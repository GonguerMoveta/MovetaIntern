// <ppj name="Moveta.Intern" date="1/17/2024 7:59:41 AM" id="F4EC85BAD2BF79AC25C9F8643540E90F9BE1DAF0"/>
// ======================================================================================================
// This code was generated by the Ice Porter(tm) Tool version 4.8.15.0
// Ice Porter is part of The Porting Project (PPJ) by Ice Tea Group, LLC.
// The generated code is not guaranteed to be accurate and to compile without
// manual modifications.
// 
// ICE TEA GROUP LLC SHALL IN NO EVENT BE LIABLE FOR ANY DAMAGES WHATSOEVER
// (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
// INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER LOSS OF ANY KIND)
// ARISING OUT OF THE USE OR INABILITY TO USE THE GENERATED CODE, WHETHER
// DIRECT, INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR OTHERWISE, REGARDLESS
// OF THE FORM OF ACTION, EVEN IF ICE TEA GROUP LLC HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
// =====================================================================================================
using System;
using System.Text;
using System.Drawing;
using System.Diagnostics;
using System.Collections;
using System.Windows.Forms;
using System.ComponentModel;
using System.Runtime.InteropServices;
using MT;
using PPJ.Runtime;
using PPJ.Runtime.Com;
using PPJ.Runtime.Sql;
using PPJ.Runtime.Vis;
using PPJ.Runtime.Windows;
using PPJ.Runtime.Windows.QO;
using PPJ.Runtime.XSal;

namespace Moveta.Intern
{
	
	public static class Ext
	{
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber SQLAllocEnv(ref SalNumber param1)
		{
			SalNumber retVal = 0;
			//FC:FINAL: not needed anymore
			//System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);


			//retVal = ODBC32.SQLAllocEnv(_param1);

			//param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SQLAllocConnect(SalNumber param1, ref SalNumber param2)
		{
			SalNumber retVal = 0;
            //FC:FINAL: not needed anymore
            //int _param1 = (int)param1;
            //System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);


            //retVal = ODBC32.SQLAllocConnect(_param1, _param2);

            //param2 = _param2.ToString();
            return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber SQLFreeEnv(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = ODBC32.SQLFreeEnv(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber SQLFreeConnect(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = ODBC32.SQLFreeConnect(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalNumber SQLConnect(SalNumber param1, SalString param2, SalNumber param3, SalString param4, SalNumber param5, SalString param6, SalNumber param7)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			short _param3 = (short)param3;
			string _param4 = param4.Value;
			short _param5 = (short)param5;
			string _param6 = param6.Value;
			short _param7 = (short)param7;


			retVal = ODBC32.SQLConnect(_param1, _param2, _param3, _param4, _param5, _param6, _param7);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber SQLDisconnect(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = ODBC32.SQLDisconnect(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalNumber SQLDriverConnect(SalNumber param1, SalWindowHandle param2, SalString param3, SalNumber param4, ref SalString param5, SalNumber param6, ref SalNumber param7, SalNumber param8)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalNumber SQLError(SalNumber param1, SalNumber param2, SalNumber param3, ref SalString param4, ref SalNumber param5, ref SalString param6, SalNumber param7, ref SalNumber param8)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			System.Text.StringBuilder _param4 = new System.Text.StringBuilder(param4.Value);
			uint _param5 = (uint)param5;
			System.Text.StringBuilder _param6 = new System.Text.StringBuilder(param6.Value);
			short _param7 = (short)param7;
			short _param8 = (short)param8;


			retVal = ODBC32.SQLError(_param1, _param2, _param3, _param4, ref _param5, _param6, _param7, ref _param8);

			param4 = _param4.ToString();
			param5 = _param5;
			param6 = _param6.ToString();
			param8 = _param8;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber ShellExecuteA(SalWindowHandle param1, SalString param2, SalString param3, SalString param4, SalString param5, SalNumber param6)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			string _param2 = param2.Value;
			string _param3 = param3.Value;
			string _param4 = param4.Value;
			string _param5 = param5.Value;
			int _param6 = (int)param6;


			retVal = SHELL32.ShellExecuteA(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// SetSysColors( 1, nIndex, nColor )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean SetSysColors(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			int _param1 = (int)param1;

			Structures.STRUCT_1 _struct1 = new Structures.STRUCT_1();
			Structures.STRUCT_2 _struct2 = new Structures.STRUCT_2();
			_struct1.Member1 = (int)param2;
			_struct2.Member1 = (uint)param3;

			retVal = USER32.SetSysColors(_param1, ref _struct1, ref _struct2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <param name="param11"></param>
		/// <param name="param12"></param>
		/// <returns></returns>
		public static SalWindowHandle CreateWindowExA(SalNumber param1, SalString param2, SalString param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalNumber param8, SalWindowHandle param9, SalNumber param10, SalNumber param11, SalNumber param12)
		{
			SalWindowHandle retVal = 0;
			uint _param1 = (uint)param1;
			string _param2 = param2.Value;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			int _param5 = (int)param5;
			int _param6 = (int)param6;
			int _param7 = (int)param7;
			int _param8 = (int)param8;
			System.IntPtr _param9 = (System.IntPtr)param9;
			int _param10 = (int)param10;
			uint _param11 = (uint)param11;
			int _param12 = (int)param12;


			retVal = USER32.CreateWindowExA(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8, _param9, _param10, _param11, _param12);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DestroyWindow(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.DestroyWindow(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetClientRect(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.GetClientRect(_param1, ref _struct1);

			param2 = (SalNumber)_struct1.Member1;
			param3 = (SalNumber)_struct1.Member2;
			param4 = (SalNumber)_struct1.Member3;
			param5 = (SalNumber)_struct1.Member4;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetWindowRect(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.GetWindowRect(_param1, ref _struct1);

			param2 = (SalNumber)_struct1.Member1;
			param3 = (SalNumber)_struct1.Member2;
			param4 = (SalNumber)_struct1.Member3;
			param5 = (SalNumber)_struct1.Member4;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalBoolean MoveWindow(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalBoolean param6)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			bool _param6 = (bool)param6;


			retVal = USER32.MoveWindow(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean UnregisterClassA(SalString param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;


			retVal = USER32.UnregisterClassA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// ! 17.12.14 Ä1140
		/// function disables the window ghosting feature for the calling GUI process.
		///                      Window ghosting is a Windows Manager feature that lets the user minimize, move, or close the main window of an  application that is not responding.
		///                     (http://msdn.microsoft.com/en-us/library/windows/desktop/ms648415(v=vs.85).aspx)
		/// </summary>
		/// <returns></returns>
		public static SalNumber DisableProcessWindowsGhosting()
		{


			USER32.DisableProcessWindowsGhosting();

			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public static SalBoolean AtlAxWinInit()
		{
			SalBoolean retVal = false;


			retVal = ATL.AtlAxWinInit();

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3">String: LPVOID</param>
		/// <param name="param4">Receive String: LPVOID</param>
		/// <returns></returns>
		public static SalNumber AtlAxCreateControl(SalString param1, SalWindowHandle param2, SalNumber param3, ref SalNumber param4)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			System.IntPtr _param2 = (System.IntPtr)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;


			retVal = ATL.AtlAxCreateControl(_param1, _param2, _param3, ref _param4);

			param4 = _param4;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber ConnectServer(ref SalNumber param1, SalString param2, SalString param3)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber DisconnectServer(SalNumber param1)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber InstallDatabase(SalNumber param1, SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber DeinstallDatabase(SalNumber param1, SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CharToOemA(SalString param1, SalString param2)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			string _param2 = param2.Value;


			retVal = USER32.CharToOemA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// Eigtl. OemToCharA
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber OemToCharA(SalString param1, SalString param2)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			string _param2 = param2.Value;


			retVal = USER32.OemToCharA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetComputerNameA(ref SalString param1, ref SalNumber param2)
		{
			SalBoolean retVal = false;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);
			uint _param2 = (uint)param2;


			retVal = KERNEL32.GetComputerNameA(_param1, ref _param2);

			param1 = _param1.ToString();
			param2 = _param2;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetUserNameA(ref SalString param1, ref SalNumber param2)
		{
			SalBoolean retVal = false;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);
			uint _param2 = (uint)param2;


			retVal = ADVAPI32.GetUserNameA(_param1, ref _param2);

			param1 = _param1.ToString();
			param2 = _param2;
			return retVal;
		}
		
		/// <summary>
		/// function RegCloseKey(hKey: HKEY): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber RegCloseKey(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = ADVAPI32.RegCloseKey(_param1);

			return retVal;
		}
		
		/// <summary>
		/// function RegCreateKeyExA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   Reserved: DWORD;
		///   lpClass: PAnsiChar;
		///   dwOptions: DWORD;
		///   samDesired: REGSAM;
		///   lpSecurityAttributes: PSecurityAttributes;
		///   var phkResult: HKEY;
		///   lpdwDisposition: PDWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <returns></returns>
		public static SalNumber RegCreateKeyExA(SalNumber param1, SalString param2, SalNumber param3, SalString param4, SalNumber param5, SalNumber param6, SalString param7, ref SalNumber param8, ref SalNumber param9)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			string _param4 = param4.Value;
			uint _param5 = (uint)param5;
			uint _param6 = (uint)param6;
			string _param7 = param7.Value;
			int _param8 = (int)param8;
			int _param9 = (int)param9;


			retVal = ADVAPI32.RegCreateKeyExA(_param1, _param2, _param3, _param4, _param5, _param6, _param7, ref _param8, ref _param9);

			param8 = _param8;
			param9 = _param9;
			return retVal;
		}
		
		/// <summary>
		/// function RegEnumKeyExA(
		///   hKey: HKEY;
		///   dwIndex: DWORD;
		///   lpName: PAnsiChar;
		///   var lpcbName: DWORD;
		///   lpReserved: Pointer;
		///   lpClass: PAnsiChar;
		///   lpcbClass: PDWORD;
		///   lpftLastWriteTime: PFileTime): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalNumber RegEnumKeyExA(SalNumber param1, SalNumber param2, SalString param3, ref SalNumber param4, SalString param5, SalString param6, ref SalNumber param7, ref SalNumber param8, ref SalNumber param9)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			uint _param2 = (uint)param2;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			string _param6 = param6.Value;
			uint _param7 = (uint)param7;

			Structures.STRUCT_4 _struct1 = new Structures.STRUCT_4();
			_struct1.Member1 = (uint)param8;
			_struct1.Member2 = (uint)param9;

			retVal = ADVAPI32.RegEnumKeyExA(_param1, _param2, _param3, ref _param4, _param5, _param6, ref _param7, ref _struct1);

			param8 = (SalNumber)_struct1.Member1;
			param9 = (SalNumber)_struct1.Member2;
			param4 = _param4;
			param7 = _param7;
			return retVal;
		}
		
		/// <summary>
		/// function RegEnumKeyExA(
		///   hKey: HKEY;
		///   dwIndex: DWORD;
		///   lpName: PAnsiChar;
		///   var lpcbName: DWORD;
		///   lpReserved: Pointer;
		///   lpClass: PAnsiChar;
		///   lpcbClass: PDWORD;
		///   lpftLastWriteTime: PFileTime): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalNumber RegEnumKeyExW(SalNumber param1, SalNumber param2, SalString param3, ref SalNumber param4, SalString param5, SalString param6, ref SalNumber param7, ref SalNumber param8, ref SalNumber param9)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			uint _param2 = (uint)param2;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			string _param6 = param6.Value;
			uint _param7 = (uint)param7;

			Structures.STRUCT_4 _struct1 = new Structures.STRUCT_4();
			_struct1.Member1 = (uint)param8;
			_struct1.Member2 = (uint)param9;

			retVal = ADVAPI32.RegEnumKeyExW(_param1, _param2, _param3, ref _param4, _param5, _param6, ref _param7, ref _struct1);

			param8 = (SalNumber)_struct1.Member1;
			param9 = (SalNumber)_struct1.Member2;
			param4 = _param4;
			param7 = _param7;
			return retVal;
		}
		
		/// <summary>
		/// function RegEnumValueA(
		///   hKey: HKEY;
		///   dwIndex: DWORD;
		///   lpValueName: PChar;
		///   var lpcbValueName: DWORD;
		///   lpReserved: Pointer;
		///   lpType: PDWORD;
		///   lpData: PByte;
		///   lpcbData: PDWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalNumber RegEnumValueA(SalNumber param1, SalNumber param2, SalString param3, ref SalNumber param4, SalString param5, ref SalNumber param6, SalString param7, ref SalNumber param8)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			uint _param2 = (uint)param2;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			uint _param6 = (uint)param6;
			string _param7 = param7.Value;
			uint _param8 = (uint)param8;


			retVal = ADVAPI32.RegEnumValueA(_param1, _param2, _param3, ref _param4, _param5, ref _param6, _param7, ref _param8);

			param4 = _param4;
			param6 = _param6;
			param8 = _param8;
			return retVal;
		}
		
		/// <summary>
		/// function RegEnumValueA(
		///   hKey: HKEY;
		///   dwIndex: DWORD;
		///   lpValueName: PChar;
		///   var lpcbValueName: DWORD;
		///   lpReserved: Pointer;
		///   lpType: PDWORD;
		///   lpData: PByte;
		///   lpcbData: PDWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalNumber RegEnumValueW(SalNumber param1, SalNumber param2, SalString param3, ref SalNumber param4, SalString param5, ref SalNumber param6, SalString param7, ref SalNumber param8)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			uint _param2 = (uint)param2;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			uint _param6 = (uint)param6;
			string _param7 = param7.Value;
			uint _param8 = (uint)param8;


			retVal = ADVAPI32.RegEnumValueW(_param1, _param2, _param3, ref _param4, _param5, ref _param6, _param7, ref _param8);

			param4 = _param4;
			param6 = _param6;
			param8 = _param8;
			return retVal;
		}
		
		/// <summary>
		/// function RegFlushKey(
		/// hKey: HKEY): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber RegFlushKey(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = ADVAPI32.RegFlushKey(_param1);

			return retVal;
		}
		
		/// <summary>
		/// function RegOpenKeyExA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   ulOptions: DWORD;
		///   samDesired: REGSAM;
		///   var phkResult: HKEY): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber RegOpenKeyExA(SalNumber param1, SalString param2, SalNumber param3, SalNumber param4, ref SalNumber param5)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			int _param5 = (int)param5;


			retVal = ADVAPI32.RegOpenKeyExA(_param1, _param2, _param3, _param4, ref _param5);

			param5 = _param5;
			return retVal;
		}
		
		/// <summary>
		/// function RegOpenKeyExA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   ulOptions: DWORD;
		///   samDesired: REGSAM;
		///   var phkResult: HKEY): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber RegOpenKeyExW(SalNumber param1, SalString param2, SalNumber param3, SalNumber param4, ref SalNumber param5)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			int _param5 = (int)param5;


			retVal = ADVAPI32.RegOpenKeyExW(_param1, _param2, _param3, _param4, ref _param5);

			param5 = _param5;
			return retVal;
		}
		
		/// <summary>
		/// function RegQueryInfoKeyA(
		///   hKey: HKEY;
		///   lpClass: PChar;
		///   lpcbClass: PDWORD;
		///   lpReserved: Pointer;
		///   lpcSubKeys,
		///   lpcbMaxSubKeyLen,
		///   lpcbMaxClassLen,
		///   lpcValues,
		///   lpcbMaxValueNameLen,
		///   lpcbMaxValueLen,
		///   lpcbSecurityDescriptor: PDWORD;
		///   lpftLastWriteTime: PFileTime): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <param name="param11"></param>
		/// <param name="param12"></param>
		/// <returns></returns>
		public static SalNumber RegQueryInfoKeyA(SalNumber param1, SalString param2, ref SalNumber param3, SalString param4, ref SalNumber param5, ref SalNumber param6, ref SalNumber param7, ref SalNumber param8, ref SalNumber param9, ref SalNumber param10, ref SalNumber param11, ref SalNumber param12, ref SalNumber param13)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			string _param4 = param4.Value;
			uint _param5 = (uint)param5;
			uint _param6 = (uint)param6;
			uint _param7 = (uint)param7;
			uint _param8 = (uint)param8;
			uint _param9 = (uint)param9;
			uint _param10 = (uint)param10;
			uint _param11 = (uint)param11;

			Structures.STRUCT_4 _struct1 = new Structures.STRUCT_4();
			_struct1.Member1 = (uint)param12;
			_struct1.Member2 = (uint)param13;

			retVal = ADVAPI32.RegQueryInfoKeyA(_param1, _param2, ref _param3, _param4, ref _param5, ref _param6, ref _param7, ref _param8, ref _param9, ref _param10, ref _param11, ref _struct1);

			param12 = (SalNumber)_struct1.Member1;
			param13 = (SalNumber)_struct1.Member2;
			param3 = _param3;
			param5 = _param5;
			param6 = _param6;
			param7 = _param7;
			param8 = _param8;
			param9 = _param9;
			param10 = _param10;
			param11 = _param11;
			return retVal;
		}
		
		/// <summary>
		/// function RegQueryInfoKeyA(
		///   hKey: HKEY;
		///   lpClass: PChar;
		///   lpcbClass: PDWORD;
		///   lpReserved: Pointer;
		///   lpcSubKeys,
		///   lpcbMaxSubKeyLen,
		///   lpcbMaxClassLen,
		///   lpcValues,
		///   lpcbMaxValueNameLen,
		///   lpcbMaxValueLen,
		///   lpcbSecurityDescriptor: PDWORD;
		///   lpftLastWriteTime: PFileTime): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <param name="param11"></param>
		/// <param name="param12"></param>
		/// <returns></returns>
		public static SalNumber RegQueryInfoKeyW(SalNumber param1, SalString param2, ref SalNumber param3, SalString param4, ref SalNumber param5, ref SalNumber param6, ref SalNumber param7, ref SalNumber param8, ref SalNumber param9, ref SalNumber param10, ref SalNumber param11, ref SalNumber param12, ref SalNumber param13)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			string _param4 = param4.Value;
			uint _param5 = (uint)param5;
			uint _param6 = (uint)param6;
			uint _param7 = (uint)param7;
			uint _param8 = (uint)param8;
			uint _param9 = (uint)param9;
			uint _param10 = (uint)param10;
			uint _param11 = (uint)param11;

			Structures.STRUCT_4 _struct1 = new Structures.STRUCT_4();
			_struct1.Member1 = (uint)param12;
			_struct1.Member2 = (uint)param13;

			retVal = ADVAPI32.RegQueryInfoKeyW(_param1, _param2, ref _param3, _param4, ref _param5, ref _param6, ref _param7, ref _param8, ref _param9, ref _param10, ref _param11, ref _struct1);

			param12 = (SalNumber)_struct1.Member1;
			param13 = (SalNumber)_struct1.Member2;
			param3 = _param3;
			param5 = _param5;
			param6 = _param6;
			param7 = _param7;
			param8 = _param8;
			param9 = _param9;
			param10 = _param10;
			param11 = _param11;
			return retVal;
		}
		
		/// <summary>
		/// function RegQueryValueExA(
		///   hKey: HKEY;
		///   lpValueName: PAnsiChar;
		///   lpReserved: Pointer;
		///   lpType: PDWORD;
		///   lpData: PByte;
		///   lpcbData: PDWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber RegQueryValueExA(SalNumber param1, SalString param2, SalString param3, ref SalNumber param4, ref SalString param5, ref SalNumber param6)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			System.Text.StringBuilder _param5 = new System.Text.StringBuilder(param5.Value);
			uint _param6 = (uint)param6;


			retVal = ADVAPI32.RegQueryValueExA(_param1, _param2, _param3, ref _param4, _param5, ref _param6);

			param4 = _param4;
			param5 = _param5.ToString();
			param6 = _param6;
			return retVal;
		}
		
		/// <summary>
		/// function RegQueryValueExA(
		///   hKey: HKEY;
		///   lpValueName: PAnsiChar;
		///   lpReserved: Pointer;
		///   lpType: PDWORD;
		///   lpData: PByte;
		///   lpcbData: PDWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber RegQueryValueExW(SalNumber param1, SalString param2, SalString param3, ref SalNumber param4, ref SalString param5, ref SalNumber param6)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			string _param3 = param3.Value;
			uint _param4 = (uint)param4;
			System.Text.StringBuilder _param5 = new System.Text.StringBuilder(param5.Value);
			uint _param6 = (uint)param6;


			retVal = ADVAPI32.RegQueryValueExW(_param1, _param2, _param3, ref _param4, _param5, ref _param6);

			param4 = _param4;
			param5 = _param5.ToString();
			param6 = _param6;
			return retVal;
		}
		
		/// <summary>
		/// function RegSetValueExA(
		///   hKey: HKEY;
		///   lpValueName: PAnsiChar;
		///   Reserved: DWORD;
		///   dwType: DWORD;
		///   lpData: Pointer;
		///   cbData: DWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber RegSetValueExA(SalNumber param1, SalString param2, SalNumber param3, SalNumber param4, SalString param5, SalNumber param6)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			uint _param6 = (uint)param6;


			retVal = ADVAPI32.RegSetValueExA(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// function RegSetValueExA(
		///   hKey: HKEY;
		///   lpValueName: PAnsiChar;
		///   Reserved: DWORD;
		///   dwType: DWORD;
		///   lpData: Pointer;
		///   cbData: DWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber RegSetValueExW(SalNumber param1, SalString param2, SalNumber param3, SalNumber param4, SalString param5, SalNumber param6)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			uint _param6 = (uint)param6;


			retVal = ADVAPI32.RegSetValueExW(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// function RegDeleteKeyA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber RegDeleteKeyA(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;


			retVal = ADVAPI32.RegDeleteKeyA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// function RegDeleteKeyA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber RegDeleteKeyW(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;


			retVal = ADVAPI32.RegDeleteKeyW(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// function RegDeleteValueA(
		///   hKey: HKEY;
		///   lpValueName: PAnsiChar): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber RegDeleteValueA(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;


			retVal = ADVAPI32.RegDeleteValueA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// function RegDeleteValueA(
		///   hKey: HKEY;
		///   lpValueName: PAnsiChar): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber RegDeleteValueW(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;


			retVal = ADVAPI32.RegDeleteValueW(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// Function: RegEnumKeyA
		/// Description: function RegEnumKeyA(
		///   hKey: HKEY;
		///   dwIndex: DWORD;
		///   lpName: PAnsiChar;
		///   cbName: DWORD): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// Number: LONG
		/// Number: DWORD
		/// String: LPSTR
		/// Number: DWORD
		/// Function: RegEnumValueA
		/// Description: function RegEnumValueA(
		///   hKey: HKEY;
		///   dwIndex: DWORD;
		///   lpValueName: PChar;
		///   var lpcbValueName: DWORD;
		///   lpReserved: Pointer;
		///   lpType: PDWORD;
		///   lpData: PByte;
		///   lpcbData: PDWORD): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// Number: LONG
		/// Number: DWORD
		/// String: LPSTR
		/// Receive Number: LPDWORD
		/// String: LPVOID
		/// Receive Number: LPDWORD
		/// Receive Number: LPBYTE
		/// Receive Number: LPDWORD
		/// Function: RegGetKeySecurity
		/// Description: function RegGetKeySecurity(
		///   hKey: HKEY;
		///   SecurityInformation: SECURITY_INFORMATION;
		///   pSecurityDescriptor: PSecurityDescriptor;
		///   var lpcbSecurityDescriptor: DWORD): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// Number: LONG
		/// Number: DWORD
		/// Receive String: LPVOID
		/// Receive Number: LPDWORD
		/// Function: RegOpenKeyA
		/// Description: function RegOpenKeyA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   var phkResult: HKEY): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// Number: LONG
		/// String: LPSTR
		/// Receive Number: LPLONG
		/// Function: RegQueryInfoKeyA
		/// Description: function RegQueryInfoKeyA(
		///   hKey: HKEY;
		///   lpClass: PChar;
		///   lpcbClass: PDWORD;
		///   lpReserved: Pointer;
		///   lpcSubKeys,
		///   lpcbMaxSubKeyLen,
		///   lpcbMaxClassLen,
		///   lpcValues,
		///   lpcbMaxValueNameLen,
		///   lpcbMaxValueLen,
		///   lpcbSecurityDescriptor: PDWORD;
		///   lpftLastWriteTime: PFileTime): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Boolean: BOOL
		/// Parameters
		/// Number: LONG
		/// String: LPSTR
		/// Receive Number: LPDWORD
		/// String: LPVOID
		/// Receive Number: LPDWORD
		/// Receive Number: LPDWORD
		/// Receive Number: LPDWORD
		/// Receive Number: LPDWORD
		/// Receive Number: LPDWORD
		/// Receive Number: LPDWORD
		/// Receive Number: LPDWORD
		/// structPointer
		/// Receive Number: DWORD
		/// Receive Number: DWORD
		/// Function: RegQueryValueA
		/// Description: function RegQueryValueA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   lpValue: PAnsiChar;
		///   var lpcbValue: Longint): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// Number: LONG
		/// String: LPSTR
		/// String: LPSTR
		/// Receive Number: LPLONG
		/// Function: RegConnectRegistryA
		/// Description: function RegConnectRegistryA(
		/// lpMachineName: PAnsiChar;
		/// hKey: HKEY;
		/// var phkResult: HKEY): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// String: LPSTR
		/// Number: LONG
		/// Receive Number: LPLONG
		/// Function: RegCreateKeyA
		/// Description: function RegCreateKeyA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   var phkResult: HKEY): Longint;
		/// Export Ordinal: 0
		/// Returns
		/// Number: LONG
		/// Parameters
		/// Number: LONG
		/// String: LPSTR
		/// Receive Number: LPLONG
		/// function RegCreateKeyExA(
		///   hKey: HKEY;
		///   lpSubKey: PAnsiChar;
		///   Reserved: DWORD;
		///   lpClass: PAnsiChar;
		///   dwOptions: DWORD;
		///   samDesired: REGSAM;
		///   lpSecurityAttributes: PSecurityAttributes;
		///   var phkResult: HKEY;
		///   lpdwDisposition: PDWORD): Longint;
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <returns></returns>
		public static SalNumber RegCreateKeyExW(SalNumber param1, SalString param2, SalNumber param3, SalString param4, SalNumber param5, SalNumber param6, SalString param7, ref SalNumber param8, ref SalNumber param9)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			string _param4 = param4.Value;
			uint _param5 = (uint)param5;
			uint _param6 = (uint)param6;
			string _param7 = param7.Value;
			int _param8 = (int)param8;
			int _param9 = (int)param9;


			retVal = ADVAPI32.RegCreateKeyExW(_param1, _param2, _param3, _param4, _param5, _param6, _param7, ref _param8, ref _param9);

			param8 = _param8;
			param9 = _param9;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalBoolean MImgAddShadow(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets an image as null terminated string.
		/// </summary>
		/// <param name="param1">Handle of the image</param>
		/// <param name="param2">The string</param>
		/// <param name="param3">Image type. Specify MIMG_TYPE_UNKNOWN to use the current image type or one of the supported image types.</param>
		/// <returns></returns>
		public static SalBoolean MImgGetStringNT(SalNumber param1, ref SalString param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Determines whether an image has any transparency.
		/// </summary>
		/// <param name="param1">Handle of the image</param>
		/// <returns></returns>
		public static SalBoolean MImgHasOpacity(SalNumber param1)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Loads an image from a named resource of a module, e.g. a DLL or an EXE.
		/// </summary>
		/// <param name="param1">The name of the module.</param>
		/// <param name="param2">Specify MIMG_TYPE_ICO to load an icon resource or MIMG_TYPE_BMP to load a bitmap resource.</param>
		/// <param name="param3">The name of the resource to load</param>
		/// <param name="param4">Frame number. See About Frames for further information</param>
		/// <returns>Handle of the image or 0 if an error occurs</returns>
		public static SalNumber MImgLoadFromModuleNamed(SalString param1, SalNumber param2, SalString param3, SalNumber param4)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Puts a text aligned into an image.
		/// 
		/// Remarks
		/// If the image has a palette ( BPP < 24 ) and the color isn't in the palette, the nearest color from the palette is used.
		/// The opacity values of the text's pixels remain unchanged.
		/// </summary>
		/// <param name="param1">Handle of the image</param>
		/// <param name="param2">(left) Rectangle to put the text into.</param>
		/// <param name="param3">The text</param>
		/// <param name="param4">Font name</param>
		/// <param name="param5">Font size</param>
		/// <param name="param6">Font enhancements. Any combination of Gupta's FONT_Enh constants.</param>
		/// <param name="param7">Text color</param>
		/// <param name="param8">One horizontal and one vertical align flag ( MIMG_ALIGN_... )</param>
		/// <returns></returns>
		public static SalBoolean MImgPutTextAligned(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalString param6, SalString param7, SalNumber param8, SalNumber param9, SalNumber param10, SalNumber param11)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber StringFromGUID2(SalNumber param1, SalNumber param2, SalNumber param3, SalString param4, ref SalString param5, SalNumber param6)
		{
			SalNumber retVal = 0;
			int _param6 = (int)param6;

			Structures.STRUCT_5 _struct1 = new Structures.STRUCT_5();
			Structures.STRUCT_6 _struct2 = new Structures.STRUCT_6();
			_struct1.Member1 = (uint)param1;
			_struct1.Member2 = (ushort)param2;
			_struct1.Member3 = (ushort)param3;
			_struct1.Member4 = param4.Value;
			_struct2.Member1 = new System.Text.StringBuilder(param5.Value);

			retVal = OLE32.StringFromGUID2(ref _struct1, ref _struct2, _param6);

			param5 = _struct2.Member1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber CoCreateGuid(ref SalString param1)
		{
			SalNumber retVal = 0;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);


			retVal = OLE32.CoCreateGuid(_param1);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3">String: LPVOID</param>
		/// <returns></returns>
		public static SalNumber wsprintfA(ref SalString param1, SalString param2, SalNumber param3)
		{
			// String: LPSTR
			// String: LPSTR
			// String: LPSTR
			// String: LPSTR
			SalNumber retVal = 0;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);
			string _param2 = param2.Value;
			int _param3 = (int)param3;


			retVal = USER32.wsprintfA(_param1, _param2, _param3);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber SmtpConnect(SalString param1, SalNumber param2, SalString param3, SalString param4, SalBoolean param5, ref SalNumber param6)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			int _param2 = (int)param2;
			string _param3 = param3.Value;
			string _param4 = param4.Value;
			bool _param5 = (bool)param5;
			uint _param6 = (uint)param6;


			retVal = SALMAIL62.SmtpConnect(_param1, _param2, _param3, _param4, _param5, ref _param6);

			param6 = _param6;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber Pop3Connect(SalString param1, SalNumber param2, SalString param3, SalString param4, SalBoolean param5, ref SalNumber param6)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			int _param2 = (int)param2;
			string _param3 = param3.Value;
			string _param4 = param4.Value;
			bool _param5 = (bool)param5;
			uint _param6 = (uint)param6;


			retVal = SALMAIL62.Pop3Connect(_param1, _param2, _param3, _param4, _param5, ref _param6);

			param6 = _param6;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber MailDisconnectEx(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = SALMAIL62.MailDisconnectEx(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <returns></returns>
		public static SalNumber SmtpSendMail(SalNumber param1, SalNumber param2, SalString param3, SalString param4, SalString param5, SalString param6, SalString param7, SalString param8, SalBoolean param9, SalNumber param10)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			byte _param2 = (byte)param2;
			string _param3 = param3.Value;
			string _param4 = param4.Value;
			string _param5 = param5.Value;
			string _param6 = param6.Value;
			string _param7 = param7.Value;
			string _param8 = param8.Value;
			bool _param9 = (bool)param9;
			byte _param10 = (byte)param10;


			retVal = SALMAIL62.SmtpSendMail(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8, _param9, _param10);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber Pop3DeleteMail(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;


			retVal = SALMAIL62.Pop3DeleteMail(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <returns></returns>
		public static SalNumber Pop3GetMail(SalNumber param1, SalNumber param2, SalNumber param3, ref SalString param4, ref SalString param5, ref SalString param6, ref SalString param7, ref SalString param8, ref SalString param9, ref SalString param10)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalNumber Pop3GetEnvelopes(SalNumber param1, SalNumber param2, SalNumber param3, SalArray<SalNumber> param4, SalArray<SalString> param5, SalArray<SalString> param6, SalArray<SalString> param7)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber Pop3GetNumberMessages(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = SALMAIL62.Pop3GetNumberMessages(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <param name="param11"></param>
		/// <returns></returns>
		public static SalNumber Pop3GetNextMail(SalNumber param1, SalNumber param2, SalNumber param3, ref SalNumber param4, ref SalString param5, ref SalString param6, ref SalString param7, ref SalString param8, ref SalString param9, ref SalString param10, ref SalString param11)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber IMAPConnect(SalString param1, SalNumber param2, SalString param3, SalString param4, SalBoolean param5)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			int _param2 = (int)param2;
			string _param3 = param3.Value;
			string _param4 = param4.Value;
			bool _param5 = (bool)param5;


			retVal = SALMAIL62.IMAPConnect(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber IMAPDeleteMail(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = SALMAIL62.IMAPDeleteMail(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <returns></returns>
		public static SalNumber IMAPGetMail(SalNumber param1, SalNumber param2, ref SalString param3, ref SalString param4, ref SalString param5, ref SalString param6, ref SalString param7, ref SalString param8, ref SalString param9)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber IMAPGetEnvelopes(SalNumber param1, SalNumber param2, SalArray<SalNumber> param3, SalArray<SalString> param4, SalArray<SalString> param5, SalArray<SalString> param6)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <returns></returns>
		public static SalNumber IMAPGetNextMail(SalNumber param1, SalNumber param2, ref SalNumber param3, ref SalString param4, ref SalString param5, ref SalString param6, ref SalString param7, ref SalString param8, ref SalString param9, ref SalString param10)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public static SalNumber IMAPGetNumberMessages()
		{
			SalNumber retVal = 0;


			retVal = SALMAIL62.IMAPGetNumberMessages();

			return retVal;
		}
		
		/// <summary>
		/// Calculates the row height in pixels for a given number of lines per row.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Number of lines per row to use for calculation. Min. value = 1.</param>
		/// <returns></returns>
		public static SalNumber MTblCalcRowHeight(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Defines the highlighting settings for an item type.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Item type ( MTBL_ITEM_... )</param>
		/// <param name="param3">Item part ( MTBL_PART_... )</param>
		/// <param name="param4">fcMTblHiLiDef-Object</param>
		/// <param name="param5">Flags ( MTDHL_... )</param>
		/// <returns></returns>
		public static SalBoolean MTblDefineHighlighting(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalFunctionalClass param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber MTblEnumFonts(SalArray<SalString> param1)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber MTblEnumFontSizes(SalString param1, SalArray<SalNumber> param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets a cell's indent level.
		/// </summary>
		/// <param name="param1">Handle of the column</param>
		/// <param name="param2">Row number</param>
		/// <param name="param3">Contains the indent level if the function returns successfully</param>
		/// <returns></returns>
		public static SalBoolean MTblGetCellIndentLevel(SalWindowHandle param1, SalNumber param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets the window handle of the current edit control.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <returns></returns>
		public static SalWindowHandle MTblGetEditHandle(SalWindowHandle param1)
		{
			SalWindowHandle retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets a cell's effective indent in pixels ( = [cell indent level] * [indent per level] )
		/// </summary>
		/// <param name="param1">Handle of the column</param>
		/// <param name="param2">Row number</param>
		/// <param name="param3">Contains the effective indent in pixels if the function returns successfully</param>
		/// <returns></returns>
		public static SalBoolean MTblGetEffCellIndent(SalWindowHandle param1, SalNumber param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets the effective highlighting settings of an item.
		/// </summary>
		/// <param name="param1">fcMTblItem-Object</param>
		/// <param name="param2">fcMTblHiLiDef-Object</param>
		/// <returns></returns>
		public static SalBoolean MTblGetEffHighlighting(SalFunctionalClass param1, SalFunctionalClass param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets the indent per level in pixels.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Contains the indent per level in pixels if the function returns successfully</param>
		/// <returns></returns>
		public static SalBoolean MTblGetIndentPerLevel(SalWindowHandle param1, ref SalNumber param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Retrieves the registered language file related to a language ID.
		/// </summary>
		/// <param name="param1">Language ID</param>
		/// <param name="param2">Contains the full path to the language file if the function returns successfully</param>
		/// <returns></returns>
		public static SalBoolean MTblGetLanguageFile(SalNumber param1, ref SalString param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Retrieves a language-specific string.
		/// </summary>
		/// <param name="param1">Language ID</param>
		/// <param name="param2">The name of the section to search for</param>
		/// <param name="param3">The name of the string to retrieve</param>
		/// <param name="param4">Contains the language-specific string if the function returns successfully</param>
		/// <returns></returns>
		public static SalBoolean MTblGetLanguageString(SalNumber param1, SalString param2, SalString param3, ref SalString param4)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Retrieves the last row which is merged with the specified row.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Contains the last row which is merged with the specified row if the function returns successfully</param>
		/// <returns></returns>
		public static SalNumber MTblGetLastMergedRow(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Retrieves the row with which the specified row is merged
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Contains the row with which the specified row is merged if the function returns successfully</param>
		/// <returns></returns>
		public static SalNumber MTblGetMergeRow(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets the node images.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Handle of the image which is displayed when a row is NOT expanded</param>
		/// <param name="param3">Handle of the image which is displayed when a row is expanded</param>
		/// <returns></returns>
		public static SalBoolean MTblGetNodeImages(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Gets a row's original parent row.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Row whose original parent row you want to get</param>
		/// <returns>Original parent row if successful, TBL_Error when not found or an error occurs</returns>
		public static SalNumber MTblGetOrigParentRow(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Retrieves a row's merge settings.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Row number</param>
		/// <param name="param3">Receive Number:Contains the number of merged rows if the function returns successfully</param>
		/// <returns></returns>
		public static SalBoolean MTblGetRowMerge(SalWindowHandle param1, SalNumber param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Returns, if the passed coordinates are over a column header separator, the handle of the column the separator belongs to.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Screen pixel X coordinate relative to upper left corner of the table.</param>
		/// <param name="param3">Screen pixel Y coordinate relative to upper left corner of the table.</param>
		/// <returns></returns>
		public static SalWindowHandle MTblGetSepCol(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalWindowHandle retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Returns, if the passed coordinates are over a row header separator, the number of the row the separator belongs to.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Screen pixel X coordinate relative to upper left corner of the table.</param>
		/// <param name="param3">Screen pixel Y coordinate relative to upper left corner of the table.</param>
		/// <returns></returns>
		public static SalNumber MTblGetSepRow(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Determines whether an item is highlighted.
		/// </summary>
		/// <param name="param1">fcMTblItem-Object</param>
		/// <returns></returns>
		public static SalBoolean MTblIsHighlighted(SalFunctionalClass param1)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Queries the current cell mode definition.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">TRUE = active, FALSE = not active</param>
		/// <param name="param3">Flags ( MTBL_CM_FLAG_... )</param>
		/// <returns></returns>
		public static SalBoolean MTblQueryCellMode(SalWindowHandle param1, ref SalBoolean param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Queries the type definition of a cell and/or column.
		/// </summary>
		/// <param name="param1">Handle of the column</param>
		/// <param name="param2">Number of the row</param>
		/// <param name="param3">Cell type ( COL_CellType_... )</param>
		/// <param name="param4">Flags ( COL_CheckBox_..., COL_DropDownList_... )</param>
		/// <param name="param5">Number of lines. Valid for types COL_CellType_DropDownList and COL_CellType_PopupEdit.</param>
		/// <param name="param6">The value when a checkbox is checked. Valid for type COL_CellType_CheckBox.</param>
		/// <param name="param7">The value when a checkbox is unchecked. Valid for type COL_CellType_CheckBox.</param>
		/// <returns></returns>
		public static SalBoolean MTblQueryCellType(SalWindowHandle param1, SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5, ref SalString param6, ref SalString param7)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Queries a column's current drop down list context.
		/// </summary>
		/// <param name="param1">Column handle</param>
		/// <param name="param2">Number of the row, TBL_Error when the drop down list context is on the column.</param>
		/// <returns></returns>
		public static SalBoolean MTblQueryDropDownListContext(SalWindowHandle param1, ref SalNumber param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Queries options for extended messages.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">One or more options to test for ( MTEM_... )</param>
		/// <returns></returns>
		public static SalBoolean MTblQueryExtMsgsOptions(SalWindowHandle param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Queries the current focus frame definition.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Thickness in pixels.</param>
		/// <param name="param3">Offset from the left/right edge of the focused object. May also be negative.</param>
		/// <param name="param4">Offset from the top/bottom edge of the focused object. May also be negative.</param>
		/// <param name="param5">Color. If MTBL_COLOR_UNDEF, the focus frame has no color but inverts it's background.</param>
		/// <returns></returns>
		public static SalBoolean MTblQueryFocusFrame(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Queries the highlighting settings for an item type.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Item type ( MTBL_ITEM_... )</param>
		/// <param name="param3">Item part ( MTBL_PART_... )</param>
		/// <param name="param4">fcMTblHiLiDef-Object</param>
		/// <returns></returns>
		public static SalBoolean MTblQueryHighlighting(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalFunctionalClass param4)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Registers a language ID and its related language file.
		/// </summary>
		/// <param name="param1">Language ID</param>
		/// <param name="param2">Language file. If no path is given, M!Table assumes that the file is in the same directory where mtblxx.dll is located.</param>
		/// <returns></returns>
		public static SalBoolean MTblRegisterLanguage(SalNumber param1, SalString param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Sets or clears options for extended messages.
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">One or more options to set or clear ( MTEM_... )</param>
		/// <param name="param3">Whether to set (TRUE) or clear (FALSE) the specified options</param>
		/// <returns></returns>
		public static SalBoolean MTblSetExtMsgsOptions(SalWindowHandle param1, SalNumber param2, SalBoolean param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Sets or removes the highlighted state of an item.
		/// </summary>
		/// <param name="param1">fcMTblItem-Object</param>
		/// <param name="param2">TRUE to set or FALSE to remove the highlighted state</param>
		/// <returns></returns>
		public static SalBoolean MTblSetHighlighted(SalFunctionalClass param1, SalBoolean param2)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Merges a row with a certain number of  rows below
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">Number of the row</param>
		/// <param name="param3">Number of rows to merge</param>
		/// <param name="param4">Optional flags ( MTSM_... )</param>
		/// <returns></returns>
		public static SalBoolean MTblSetRowMerge(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Exports a table to Open Office Calc
		/// </summary>
		/// <param name="param1">Handle of the table</param>
		/// <param name="param2">
		/// Language. Specify MTE_LNG_GERMAN or MTE_LNG_ENGLISH.
		/// The language refers to the status dialog and messages.
		/// </param>
		/// <param name="param3">
		/// Cell in Calc that shall be the starting point.
		/// You can also specify STRING_Null for no start cell.
		/// If the flag MTE_OOCALC_CURRENT_POS is set, this parameter is ignored.
		/// </param>
		/// <param name="param4">Optional Calc flags ( MTE_OOCALC_... )</param>
		/// <param name="param5">Optional export flags ( MTE_... )</param>
		/// <param name="param6">The flags a row should have to be exported.</param>
		/// <param name="param7">The flags a row should not have to be exported.</param>
		/// <param name="param8">The flags a column should have to be exported.</param>
		/// <param name="param9">The flags a column should not have to be exported.</param>
		/// <returns>
		/// 1 if successful or one of the following error codes:
		/// MTE_ERR_CANCELLED		The user has cancelled the export.
		/// MTE_ERR_RUNNING_INSTANCE	A running instance could not be found.
		/// MTE_ERR_NEW_INSTANCE	A new instance could not be created.
		/// MTE_ERR_STATUS		An status dialog error occured.
		/// MTE_ERR_OLE_EXCEPTION	An OLE exception occured. The exception is reported to the user in a message box.
		/// MTE_ERR_EXCEPTION		Another exception occured. The exception is reported to the user in a message box.
		/// MTE_ERR_NOT_SUBCLASSED	The table isn't subclassed with MTblSubClass.
		/// </returns>
		public static SalNumber MTblExportToOOCalc(SalWindowHandle param1, SalNumber param2, SalString param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalNumber param8, SalNumber param9)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalNumber SetWindowPos(SalWindowHandle param1, SalWindowHandle param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			int _param6 = (int)param6;
			uint _param7 = (uint)param7;


			USER32.SetWindowPos(_param1, _param2, _param3, _param4, _param5, _param6, _param7);

			return 0;
		}
		
		/// <summary>
		/// Extract a byte from a buffer.
		/// nResult = CStructGetByte( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetByte(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract an integer from a buffer.
		/// nResult = CStructGetInt( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetInt(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a word from a buffer.
		/// nResult = CStructGetWord( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetWord(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a long from a buffer.
		/// nResult = CStructGetLong( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetLong(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a float from a buffer.
		/// nResult = CStructGetFloat( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetFloat(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a double from a buffer.
		/// nResult = CStructGetDouble( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetDouble(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a BFloat from a buffer and convert to double.
		/// nResult = CStructGetBFloat( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetBFloat(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a string from a buffer.
		/// nLength = CStructGetString( strBuffer, nOffset, nMaxWidth, strExtract )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber CStructGetString(SalString param1, SalNumber param2, SalNumber param3, ref SalString param4)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a far pointer from a buffer.
		/// nFarPointer = CStructGetFarPointer( strBuffer, nOffset )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CStructGetFarPointer(ref SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a byte into a buffer.
		/// bOK = CStructPutByte( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutByte(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert an integer into a buffer.
		/// bOK = CStructPutInt( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutInt(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a word into a buffer.
		/// bOK = CStructPutWord( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutWord(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a long into a buffer.
		/// bOK = CStructPutLong( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutLong(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a byte into a buffer.
		/// bOK = CStructPutFloat( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutFloat(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a double into a buffer.
		/// bOK = CStructPutDouble( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutDouble(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Convert double to BFloat and insert it into a buffer.
		/// bOK = CStructPutBFloat( strBuffer, nOffset, nInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutBFloat(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a string into a buffer.
		/// bOK = CStructPutString( strBuffer, nOffset, nMaxWidth, strInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutString(ref SalString param1, SalNumber param2, SalNumber param3, SalString param4)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a far pointer into a buffer.
		/// bOK = CStructPutFarPointer( strBuffer, nOffset, nFarPointer )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutFarPointer(ref SalString param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Copy data from one String to another.
		/// bOK = CStructCopyBuffer( strDest, nDestOffset,
		///                          strSrc, nSrcOffset, nCopyLen )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean CStructCopyBuffer(SalString param1, SalNumber param2, SalString param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Allocate memory and return a far pointer.
		/// nFarPointer = CStructAllocFarMem( nBytes )
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber CStructAllocFarMem(SalNumber param1)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Free memory allocated by CStructAllocFarMem.
		/// bOK = CStructFreeFarMem( nFarPointer )
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean CStructFreeFarMem(SalNumber param1)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Copy data from far memory to a String.
		/// bOK = CStructCopyToFarMem( nFarPointer, strData, nDataLen  )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructCopyToFarMem(SalNumber param1, SalString param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Copy from a String to far memory.
		/// bOK = CStructCopyFromFarMem( nFarPointer, strData, nMaxLen )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CStructCopyFromFarMem(SalNumber param1, ref SalString param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Extract a string from a buffer.
		/// nLength = CStructGetStringW( strBuffer, nOffset, nMaxWidth, strExtract )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber CStructGetStringW(SalString param1, SalNumber param2, SalNumber param3, ref SalString param4)
		{
			SalNumber retVal = 0;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// Insert a string into a buffer.
		/// bOK = CStructPutStringW( strBuffer, nOffset, nMaxWidth, strInsert )
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean CStructPutStringW(ref SalString param1, SalNumber param2, SalNumber param3, SalString param4)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source
		/// device context into a destination device context.
		/// 
		/// Parameters:
		/// 	hdcDest 		Identifies the destination device context.
		/// 	nXDest 		Specifies the logical x-coordinate of the upper-left corner of the destination rectangle.
		/// 	nYDest 		Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.
		/// 	nWidth 		Specifies the logical width of the source and destination rectangles.
		/// 	nHeight 		Specifies the logical height of the source and the destination rectangles.
		/// 	hdcSrc 		Identifies the source device context.
		/// 	nXSrc 		Specifies the logical x-coordinate of the upper-left corner of the source rectangle.
		/// 	nYSrc 		Specifies the logical y-coordinate of the upper-left corner of the source rectangle.
		/// 	dwRop 		Specifies a raster-operation code. These codes define how the color data for the source rectangle is to be
		/// 			combined with the color data for the destination rectangle to achieve the final color.
		/// 			The following list shows some common raster operation codes:
		/// 			Value 			Description
		/// 			BLACKNESS 		Fills the destination rectangle using the color associated with index 0 in the physical
		/// 						palette. (This color is black for the default physical palette.)
		/// 			DSTINVERT 		Inverts the destination rectangle.
		/// 			MERGECOPY 		Merges the colors of the source rectangle with the specified pattern by using the
		/// 						Boolean AND operator.
		/// 			MERGEPAINT 		Merges the colors of the inverted source rectangle with the colors of the
		/// 						destination rectangle by using the Boolean OR operator.
		/// 			NOTSRCCOPY 		Copies the inverted source rectangle to the destination.
		/// 			NOTSRCERASE 		Combines the colors of the source and destination rectangles by using the
		/// 						Boolean OR operator and then inverts the resultant color.
		/// 			PATCOPY 		Copies the specified pattern into the destination bitmap.
		/// 			PATINVERT 		Combines the colors of the specified pattern with the colors of the destination
		/// 						rectangle by using the Boolean XOR operator.
		/// 			PATPAINT 		Combines the colors of the pattern with the colors of the inverted source rectangle
		/// 						by using the Boolean OR operator. The result of this operation is combined with the
		/// 						colors of the destination rectangle by using the Boolean OR operator.
		/// 			SRCAND 		Combines the colors of the source and destination rectangles by using the Boolean
		/// 						AND operator.
		/// 			SRCCOPY 		Copies the source rectangle directly to the destination rectangle.
		/// 			SRCERASE 		Combines the inverted colors of the destination rectangle with the colors of the
		/// 						source rectangle by using the Boolean AND operator.
		/// 			SRCINVERT 		Combines the colors of the source and destination rectangles by using the Boolean
		/// 						XOR operator.
		/// 			SRCPAINT 		Combines the colors of the source and destination rectangles by using the Boolean
		/// 						OR operator.
		/// 			WHITENESS 		Fills the destination rectangle using the color associated with index 1 in the physical
		/// 						palette. (This color is white for the default physical palette.)
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// If a rotation or shear transformation is in effect in the source device context, BitBlt returns an error. If other transformations exist in the source
		/// device context (and a matching transformation is not in effect in the destination device context), the rectangle in the destination device
		/// context is stretched, compressed, or rotated as necessary.
		/// 
		/// If the color formats of the source and destination device contexts do not match, the BitBlt function converts the source color format to match
		/// the destination format.
		/// 
		/// When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context.
		/// 
		/// Not all devices support the BitBlt function. For more information, see the RC_BITBLT raster capability entry in GetDeviceCaps.
		/// 
		/// BitBlt returns an error if the source and destination device contexts represent different devices.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <returns></returns>
		public static SalBoolean BitBlt(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalNumber param8, SalNumber param9)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			uint _param6 = (uint)param6;
			int _param7 = (int)param7;
			int _param8 = (int)param8;
			uint _param9 = (uint)param9;


			retVal = GDI32.BitBlt(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8, _param9);

			return retVal;
		}
		
		/// <summary>
		/// The CombineRgn function combines two regions and stores the result in a third region.
		/// The two regions are combined according to the specified mode.
		/// 
		/// Parameters:
		/// hrgnDest 		Handle to a new region with dimensions defined by combining two other regions.
		/// 		(This region must exist before CombineRgn is called.)
		/// hrgnSrc1 		Handle to the first of two regions to be combined.
		/// hrgnSrc2 		Handle to the second of two regions to be combined.
		/// fnCombineMode 	Specifies a mode indicating how the two regions will be combined.
		/// 		This parameter can be one of the following values:
		/// 		Value 		Description
		/// 		RGN_AND 	Creates the intersection of the two combined regions.
		/// 		RGN_COPY 	Creates a copy of the region identified by hrgnSrc1.
		/// 		RGN_DIFF 	Combines the parts of hrgnSrc1 that are not part of hrgnSrc2.
		/// 		RGN_OR 	Creates the union of two combined regions.
		/// 		RGN_XOR 	Creates the union of two combined regions except for any overlapping areas.
		/// 
		/// Return Values:
		/// The return value specifies the type of the resulting region. It can be one of the following values:
		/// Value 			Meaning
		/// NULLREGION 		The region is empty.
		/// SIMPLEREGION 		The region is a single rectangle.
		/// COMPLEXREGION 	The region is more than a single rectangle.
		/// ERROR 			No region is created.
		/// 
		/// Remarks:
		/// The three regions need not be distinct. For example, the hrgnSrc1 parameter can equal the hrgnDest parameter.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber CombineRgn(SalWindowHandle param1, SalWindowHandle param2, SalWindowHandle param3, SalNumber param4)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;
			System.IntPtr _param3 = (System.IntPtr)param3;
			int _param4 = (int)param4;


			GDI32.CombineRgn(_param1, _param2, _param3, _param4);

			return 0;
		}
		
		/// <summary>
		/// The CreateBitmap function creates a bitmap with the specified width, height, and color format (color planes and bits per pixel).
		/// 
		/// Parameters:
		/// nWidth 		Specifies the bitmap width, in pixels.
		/// nHeight 		Specifies the bitmap height, in pixels.
		/// cPlanes 		Specifies the number of color planes used by the device.
		/// cBitsPerPel 	Specifies the number of bits required to identify the color of a single pixel.
		/// lpvBits 		Pointer to an array of color data used to set the colors in a rectangle of pixels.
		/// 		Each scan line in the rectangle must be word aligned (scan lines that are not word aligned must be
		/// 		padded with zeros). If this parameter is NULL, the new bitmap is undefined.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is a handle to a bitmap.
		/// If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// After a bitmap is created, it can be selected into a device context by calling the SelectObject function.
		/// 
		/// While the CreateBitmap function can be used to create color bitmaps, for performance reasons applications
		/// should use CreateBitmap to create monochrome bitmaps and CreateCompatibleBitmap to create color bitmaps.
		/// When a color bitmap returned from CreateBitmap is selected into a device context, the system must ensure that the bitmap
		/// matches the format of the device context it is being selected into. Since CreateCompatibleBitmap takes a device context,
		/// it returns a bitmap that has the same format as the specified device context. Because of this, subsequent calls to SelectObject
		/// are faster than with a color bitmap returned from CreateBitmap.
		/// 
		/// If the bitmap is monochrome, zeros represent the foreground color and ones represent the background color for the destination
		/// device context.
		/// 
		/// If an application sets the nWidth or nHeight parameters to zero, CreateBitmap returns the handle to a 1- by 1-pixel, monochrome bitmap.
		/// 
		/// When you no longer need the bitmap, call the DeleteObject function to delete it.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber CreateBitmap(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			int _param5 = (int)param5;


			retVal = GDI32.CreateBitmap(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// The CreateCompatibleBitmap function creates a bitmap compatible with the device that is associated with the specified device context.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies a device context.
		/// 	nWidth 		Specifies the bitmap width, in pixels.
		/// 	nHeight 		Specifies the bitmap height, in pixels.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is a handle to the bitmap.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// The color format of the bitmap created by the CreateCompatibleBitmap function matches the color format of the device identified by
		/// the hdc parameter. This bitmap can be selected into any memory device context that is compatible with the original device.
		/// 
		/// Because memory device contexts allow both color and monochrome bitmaps, the format of the bitmap returned by the
		/// CreateCompatibleBitmap function differs when the specified device context is a memory device context. However, a compatible bitmap that
		/// was created for a nonmemory device context always possesses the same color format and uses the same color palette as the specified
		/// device context.
		/// 
		/// If an application sets the nWidth or nHeight parameters to zero, CreateCompatibleBitmap returns the handle of a 1- by 1-pixel, monochrome bitmap.
		/// 
		/// If a DIB section, which is a bitmap created by the CreateDIBSection function, is selected into the device context identified by the hdc parameter,
		/// CreateCompatibleBitmap creates a DIB section.
		/// 
		/// When you no longer need the bitmap, call the DeleteObject function to delete it.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber CreateCompatibleBitmap(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;


			retVal = GDI32.CreateCompatibleBitmap(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The CreateCompatibleDC function creates a memory device context (DC) compatible with the specified device.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context. If this handle is NULL, the function creates a memory device context compatible
		/// 			with the application’s current screen.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to a memory device context.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// Before an application can use a memory device context for drawing operations, it must select a bitmap of the correct width and height into
		/// the device context. Once a bitmap has been selected, the device context can be used to prepare images that will be copied to the screen or printed.
		/// 
		/// The CreateCompatibleDC function can only be used with devices that support raster operations. An application can determine whether a device
		/// supports these operations by calling the GetDeviceCaps function.
		/// 
		/// When you no longer need the memory device context, call the DeleteDC function to delete it.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber CreateCompatibleDC(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = GDI32.CreateCompatibleDC(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The CreateEllipticRgn function creates an elliptical region.
		/// 
		/// Parameters:
		/// nLeftRect 	Specifies the x-coordinate of the upper-left corner of the bounding rectangle of the ellipse.
		/// nTopRect 	Specifies the y-coordinate of the upper-left corner of the bounding rectangle of the ellipse.
		/// nRightRect 	Specifies the x-coordinate of the lower-right corner of the bounding rectangle of the ellipse.
		/// nBottomRect 	Specifies the y-coordinate of the lower-right corner of the bounding rectangle of the ellipse.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is the handle to the region.
		/// If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle
		/// define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis;
		/// and the center of the rectangle defines the intersection of the major and minor axes.
		/// 
		/// The coordinates of the bounding rectangle are specified in logical units.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalWindowHandle CreateEllipticRgn(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalWindowHandle retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;


			retVal = GDI32.CreateEllipticRgn(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The CreateFont function creates a logical font that has specific characteristics. The logical font can subsequently be selected as the font for any device.
		/// 
		/// Parameters:
		/// 	nHeight		Specifies the height, in logical units, of the font’s character cell or character.
		/// 			The character height value (also known as the em height) is the character cell height value minus the internal-leading value.
		/// 			The font mapper interprets the value specified in nHeight in the following manner:
		/// 			> 0 	The font mapper transforms this value into device units and matches it against the cell height of the available fonts.
		/// 			0 	The font mapper uses a default height value when it searches for a match.
		///  			< 0 	The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.
		/// 
		/// 			For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.
		/// 			This mapping occurs when the font is used for the first time.
		/// 			For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:
		///  			nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
		/// 	 nWidth 	Specifies the average width, in logical units, of characters in the requested font.
		/// 			If this value is zero, the font mapper chooses a “closest match” value. The “closest match” value is determined by comparing the absolute
		/// 			values of the difference between the current device’s aspect ratio and the digitized aspect ratio of available fonts.
		/// 	nEscapement 	Specifies the angle, in tenths of degrees, between the escapement vector and the x-axis of the device.
		/// 			The escapement vector is parallel to the base line of a row of text.
		/// 			Windows NT:
		/// 			When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string’s characters.
		/// 			When the graphics mode is set to GM_COMPATIBLE, nEscapement specifies both the escapement and orientation. You should set nEscapement and nOrientation to the same value.
		/// 			Windows 95:
		/// 			The nEscapement parameter specifies both the escapement and orientation. You should set nEscapement and nOrientation to the same value.
		/// 	nOrientation 	Specifies the angle, in tenths of degrees, between each character’s base line and the x-axis of the device.
		/// 	fnWeight 		Specifies the weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.
		/// 			The following values are defined for convenience:
		/// 			Value 			Weight
		///  			FW_DONTCARE 	0
		///  			FW_THIN 		100
		///  			FW_EXTRALIGHT 	200
		///  			FW_ULTRALIGHT 	200
		///  			FW_LIGHT 		300
		///  			FW_NORMAL 		400
		///  			FW_REGULAR 		400
		///  			FW_MEDIUM 		500
		///  			FW_SEMIBOLD 		600
		///  			FW_DEMIBOLD 		600
		///  			FW_BOLD 		700
		///  			FW_EXTRABOLD 	800
		///  			FW_ULTRABOLD 	800
		///  			FW_HEAVY 		900
		///  			FW_BLACK 		900
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <param name="param11"></param>
		/// <param name="param12"></param>
		/// <param name="param13"></param>
		/// <param name="param14"></param>
		/// <returns></returns>
		public static SalNumber CreateFontA(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalNumber param8, SalNumber param9, SalNumber param10, SalNumber param11, SalNumber param12, SalNumber param13, SalString param14)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			byte _param6 = (byte)param6;
			byte _param7 = (byte)param7;
			byte _param8 = (byte)param8;
			byte _param9 = (byte)param9;
			byte _param10 = (byte)param10;
			byte _param11 = (byte)param11;
			byte _param12 = (byte)param12;
			byte _param13 = (byte)param13;
			string _param14 = param14.Value;


			retVal = GDI32.CreateFontA(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8, _param9, _param10, _param11, _param12, _param13, _param14);

			return retVal;
		}
		
		/// <summary>
		/// The CreateHalftonePalette function creates a halftone palette for the specified device context.
		/// 
		/// Parameters:
		/// hdc 		Handle to the device context.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value identifies a logical halftone palette.
		/// If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// An application should create a halftone palette when the stretching mode of a device context is set to HALFTONE.
		/// The logical halftone palette returned by CreateHalftonePalette should then be selected and realized into the device
		/// context before the StretchBlt or StretchDIBits function is called.
		/// 
		/// When you no longer need the palette, call the DeleteObject function to delete it.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber CreateHalftonePalette(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = GDI32.CreateHalftonePalette(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The CreateHatchBrush function creates a logical brush that has the specified hatch pattern and color.
		/// 
		/// Parameters:
		/// fnStyle 		Specifies the hatch style of the brush. This parameter can be any one of the following values:
		/// 		Value 		Meaning
		/// 		HS_BDIAGONAL 	45-degree downward left-to-right hatch
		/// 		HS_CROSS 	Horizontal and vertical crosshatch
		/// 		HS_DIAGCROSS 	45-degree crosshatch
		/// 		HS_FDIAGONAL 	45-degree upward left-to-right hatch
		/// 		HS_HORIZONTAL 	Horizontal hatch
		/// 		HS_VERTICAL 	Vertical hatch
		/// clrref 		Specifies the foreground color of the brush that is used for the hatches.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value identifies a logical brush.
		/// If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// A brush is a bitmap that the system uses to paint the interiors of filled shapes.
		/// 
		/// After an application creates a brush by calling CreateHatchBrush, it can select that brush into any device context
		/// by calling the SelectObject function.
		/// 
		/// If an application uses a hatch brush to fill the backgrounds of both a parent and a child window with matching color,
		/// it may be necessary to set the brush origin before painting the background of the child window. You can do this by
		/// having your application call the SetBrushOrgEx function. Your application can retrieve the current brush origin by
		/// calling the GetBrushOrgEx function.
		/// 
		/// When you no longer need the brush, call the DeleteObject function to delete it.
		/// 
		/// ICM: No color is done at brush creation. However, color management will be performed when the brush is selected
		/// into an ICM-enabled device context.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CreateHatchBrush(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;


			retVal = GDI32.CreateHatchBrush(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The CreatePalette function creates a logical color palette.
		/// 
		/// Parameters:
		/// lplgpl 		Pointer to a LOGPALETTE structure that contains information about the colors in the logical palette.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is a handle that identifies a logical palette.
		/// If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// An application can determine whether a device supports palette operations by calling the GetDeviceCaps function
		/// and specifying the RASTERCAPS constant.
		/// 
		/// Once an application creates a logical palette, it can select that palette into a device context by calling the
		/// SelectPalette function. A palette selected into a device context can be realized by calling the RealizePalette function.
		/// 
		/// When you no longer need the palette, call the DeleteObject function to delete it.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber CreatePalette(SalNumber param1, SalNumber param2, SalString param3)
		{
			SalNumber retVal = 0;
			string _param3 = param3.Value;

			Structures.STRUCT_7 _struct1 = new Structures.STRUCT_7();
			_struct1.Member1 = (ushort)param1;
			_struct1.Member2 = (ushort)param2;

			retVal = GDI32.CreatePalette(ref _struct1, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The CreatePen function creates a logical pen that has the specified style, width, and color.
		/// The pen can subsequently be selected into a device context and used to draw lines and curves.
		/// 
		/// Parameters:
		/// 	fnPenStyle 	Specifies the pen style. It can be any one of the following values:
		/// 			PS_SOLID		Pen is solid.
		/// 			PS_DASH 		Pen is dashed. This style is valid only when the pen width is one or less in device units.
		/// 			PS_DOT 		Pen is dotted. This style is valid only when the pen width is one or less in device units.
		/// 			PS_DASHDOT 		Pen has alternating dashes and dots. This style is valid only when the pen width is one or less in device units.
		/// 			PS_DASHDOTDOT 	Pen has alternating dashes and double dots. This style is valid only when the pen width is one or less in device units.
		/// 			PS_NULL 		Pen is invisible.
		/// 			PS_INSIDEFRAME  	Pen is solid. When this pen is used in any graphics device interface (GDI) drawing function that takes a bounding rectangle, the dimensions of the figure are shrunk
		/// 						so that it fits entirely in the bounding rectangle, taking into account the width of the pen. This applies only to geometric pens.
		/// 	nWidth		Specifies the width of the pen, in logical units. If nWidth is zero, the pen is a single pixel wide, regardless of the current transformation.
		/// 	crColor		Specifies a color reference for the pen color.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is a handle that identifies a logical pen.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// After an application creates a logical pen, it can select that pen into a device context by calling the SelectObject function. After a pen is selected into a device context, it can be used to draw lines and curves.
		/// If the value specified by the nWidth parameter is zero, a line drawn with the created pen will always be a single pixel wide regardless of the current transformation.
		/// If the value specified by nWidth is greater than 1, the fnPenStyle parameter must be PS_NULL, PS_SOLID, or PS_INSIDEFRAME.
		/// If the value specified by nWidth is greater than 1 and fnPenStyle is PS_INSIDEFRAME, the line associated with the pen is drawn inside the frame of all primitives except polygons and polylines.
		/// If the value specified by nWidth is greater than 1, fnPenStyle is PS_INSIDEFRAME, and the color specified by the crColor parameter does not match one of the entries in the logical palette, Windows draws lines by using a dithered color.
		/// Dithered colors are not available with solid pens.
		/// When you no longer need the pen, call the DeleteObject function to delete it.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber CreatePen(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;


			retVal = GDI32.CreatePen(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The CreatePolygonRgn function creates a polygonal region.
		/// 
		/// Parameters:
		/// lppt 		Pointer to an array of POINT structures that define the vertices of the polygon.
		/// 		The polygon is presumed closed. Each vertex can be specified only once.
		/// cPoints 		Specifies the number of points in the array.
		/// fnPolyFillMode 	Specifies the fill mode used to determine which pixels are in the region.
		/// 		This parameter can be one of the following values:
		/// 		Value 		Meaning
		/// 		ALTERNATE 	Selects alternate mode (fills area between odd-numbered and even-numbered
		/// 				polygon sides on each scan line).
		/// 		WINDING 	Selects winding mode (fills any region with a nonzero winding value).
		/// 
		/// 		For more information about these modes, see the SetPolyFillMode function.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is the handle to the region.
		/// If the function fails, the return value is NULL.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalWindowHandle CreatePolygonRgn(SalString param1, SalNumber param2, SalNumber param3)
		{
			SalWindowHandle retVal = 0;
			string _param1 = param1.Value;
			int _param2 = (int)param2;
			int _param3 = (int)param3;


			retVal = GDI32.CreatePolygonRgn(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The CreateRectRgn function creates a rectangular region.
		/// 
		/// Parameters:
		/// nLeftRect 	Specifies the x-coordinate of the upper-left corner of the region.
		/// nTopRect 	Specifies the y-coordinate of the upper-left corner of the region.
		/// nRightRect 	Specifies the x-coordinate of the lower-right corner of the region.
		/// nBottomRect 	Specifies the y-coordinate of the lower-right corner of the region.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is the handle to the region.
		/// If the function fails, the return value is NULL.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalWindowHandle CreateRectRgn(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalWindowHandle retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;


			retVal = GDI32.CreateRectRgn(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The CreateRoundRectRgn function creates a rectangular region with rounded corners.
		/// 
		/// Parameters:
		/// nLeftRect 	Specifies the x-coordinate of the upper-left corner of the region.
		/// nTopRect 	Specifies the y-coordinate of the upper-left corner of the region.
		/// nRightRect 	Specifies the x-coordinate of the lower-right corner of the region.
		/// nBottomRect 	Specifies the y-coordinate of the lower-right corner of the region.
		/// nWidthEllipse 	Specifies the width of the ellipse used to create the rounded corners.
		/// nHeightEllipse 	Specifies the height of the ellipse used to create the rounded corners.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is the handle to the region.
		/// If the function fails, the return value is NULL.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalWindowHandle CreateRoundRectRgn(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6)
		{
			SalWindowHandle retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			int _param6 = (int)param6;


			retVal = GDI32.CreateRoundRectRgn(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// The CreateSolidBrush function creates a logical brush that has the specified solid color.
		/// 
		/// Parameters:
		/// crColor 		Specifies the color of the brush.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value identifies a logical brush.
		/// If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// A solid brush is a bitmap that the system uses to paint the interiors of filled shapes.
		/// 
		/// After an application creates a brush by calling CreateSolidBrush, it can select that brush into any device
		/// context by calling the SelectObject function.
		/// 
		/// ICM: No color is done at brush creation. However, color management will be performed when the brush
		/// is selected into an ICM-enabled device context.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber CreateSolidBrush(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = GDI32.CreateSolidBrush(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The DeleteDC function deletes the specified device context (DC).
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// An application must not delete a device context whose handle was obtained by calling the GetDC function. Instead, it must call the
		/// ReleaseDC function to free the device context.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DeleteDC(SalNumber param1)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;


			retVal = GDI32.DeleteDC(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object.
		/// After the object is deleted, the specified handle is no longer valid.
		/// 
		/// Parameters:
		/// 	hObject		Identifies a logical pen, brush, font, bitmap, region, or palette.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the specified handle is not valid or is currently selected into a device context, the return value is zero.
		/// 
		/// Remarks:
		/// Do not delete a drawing object (pen or brush) while it is still selected into a device context.
		/// When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DeleteObject(SalNumber param1)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;


			retVal = GDI32.DeleteObject(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The DPtoLP function converts device coordinates into logical coordinates. The conversion depends on
		/// the mapping mode of the device context, the settings of the origins and extents for the window and viewport,
		/// and the world transformation.
		/// 
		/// Parameters:
		/// hdc 		Handle to the device context.
		/// lpPoints 		Pointer to an array of POINT structures. The x- and y-coordinates contained in each POINT
		/// 		structure will be transformed.
		/// nCount 		Specifies the number of points in the array.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is nonzero.
		/// If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The DPtoLP function fails if the device coordinates exceed 27 bits, or if the converted logical coordinates exceed 32 bits.
		/// In the case of such an overflow, the results for all the points are undefined.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean DPtoLP(SalNumber param1, ref SalNumber param2, ref SalNumber param3, SalNumber param4)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param4 = (int)param4;

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;

			retVal = GDI32.DPtoLP(_param1, ref _struct1, _param4);

			param2 = (SalNumber)_struct1.Member1;
			param3 = (SalNumber)_struct1.Member2;
			return retVal;
		}
		
		/// <summary>
		/// The Ellipse function draws an ellipse. The center of the ellipse is the center of the specified bounding rectangle.
		/// The ellipse is outlined by using the current pen and is filled by using the current brush.
		/// 
		/// Parameters:
		/// hdc 		Handle to the device context.
		/// nLeftRect 	Specifies the x-coordinate of the upper-left corner of the bounding rectangle.
		/// nTopRect 	Specifies the y-coordinate of the upper-left corner of the bounding rectangle.
		/// nRightRect 	Specifies the x-coordinate of the lower-right corner of the bounding rectangle.
		/// nBottomRect 	Specifies the y-coordinate of the lower-right corner of the bounding rectangle.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is nonzero.
		/// If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The current position is neither used nor updated by Ellipse.
		/// 
		/// Windows 95 and Windows 98: The sum of the coordinates of the bounding rectangle cannot exceed 32,767.
		/// The sum of nLeftRect and nRightRect or nTopRect and nBottomRect parameters cannot exceed 32,767.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean Ellipse(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;


			retVal = GDI32.Ellipse(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// The ExcludeClipRect function creates a new clipping region that consists of the existing clipping region
		/// minus the specified rectangle.
		/// 
		/// Parameters:
		/// hdc 		Handle to the device context.
		/// nLeftRect 	Specifies the logical x-coordinate of the upper-left corner of the rectangle.
		/// nTopRect 	Specifies the logical y-coordinate of the upper-left corner of the rectangle.
		/// nRightRect 	Specifies the logical x-coordinate of the lower-right corner of the rectangle.
		/// nBottomRect 	Specifies the logical y-coordinate of the lower-right corner of the rectangle.
		/// 
		/// Return Values:
		/// The return value specifies the new clipping region's complexity; it can be any one of the following values:
		/// Value 			Meaning
		/// NULLREGION 		Region is empty.
		/// SIMPLEREGION 		Region is a single rectangle.
		/// COMPLEXREGION 	Region is more than one rectangle.
		/// ERROR 			No region was created.
		/// 
		/// Remarks:
		/// The lower and right edges of the specified rectangle are not excluded from the clipping region.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber ExcludeClipRect(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;


			retVal = GDI32.ExcludeClipRect(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// The ExtTextOut function draws a character string by using the currently selected font. An optional rectangle may be provided, to be used for clipping, opaquing, or both.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	X 		Specifies the logical x-coordinate of the reference point used to position the string.
		/// 	Y 		Specifies the logical y-coordinate of the reference point used to position the string.
		/// 	fuOptions 	Specifies how to use the application-defined rectangle. This parameter can be a combination of the following values:
		/// 			Value 			Meaning
		/// 			ETO_CLIPPED 		The text will be clipped to the rectangle.
		///  			ETO_GLYPH_INDEX 	Windows 95 only: The lpString array refers to an array returned from GetCharacterPlacement and should be parsed directly by GDI as no further language-specific processing is required.
		/// 						Glyph indexing only applies to TrueType fonts, but the flag can be used for Windows bitmap and vector fonts to indicate no further language processing is necessary and GDI should
		/// 						process the string directly. Note that all glyph indices are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.
		/// 			ETO_OPAQUE 		The current background color should be used to fill the rectangle.
		///  			ETO_RTLREADING 	Windows 95 only: If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order.
		/// 						If this value is not specified, the string is output in left- to-right order. The same effect can be achieved by setting the TA_RTLREADING value in SetTextAlign.
		/// 						This value is preserved for backward compatability.
		///  			The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed,
		/// 			the function ignores the ETO_RTLREADING flag if also specified.
		/// 	lprc 		Points to an optional RECT structure that specifies the dimensions of a rectangle that is used for clipping, opaquing, or both.
		/// 	lpString 		Points to the character string to be drawn. The string does not need to be zero-terminated, since cbCount specifies the length of the string.
		/// 	cbCount 		Specifies the number of characters in the string.
		/// 	lpDx 		Points to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[i] logical units separate the origins of character cell i and character cell i + 1.
		/// 
		/// Return Values:
		/// 	If the string is drawn, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the GetTextAlign function.
		/// The text-alignment settings are altered by calling the SetTextAlign function.
		/// 
		/// If the lpDx parameter is NULL, the ExtTextOut function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the lpDx parameter are given in logical units.
		/// A character-cell origin is defined as the upper-left corner of the character cell.
		/// 
		/// By default, the current position is not used or updated by this function. However, an application can call the SetTextAlign function with the fMode parameter set to TA_UPDATECP to permit Windows to use and update
		/// the current position each time the application calls ExtTextOut for a specified device context. When this flag is set, Windows ignores the X and Y parameters on subsequent ExtTextOut calls.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <returns></returns>
		public static SalBoolean ExtTextOutA(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalString param5, SalString param6, SalNumber param7, SalNumber param8)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			uint _param4 = (uint)param4;
			string _param5 = param5.Value;
			string _param6 = param6.Value;
			ushort _param7 = (ushort)param7;
			uint _param8 = (uint)param8;


			retVal = GDI32.ExtTextOutA(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8);

			return retVal;
		}
		
		/// <summary>
		/// The FrameRgn function draws a border around the specified region by using the specified brush.
		/// 
		/// Parameters:
		/// hdc 		Handle to the device context.
		/// hrgn 		Handle to the region to be enclosed in a border. The region's coordinates are presumed to be in logical units.
		/// hbr 		Handle to the brush to be used to draw the border.
		/// nWidth 		Specifies the width, in logical units, of vertical brush strokes.
		/// nHeight 		Specifies the height, in logical units, of horizontal brush strokes.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is nonzero.
		/// If the function fails, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber FrameRgn(SalNumber param1, SalWindowHandle param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			uint _param1 = (uint)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;


			GDI32.FrameRgn(_param1, _param2, _param3, _param4, _param5);

			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetBitmapDimensionEx(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;

			retVal = GDI32.GetBitmapDimensionEx(_param1, ref _struct1);

			param2 = (SalNumber)_struct1.Member1;
			param3 = (SalNumber)_struct1.Member2;
			return retVal;
		}
		
		/// <summary>
		/// The GetDeviceCaps function retrieves device-specific information about a specified device.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetDeviceCaps(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = GDI32.GetDeviceCaps(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The GetPixel function retrieves the red, green, blue (RGB) color value of the pixel at the specified coordinates.
		/// 
		/// COLORREF GetPixel(
		///   HDC hdc,   // handle to device context
		///   int XPos,  // x-coordinate of pixel
		///   int nYPos  // y-coordinate of pixel
		/// );
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetPixel(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;


			retVal = GDI32.GetPixel(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The GetObject function obtains information about a specified graphics object.
		/// Depending on the graphics object, the function places a filled-in BITMAP, DIBSECTION, EXTLOGPEN, LOGBRUSH, LOGFONT,
		/// or LOGPEN structure, or a count of table entries (for a logical palette), into a specified buffer.
		/// 
		/// int GetObject(
		///   HGDIOBJ hgdiobj,  // handle to graphics object of interest
		///   int cbBuffer,     // size of buffer for object information
		///   LPVOID lpvObject  // pointer to buffer for object information
		/// );
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetObjectA(SalNumber param1, SalNumber param2, ref SalString param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			System.Text.StringBuilder _param3 = new System.Text.StringBuilder(param3.Value);


			retVal = GDI32.GetObjectA(_param1, _param2, _param3);

			param3 = _param3.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The GetStockObject function retrieves a handle to one of the predefined stock pens, brushes, fonts, or palettes.
		/// 
		/// Parameters:
		/// fnObject 		Specifies the type of stock object. This parameter can be any one of the following values:
		/// 		Value 			Meaning
		/// 		BLACK_BRUSH 		Black brush.
		/// 		DKGRAY_BRUSH 		Dark gray brush.
		/// 		DC_BRUSH 		Windows 98, Windows NT 5.0 and later: Solid color brush. The default color is white.
		/// 					The color can be changed by using the SetDCBrushColor function.
		/// 					For more information, see the following Remarks section.
		/// 		GRAY_BRUSH 		Gray brush.
		/// 		HOLLOW_BRUSH 		Hollow brush (equivalent to NULL_BRUSH).
		/// 		LTGRAY_BRUSH 		Light gray brush.
		/// 		NULL_BRUSH 		Null brush (equivalent to HOLLOW_BRUSH).
		/// 		WHITE_BRUSH 		White brush.
		/// 		BLACK_PEN 		Black pen.
		/// 		DC_PEN 			Windows 98, Windows NT 5.0 and later: Solid pen color.
		/// 					The default color is white. The color can be changed by using the
		/// 					SetDCPenColor function. For more information, see the following Remarks section.
		/// 		WHITE_PEN 		White pen.
		/// 		ANSI_FIXED_FONT 	Windows fixed-pitch (monospace) system font.
		/// 		ANSI_VAR_FONT 		Windows variable-pitch (proportional space) system font.
		/// 		DEVICE_DEFAULT_FONT 	Windows NT: Device-dependent font.
		/// 		DEFAULT_GUI_FONT 	Default font for user interface objects such as menus and dialog boxes.
		/// 		OEM_FIXED_FONT 	Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font.
		/// 		SYSTEM_FONT 		System font. By default, the system uses the system font to draw menus, dialog box controls, and text.
		/// 		SYSTEM_FIXED_FONT 	Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0.
		/// 		DEFAULT_PALETTE 	Default palette. This palette consists of the static colors in the system palette.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value identifies the logical object requested.
		/// If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// Use the DKGRAY_BRUSH, GRAY_BRUSH, and LTGRAY_BRUSH stock objects only in windows with the CS_HREDRAW
		/// and CS_VREDRAW styles. Using a gray stock brush in any other style of window can lead to misalignment of brush
		/// patterns after a window is moved or sized. The origins of stock brushes cannot be adjusted.
		/// 
		/// The HOLLOW_BRUSH and NULL_BRUSH stock objects are equivalent.
		/// 
		/// The font used by the DEFAULT_GUI_FONT stock object could change. Use this stock object when you want to use the
		/// font that menus, dialog boxes, and other user interface objects use.
		/// 
		/// It is not necessary (but it is not harmful) to delete stock objects by calling DeleteObject.
		/// 
		/// Windows 98, Windows NT 5.0 and later: Both DC_BRUSH and DC_PEN can be used interchangeably with other stock objects
		/// like BLACK_BRUSH and BLACK_PEN. For information on retrieving the current pen or brush color, see GetDCBrushColor and
		/// GetDCPenColor. See Setting the Pen or Brush Color for an example of setting colors. The GetStockObject function with an
		/// argument of DC_BRUSH OR DC_PEN can be used interchangeably with the SetDCPenColor and SetDCBrushColor functions.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetStockObject(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = GDI32.GetStockObject(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetTextExtentPoint32 function computes the width and height of the specified string of text.
		/// This function supersedes the GetTextExtentPoint function.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	lpString 		Points to the string of text. The string does not need to be zero-terminated, since cbString specifies the length of the string.
		/// 	cbString 		Specifies the number of characters in the string.
		/// 	lpSize 		Points to a SIZE structure in which the dimensions of the string are to be returned.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The GetTextExtentPoint32 function uses the currently selected font to compute the dimensions of the string.
		/// The width and height, in logical units, are computed without considering any clipping.
		/// Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.
		/// The calculated string width takes into account the intercharacter spacing set by the SetTextCharacterExtra function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber GetTextExtentPoint32A(SalNumber param1, SalString param2, SalNumber param3, ref SalNumber param4, ref SalNumber param5)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			string _param2 = param2.Value;
			int _param3 = (int)param3;

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param4;
			_struct1.Member2 = (int)param5;

			retVal = GDI32.GetTextExtentPoint32A(_param1, _param2, _param3, ref _struct1);

			param4 = (SalNumber)_struct1.Member1;
			param5 = (SalNumber)_struct1.Member2;
			return retVal;
		}
		
		/// <summary>
		/// The GetTextFace function retrieves the typeface name of the font that is selected into the specified device context.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	nCount 		Specifies the size, in characters, of the buffer.
		/// 	lpFaceName 	Points to the buffer that is to receive the typeface name. If this parameter is NULL, the function returns the number of characters in the name, including the terminating null character.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the number of characters copied to the buffer.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The typeface name is copied as a null-terminated character string.
		/// If the name is longer than the number of characters specified by the nCount parameter, the name is truncated.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetTextFaceA(SalNumber param1, SalNumber param2, SalString param3)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;
			ushort _param2 = (ushort)param2;
			string _param3 = param3.Value;


			retVal = GDI32.GetTextFaceA(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The GetTextMetrics function fills the specified buffer with the metrics for the currently selected font.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	lptm 		Points to the TEXTMETRIC structure that is to receive the metrics.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetTextMetricsA(SalNumber param1, SalString param2)
		{
			SalBoolean retVal = false;
			ushort _param1 = (ushort)param1;
			string _param2 = param2.Value;


			retVal = GDI32.GetTextMetricsA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The LineTo function draws a line from the current position up to, but not including, the specified point.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies a device context.
		/// 	nXEnd 		Specifies the x-coordinate of the line’s ending point.
		/// 	nYEnd 		Specifies the y-coordinate of the line’s ending point.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The coordinates of the line’s ending point are specified in logical units.
		/// The line is drawn by using the current pen and, if the pen is a geometric pen, the current brush.
		/// If LineTo succeeds, the current position is set to the specified ending point.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean LineTo(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;


			retVal = GDI32.LineTo(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The MoveToEx function updates the current position to the specified point and optionally returns the previous position.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies a device context.
		/// 	X 		Specifies the x-coordinate of the new position, in logical units.
		/// 	Y 		Specifies the y-coordinate of the new position, in logical units.
		/// 	lpPoint 		Points to a POINT structure in which the previous current position is stored. If this parameter is a NULL pointer, the previous position is not returned.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The MoveToEx function affects all drawing functions.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber MoveToEx(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;


			retVal = GDI32.MoveToEx(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The PatBlt function paints the given rectangle using the brush that is currently selected into the specified device context.
		/// The brush color and the surface color(s) are combined by using the given raster operation.
		/// 
		/// Parameters
		/// hdc 		Handle to the device context.
		/// nXLeft 		Specifies the x-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.
		/// nYLeft 		Specifies the y-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.
		/// nWidth 		Specifies the width, in logical units, of the rectangle.
		/// nHeight 		Specifies the height, in logical units, of the rectangle.
		/// dwRop 		Specifies the raster operation code. This code may be one of the following values:
		/// 		Value 		Meaning
		/// 		PATCOPY 	Copies the specified pattern into the destination bitmap.
		/// 		PATINVERT 	Combines the colors of the specified pattern with the colors of the destination
		/// 				rectangle by using the Boolean OR operator.
		/// 		DSTINVERT 	Inverts the destination rectangle.
		/// 		BLACKNESS 	Fills the destination rectangle using the color associated with index 0 in the physical
		/// 				palette. (This color is black for the default physical palette.)
		/// 		WHITENESS 	Fills the destination rectangle using the color associated with index 1 in the physical
		/// 				palette. (This color is white for the default physical palette.)
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is nonzero.
		/// If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The values of the dwRop parameter for this function are a limited subset of the full 256 ternary raster-operation codes;
		/// in particular, an operation code that refers to a source rectangle cannot be used.
		/// 
		/// Not all devices support the PatBlt function. For more information, see the description of the RC_BITBLT capability in the
		/// GetDeviceCaps function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalBoolean PatBlt(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			uint _param6 = (uint)param6;


			retVal = GDI32.PatBlt(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean Rectangle(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;


			retVal = GDI32.Rectangle(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean RectInRegion(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = GDI32.RectInRegion(_param1, ref _struct1);

			return retVal;
		}
		
		/// <summary>
		/// Selects an object into the given device context.  The new object replaces
		/// the previous object of the same type.
		/// 
		/// Parameters:
		/// 	hDC		Identifies the device context
		/// 	hGDIObj		Identifies the object to be selected.
		/// 
		/// Return Value:
		/// 	The return value is the handle of the object being replaced.
		/// 
		/// Remarks:
		/// This function returns the previously selected object of the specified type.
		/// An application should always replace a new object with the original, default object after it has finished drawing with the new object.
		/// An application cannot select a bitmap into more than one device context at a time.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SelectObject(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = GDI32.SelectObject(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetBkColor function sets the current background color to the specified color value, or to the nearest physical color if the device cannot represent the specified color value.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	crColor 		Specifies the new background color.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value specifies the previous background color as a COLORREF value.
		/// 	If the function fails, the return value is CLR_INVALID.
		/// 
		/// Remarks
		/// This function fills the gaps between styled lines drawn using a pen created by the CreatePen function; it does not fill the gaps between styled lines drawn using a pen created by the ExtCreatePen function.
		/// 
		/// If the background mode is OPAQUE, the background color is used to fill gaps between styled lines, gaps between hatched lines in brushes, and character cells.
		/// The background color is also used when converting bitmaps from color to monochrome and vice versa.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SetBkColor(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;
			int _param2 = (int)param2;


			retVal = GDI32.SetBkColor(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetBkMode function sets the background mix mode of the specified device context.
		/// The background mix mode is used with text, hatched brushes, and pen styles that are not solid lines.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	iBkMode 		Specifies the background mode. This parameter can be either of the following values:
		/// 			Value 		Description
		///  			OPAQUE 	Background is filled with the current background color before the text, hatched brush, or pen is drawn.
		///  			TRANSPARENT 	Background remains untouched.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value specifies the previous background mode.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The SetBkMode function affects the line styles for lines drawn using a pen created by the CreatePen function.
		/// SetBkMode does not affect lines drawn using a pen created by the ExtCreatePen function.
		/// 
		/// The iBkMode parameter can also be set to driver-specific values. GDI passes such values to the device driver and otherwise ignores them.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SetBkMode(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = GDI32.SetBkMode(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetTextAlign function sets the text-alignment flags for the specified device context.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	fMode 		Specifies the text alignment by using a mask of the values in the following list. Only one flag can be chosen from those that affect horizontal and vertical alignment.
		/// 			In addition, only one of the two flags that alter the current position can be chosen.
		/// 			Value  			Meaning
		///  			TA_BASELINE 		The reference point will be on the base line of the text.
		///  			TA_BOTTOM 		The reference point will be on the bottom edge of the bounding rectangle.
		///  			TA_TOP 			The reference point will be on the top edge of the bounding rectangle.
		///  			TA_CENTER 		The reference point will be aligned horizontally with the center of the bounding rectangle.
		///  			TA_LEFT 		The reference point will be on the left edge of the bounding rectangle.
		///  			TA_RIGHT 		The reference point will be on the right edge of the bounding rectangle.
		///  			TA_NOUPDATECP 	The current position is not updated after each text output call. The reference point is passed to the text output function.
		///  			TA_RTLREADING 		Windows 95 only: The text is laid out in right to left reading order, as opposed to the default left to right order.
		/// 						This applies only when the font selected into the device context is either Hebrew or Arabic.
		///  			TA_UPDATECP 		The current position is updated after each text output call. The current position is used as the reference point.
		/// 
		/// 			When the current font has a vertical default base line, as with Kanji, the following values must be used instead of TA_BASELINE and TA_CENTER:
		/// 			Value  			Meaning
		/// 			VTA_BASELINE 		The reference point will be on the base line of the text.
		///  			VTA_CENTER 		The reference point will be aligned vertically with the center of the bounding rectangle.
		/// 
		/// 			The default values are TA_LEFT, TA_TOP, and TA_NOUPDATECP.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the previous text-alignment setting.
		/// 	If the function fails, the return value is GDI_ERROR. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The TextOut and ExtTextOut functions use the text-alignment flags to position a string of text on a display or other device.
		/// The flags specify the relationship between a reference point and a rectangle that bounds the text.
		/// The reference point is either the current position or a point passed to a text output function.
		/// 
		/// The rectangle that bounds the text is formed by the character cells in the text string.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SetTextAlign(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;
			ushort _param2 = (ushort)param2;


			retVal = GDI32.SetTextAlign(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetTextColor function sets the text color for the specified device context to the specified color.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	crColor 		Specifies the color of the text.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is a color reference for the previous text color.
		/// 	If the function fails, the return value is CLR_INVALID. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The text color is used to draw the face of each character written by the TextOut and ExtTextOut functions.
		/// The text color is also used in converting bitmaps from color to monochrome and vice versa.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SetTextColor(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = GDI32.SetTextColor(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetStretchBltMode function sets the bitmap stretching mode in the specified device context.
		/// 
		/// Parameters:
		/// hdc 		Handle to the device context.
		/// iStretchMode 	Specifies the stretching mode. It can be one of the following values:
		/// 		Value 			Description
		/// 		BLACKONWHITE 		Performs a Boolean AND operation using the color values for the
		/// 					eliminated and existing pixels. If the bitmap is a monochrome bitmap,
		/// 					this mode preserves black pixels at the expense of white pixels.
		/// 		COLORONCOLOR 		Deletes the pixels. This mode deletes all eliminated lines of pixels without
		/// 					trying to preserve their information.
		/// 		HALFTONE 		Maps pixels from the source rectangle into blocks of pixels in the destination
		/// 					rectangle. The average color over the destination block of pixels approximates
		/// 					the color of the source pixels. After setting the HALFTONE stretching mode,
		/// 					an application must call the SetBrushOrgEx function to set the brush origin.
		/// 					If it fails to do so, brush misalignment occurs.
		/// 		STRETCH_ANDSCANS 	Same as BLACKONWHITE.
		/// 		STRETCH_DELETESCANS 	Same as COLORONCOLOR.
		/// 		STRETCH_HALFTONE 	Same as HALFTONE.
		/// 		STRETCH_ORSCANS 	Same as WHITEONBLACK.
		/// 		WHITEONBLACK 		Performs a Boolean OR operation using the color values for the eliminated and
		/// 					existing pixels. If the bitmap is a monochrome bitmap, this mode preserves
		/// 					white pixels at the expense of black pixels.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is the previous stretching mode.
		/// If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The stretching mode defines how the system combines rows or columns of a bitmap with existing pixels on a display device when
		/// an application calls the StretchBlt function.
		/// 
		/// The BLACKONWHITE (STRETCH_ANDSCANS) and WHITEONBLACK (STRETCH_ORSCANS) modes are typically used
		/// to preserve foreground pixels in monochrome bitmaps. The COLORONCOLOR (STRETCH_DELETESCANS) mode is typically
		/// used to preserve color in color bitmaps.
		/// 
		/// The HALFTONE mode requires more processing of the source image than the other three modes; it is slower than the others
		/// but produces higher quality images. Also note that SetBrushOrgEx must be called after setting the HALFTONE mode to avoid
		/// brush misalignment.
		/// 
		/// Additional stretching modes might also be available depending on the capabilities of the device driver.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SetStretchBltMode(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = GDI32.SetStretchBltMode(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The TextOut function writes a character string at the specified location, using the currently selected font.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	nXStart 		Specifies the logical x-coordinate of the reference point that Windows uses to align the string.
		/// 	nYStart 		Specifies the logical y-coordinate of the reference point that Windows uses to align the string.
		/// 	lpString 		Points to the string to be drawn. The string does not need to be zero-terminated, since cbString specifies the length of the string.
		/// 	cbString 		Specifies the number of characters in the string.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the GetTextAlign function;
		/// an application can alter this mode by calling the SetTextAlign function.
		/// 
		/// By default, the current position is not used or updated by this function. However, an application can call the SetTextAlign function with the fMode parameter set to
		/// TA_UPDATECP to permit Windows to use and update the current position each time the application calls TextOut for a specified device context. When this flag is set,
		/// Windows ignores the nXStart and nYStart parameters on subsequent TextOut calls.
		/// 
		/// When the TextOut function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box.
		/// The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting
		/// the background mode to transparent before placing the TextOut function in the path bracket. Following is sample code that demonstrates this procedure.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean TextOutA(SalNumber param1, SalNumber param2, SalNumber param3, SalString param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			ushort _param1 = (ushort)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			string _param4 = param4.Value;
			ushort _param5 = (ushort)param5;


			retVal = GDI32.TextOutA(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// 27.07.09
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns>Number: DWORD</returns>
		public static SalNumber CreateDCA(SalString param1, SalString param2, SalString param3, SalNumber param4)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			string _param2 = param2.Value;
			string _param3 = param3.Value;
			int _param4 = (int)param4;


			retVal = GDI32.CreateDCA(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber AddAtomA(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = KERNEL32.AddAtomA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CopyFileA(SalString param1, SalString param2, SalBoolean param3)
		{
			SalBoolean retVal = false;
			string _param1 = param1.Value;
			string _param2 = param2.Value;
			bool _param3 = (bool)param3;


			retVal = KERNEL32.CopyFileA(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalFileHandle CreateFileA(SalString param1, SalNumber param2, SalNumber param3, SalWindowHandle param4, SalNumber param5, SalNumber param6, SalWindowHandle param7)
		{
			SalFileHandle retVal = new SalFileHandle();
            //FC:FINAL: not needed anymore
            //string _param1 = param1.Value;
            //uint _param2 = (uint)param2;
            //uint _param3 = (uint)param3;
            //System.IntPtr _param4 = (System.IntPtr)param4;
            //uint _param5 = (uint)param5;
            //uint _param6 = (uint)param6;
            //System.IntPtr _param7 = (System.IntPtr)param7;


            //retVal = KERNEL32.CreateFileA(_param1, _param2, _param3, _param4, _param5, _param6, _param7);

            return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber DeleteAtom(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = KERNEL32.DeleteAtom(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DeleteFileA(SalString param1)
		{
			SalBoolean retVal = false;
			string _param1 = param1.Value;


			retVal = KERNEL32.DeleteFileA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber ExitProcess(SalNumber param1)
		{
			uint _param1 = (uint)param1;


			KERNEL32.ExitProcess(_param1);

			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean FindClose(SalNumber param1)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;


			retVal = KERNEL32.FindClose(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber FindFirstFileA(SalString param1, ref SalString param2)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);


			retVal = KERNEL32.FindFirstFileA(_param1, _param2);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The FreeLibrary function decrements the reference count of the loaded dynamic-link library (DLL) module.
		/// When the reference count reaches zero, the module is unmapped from the address space of the calling process and the handle is no longer valid.
		/// 
		/// Parameters:
		/// 	hLibModule 		Identifies the loaded library module. The LoadLibrary or GetModuleHandle function returns this handle.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// Each process maintains a reference count for each loaded library module. This reference count is incremented each time LoadLibrary is called and is decremented each time FreeLibrary is called.
		/// A DLL module loaded at process initialization due to load-time dynamic linking has a reference count of one. This count is incremented if the same module is loaded by a call to LoadLibrary.
		/// 
		/// Before unmapping a library module, the system enables the DLL to detach from the process by calling the DLL’s DllEntryPoint function, if it has one, with the DLL_PROCESS_DETACH value.
		/// Doing so gives the DLL an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process.
		/// 
		/// Calling FreeLibrary does not affect other processes using the same library module.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber FreeLibrary(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = KERNEL32.FreeLibrary(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetCurrentDirectoryA(SalNumber param1, ref SalString param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);


			retVal = KERNEL32.GetCurrentDirectoryA(_param1, _param2);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// Function: GetComputerNameA
		/// Description:
		/// Export Ordinal: 0
		/// Returns
		/// Boolean: BOOL
		/// Parameters
		/// Receive String: LPSTR
		/// Receive Number: LPWORD
		/// </summary>
		/// <returns></returns>
		public static SalNumber GetCurrentProcess()
		{
			SalNumber retVal = 0;


			retVal = KERNEL32.GetCurrentProcess();

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public static SalNumber GetCurrentThreadId()
		{
			SalNumber retVal = 0;


			retVal = KERNEL32.GetCurrentThreadId();

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean GetDiskFreeSpaceA(SalString param1, ref SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5)
		{
			SalBoolean retVal = false;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			uint _param5 = (uint)param5;


			retVal = KERNEL32.GetDiskFreeSpaceA(_param1, ref _param2, ref _param3, ref _param4, ref _param5);

			param2 = _param2;
			param3 = _param3;
			param4 = _param4;
			param5 = _param5;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetDriveTypeA(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = KERNEL32.GetDriveTypeA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetEnvironmentVariableA(SalString param1, ref SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);
			uint _param3 = (uint)param3;


			retVal = KERNEL32.GetEnvironmentVariableA(_param1, _param2, _param3);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean GetExitCodeProcess(SalNumber param1, ref SalNumber param2)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = KERNEL32.GetExitCodeProcess(_param1, ref _param2);

			param2 = _param2;
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetFileAttributesA(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = KERNEL32.GetFileAttributesA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber GetFullPathNameA(SalString param1, SalNumber param2, ref SalString param3, ref SalString param4)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;
			System.Text.StringBuilder _param3 = new System.Text.StringBuilder(param3.Value);
			System.Text.StringBuilder _param4 = new System.Text.StringBuilder(param4.Value);


			retVal = KERNEL32.GetFullPathNameA(_param1, _param2, _param3, _param4);

			param3 = _param3.ToString();
			param4 = _param4.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public static SalNumber GetLastError()
		{
			SalNumber retVal = 0;


			retVal = KERNEL32.GetLastError();

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetModuleFileNameA(SalNumber param1, ref SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);
			ushort _param3 = (ushort)param3;


			retVal = KERNEL32.GetModuleFileNameA(_param1, _param2, _param3);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetModuleHandleA(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = KERNEL32.GetModuleHandleA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetProcAddress(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			string _param2 = param2.Value;


			retVal = KERNEL32.GetProcAddress(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public static SalNumber GetProcessHeap()
		{
			SalNumber retVal = 0;


			retVal = KERNEL32.GetProcessHeap();

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetShortPathNameA(SalString param1, ref SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);
			uint _param3 = (uint)param3;


			retVal = KERNEL32.GetShortPathNameA(_param1, _param2, _param3);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetSystemDirectoryA(ref SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);
			uint _param2 = (uint)param2;


			retVal = KERNEL32.GetSystemDirectoryA(_param1, _param2);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber GetTempFileNameA(SalString param1, SalString param2, SalNumber param3, ref SalString param4)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			System.Text.StringBuilder _param4 = new System.Text.StringBuilder(param4.Value);


			retVal = KERNEL32.GetTempFileNameA(_param1, _param2, _param3, _param4);

			param4 = _param4.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetTempPathA(SalNumber param1, ref SalString param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);


			retVal = KERNEL32.GetTempPathA(_param1, _param2);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The GetTickCount function retrieves the number of milliseconds that have elapsed since Windows was started.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the number of milliseconds that have elapsed since Windows was started.
		/// 
		/// Remarks:
		/// The elapsed time is stored as a DWORD value. Therefore, the time will wrap around to zero if Windows is run continuously for 49.7 days.
		/// 
		/// Windows NT: To obtain the time elapsed since the computer was started, look up the System Up Time counter in the performance data in the registry key HKEY_PERFORMANCE_DATA. The value returned is an 8 byte value.
		/// </summary>
		/// <returns></returns>
		public static SalNumber GetTickCount()
		{
			SalNumber retVal = 0;


			retVal = KERNEL32.GetTickCount();

			return retVal;
		}
		
		/// <summary>
		/// Struct: OSVERSIONINFO
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean GetVersionExA(SalNumber param1, ref SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5, ref SalString param6)
		{
			SalBoolean retVal = false;

			Structures.STRUCT_9 _struct1 = new Structures.STRUCT_9();
			_struct1.Member1 = (uint)param1;
			_struct1.Member2 = (uint)param2;
			_struct1.Member3 = (uint)param3;
			_struct1.Member4 = (uint)param4;
			_struct1.Member5 = (uint)param5;
			_struct1.Member6 = new System.Text.StringBuilder(param6.Value);

			retVal = KERNEL32.GetVersionExA(ref _struct1);

			param2 = (SalNumber)_struct1.Member2;
			param3 = (SalNumber)_struct1.Member3;
			param4 = (SalNumber)_struct1.Member4;
			param5 = (SalNumber)_struct1.Member5;
			param6 = _struct1.Member6.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetWindowsDirectoryA(ref SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);
			uint _param2 = (uint)param2;


			retVal = KERNEL32.GetWindowsDirectoryA(_param1, _param2);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalAddAtomA(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = KERNEL32.GlobalAddAtomA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GlobalAlloc function allocates the specified number of bytes from the heap. In the linear Win32 API environment,
		/// there is no difference between the local heap and the global heap.
		/// 
		/// Parameters:
		/// 	uFlags 		Specifies how to allocate memory. If zero is specified, the default is GMEM_FIXED. Except for the incompatible combinations that are specifically noted, any combination of the following flags can be used.
		/// 			To indicate whether the function allocates fixed or movable memory, specify one of the first four flags:
		/// 			Flag  Meaning
		///  			GMEM_FIXED 		Allocates fixed memory. This flag cannot be combined with the GMEM_MOVEABLE or GMEM_DISCARDABLE flag.
		/// 						The return value is a pointer to the memory block. To access the memory, the calling process simply casts the return value to a pointer.
		/// 			GMEM_MOVEABLE 	Allocates movable memory. This flag cannot be combined with the GMEM_FIXED flag. The return value is the handle of the memory object.
		/// 						The handle is a 32-bit quantity that is private to the calling process. To translate the handle into a pointer, use the GlobalLock function.
		/// 			GPTR 			Combines the GMEM_FIXED and GMEM_ZEROINIT flags.
		///  			GHND 			Combines the GMEM_MOVEABLE and GMEM_ZEROINIT flags.
		///  			GMEM_DDESHARE 	Allocates memory to be used by the dynamic data exchange (DDE) functions for a DDE conversation. Unlike Windows version 3. x, this memory is not shared globally.
		/// 						However, this flag is available for compatibility purposes. It may be used by some applications to enhance the performance of DDE operations and should, therefore,
		/// 						be specified if the memory is to be used for DDE. Only processes that use DDE or the clipboard for interprocess communications should specify this flag.
		/// 			GMEM_DISCARDABLE 	Allocates discardable memory. This flag cannot be combined with the GMEM_FIXED flag. Some Win32-based applications may ignore this flag.
		/// 			GMEM_LOWER 		Ignored. This flag is provided only for compatibility with Windows version 3. x.
		/// 			GMEM_NOCOMPACT 	Does not compact or discard memory to satisfy the allocation request.
		/// 			GMEM_NODISCARD 	Does not discard memory to satisfy the allocation request.
		/// 			GMEM_NOT_BANKED 	Ignored. This flag is provided only for compatibility with Windows version 3. x.
		/// 			GMEM_NOTIFY 		Ignored. This flag is provided only for compatibility with Windows version 3. x.
		/// 			GMEM_SHARE 		Same as the GMEM_DDESHARE flag.
		/// 			GMEM_ZEROINIT 		Initializes memory contents to zero.
		/// 	dwBytes 		Specifies the number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies the GMEM_MOVEABLE flag, the function returns a handle to a memory object that is marked as discarded.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the newly allocated memory object.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// If the heap does not contain sufficient free space to satisfy the request, GlobalAlloc returns NULL.
		/// 
		/// Because NULL is used to indicate an error, virtual address zero is never allocated. It is, therefore, easy to detect the use of a NULL pointer.
		/// 
		/// All memory is created with execute access; no special function is required to execute dynamically generated code.
		/// 
		/// Memory allocated with this function is guaranteed to be aligned on an 8-byte boundary.
		/// 
		/// The GlobalAlloc and LocalAlloc functions are limited to a combined total of 65,536 handles for GMEM_MOVEABLE and LMEM_MOVEABLE memory per process. This limitation does not apply to GMEM_FIXED or LMEM_FIXED memory.
		/// 
		/// If this function succeeds, it allocates at least the amount of memory requested. If the actual amount allocated is greater than the amount requested, the process can use the entire amount.
		/// To determine the actual number of bytes allocated, use the GlobalSize function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GlobalAlloc(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;


			retVal = KERNEL32.GlobalAlloc(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalDeleteAtom(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = KERNEL32.GlobalDeleteAtom(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GlobalFree function frees the specified global memory object and invalidates its handle.
		/// 
		/// Parameters:
		/// 	hMem 		Identifies the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc function.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is NULL.
		/// 	If the function fails, the return value is equal to the handle of the global memory object. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Heap corruption or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may occur if the process tries to examine or modify the memory after it has been freed.
		/// 
		/// If the hgblMem parameter is NULL, GlobalFree fails and the system generates an access violation exception.
		/// 
		/// Both GlobalFree and LocalFree will free a locked memory object. A locked memory object has a lock count greater than zero. The GlobalLock function locks a global memory object and increments the lock count by one.
		/// The GlobalUnlock function unlocks it and decrements the lock count by one. To get the lock count of a global memory object, use the GlobalFlags function.
		/// 
		/// Windows NT: However, if an application is running under a debug (DBG) version of Windows NT, such as the one distributed on the SDK CD-ROM, both GlobalFree and LocalFree enter a breakpoint just before freeing a locked object.
		/// This lets a programmer double-check the intended behavior. Typing G while using the debugger in this situation lets the freeing operation occur.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalFree(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = KERNEL32.GlobalFree(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GlobalGetAtomNameA(SalNumber param1, ref SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);
			int _param3 = (int)param3;


			retVal = KERNEL32.GlobalGetAtomNameA(_param1, _param2, _param3);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The GlobalLock function locks a global memory object and returns a pointer to the first byte of the object’s memory block.
		/// The memory block associated with a locked memory object cannot be moved or discarded. For memory objects allocated with the
		/// GMEM_MOVEABLE flag, the function increments the lock count associated with the memory object.
		/// 
		/// Parameters:
		/// 	hMem 		Identifies the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc function.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is a pointer to the first byte of the memory block.
		/// 	If the function fails, the return value is NULL. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects,
		/// GlobalLock increments the count by one, and the GlobalUnlock function decrements the count by one. For each call that a process
		/// makes to GlobalLock for an object, it must eventually call GlobalUnlock. Locked memory will not be moved or discarded, unless the
		/// memory object is reallocated by using the GlobalReAlloc function. The memory block of a locked memory object remains locked until its
		/// lock count is decremented to zero, at which time it can be moved or discarded.
		/// 
		/// Memory objects allocated with the GMEM_FIXED flag always have a lock count of zero. For these objects, the value of the returned pointer
		/// is equal to the value of the specified handle.
		/// 
		/// If the specified memory block has been discarded or if the memory block has a zero-byte size, this function returns NULL.
		/// 
		/// Discarded objects always have a lock count of zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalLock(SalNumber param1)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;


			retVal = KERNEL32.GlobalLock(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GlobalMemoryStatus function obtains information about the computer
		/// system's current usage of both physical and virtual memory.
		/// 
		/// Parameter: lpBuffer
		/// 		Pointer to a MEMORYSTATUS structure.
		/// 		The GlobalMemoryStatus function stores information about
		/// 		current memory availability into this structure.
		/// 
		/// dwLength
		/// 	The size in bytes of the MEMORYSTATUS data structure. You do not need to set this
		/// 	member before calling the GlobalMemoryStatus function; the function sets it.
		/// dwMemoryLoad
		/// 	Specifies a number between 0 and 100 that gives a general idea of current memory utilization,
		/// 	in which 0 indicates no memory use and 100 indicates full memory use.
		/// dwTotalPhys
		/// 	Indicates the total number of bytes of physical memory.
		/// dwAvailPhys
		/// 	Indicates the number of bytes of physical memory available.
		/// dwTotalPageFile
		/// 	Indicates the total number of bytes that can be stored in the paging file. Note that this
		/// 	number does not represent the actual physical size of the paging file on disk.
		/// dwAvailPageFile
		/// 	Indicates the number of bytes available in the paging file.
		/// dwTotalVirtual
		/// 	Indicates the total number of bytes that can be described in the user mode portion of the
		/// 	virtual address space of the calling process.
		/// dwAvailVirtual
		/// 	Indicates the number of bytes of unreserved and uncommitted memory in the user mode
		/// 	portion of the virtual address space of the calling process.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalMemoryStatus(ref SalNumber param1, ref SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5, ref SalNumber param6, ref SalNumber param7, ref SalNumber param8)
		{

			Structures.STRUCT_10 _struct1 = new Structures.STRUCT_10();
			_struct1.Member1 = (uint)param1;
			_struct1.Member2 = (uint)param2;
			_struct1.Member3 = (uint)param3;
			_struct1.Member4 = (uint)param4;
			_struct1.Member5 = (uint)param5;
			_struct1.Member6 = (uint)param6;
			_struct1.Member7 = (uint)param7;
			_struct1.Member8 = (uint)param8;

			KERNEL32.GlobalMemoryStatus(ref _struct1);

			param1 = (SalNumber)_struct1.Member1;
			param2 = (SalNumber)_struct1.Member2;
			param3 = (SalNumber)_struct1.Member3;
			param4 = (SalNumber)_struct1.Member4;
			param5 = (SalNumber)_struct1.Member5;
			param6 = (SalNumber)_struct1.Member6;
			param7 = (SalNumber)_struct1.Member7;
			param8 = (SalNumber)_struct1.Member8;
			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalSize(SalWindowHandle param1)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = KERNEL32.GlobalSize(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GlobalUnlock function decrements the lock count associated with a memory object that was allocated with the GMEM_MOVEABLE flag.
		/// This function has no effect on memory objects allocated with the GMEM_FIXED flag.
		/// 
		/// Parameters:
		/// 	hMem 		Identifies the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc function.
		/// 
		/// Return Values:
		/// 	If the memory object is still locked after decrementing the lock count, the return value is a nonzero value.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError. If GetLastError returns
		/// 	NO_ERROR, the memory object is unlocked.
		/// 
		/// Remarks:
		/// The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, the GlobalLock
		/// function increments the count by one, and GlobalUnlock decrements the count by one. For each call that a process makes to GlobalLock
		/// for an object, it must eventually call GlobalUnlock. Locked memory will not be moved or discarded, unless the memory object is reallocated
		/// by using the GlobalReAlloc function. The memory block of a locked memory object remains locked until its lock count is decremented to zero,
		/// at which time it can be moved or discarded.
		/// 
		/// Memory objects allocated with the GMEM_FIXED flag always have a lock count of zero. If the specified memory block is fixed memory,
		/// this function returns TRUE.
		/// 
		/// If the memory object is already unlocked, GlobalUnlock returns FALSE and GetLastError reports ERROR_NOT_LOCKED.
		/// Memory objects allocated with the LMEM_FIXED flag always have a lock count of zero and cause the ERROR_NOT_LOCKED error.
		/// 
		/// A process should not rely on the return value to determine the number of times it must subsequently call GlobalUnlock for a memory object.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GlobalUnlock(SalNumber param1)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;


			retVal = KERNEL32.GlobalUnlock(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber HeapAlloc(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;


			retVal = KERNEL32.HeapAlloc(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean HeapFree(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;
			int _param3 = (int)param3;


			retVal = KERNEL32.HeapFree(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The LoadLibrary function maps the specified executable module into the address space of the calling process.
		/// 
		/// Parameters:
		/// 	lpLibFileName 		Points to a null-terminated string that names the executable module (either a .DLL or .EXE file). The name specified is the filename of the module and is not related to
		/// 				the name stored in the library module itself, as specified by the LIBRARY keyword in the module-definition (.DEF) file.
		/// 
		/// 				If the string specifies a path but the file does not exist in the specified directory, the function fails. When specifying a path, be sure to use backslashes (\), not forward slashes (/).
		/// 
		/// 				If a path is not specified and the filename extension is omitted, the default library extension .DLL is appended. However, the filename string can include a trailing point character (.)
		/// 				to indicate that the module name has no extension. When no path is specified, the function searches for the file in the following sequence:
		/// 
		/// 				1. The directory from which the application loaded.
		/// 
		/// 				2. The current directory.
		/// 
		/// 				3. Windows 95: The Windows system directory. Use the GetSystemDirectory function to get the path of this directory.
		/// 
		/// 				Windows NT: The 32-bit Windows system directory. Use the GetSystemDirectory function to get the path of this directory. The name of this directory is SYSTEM32.
		/// 
		/// 				4. Windows NT: The 16-bit Windows system directory. There is no Win32 function that obtains the path of this directory, but it is searched. The name of this directory is SYSTEM.
		/// 
		/// 				5. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.
		/// 
		/// 				6. The directories that are listed in the PATH environment variable.
		/// 
		/// 				The first directory searched is the one directory containing the image file used to create the calling process (for more information, see the CreateProcess function).
		/// 				Doing this allows private dynamic-link library (DLL) files associated with a process to be found without adding the process’s installed directory to the PATH environment variable.
		/// 
		/// 				Once the function obtains a fully qualified path to a library module file, the path is compared (case independently) to the full paths of library modules currently loaded into the calling process.
		/// 				These libraries include those loaded when the process was starting up as well as those previously loaded by LoadLibrary but not unloaded by FreeLibrary.
		/// 				If the path matches the path of an already loaded module, the function just increments the reference count for the module and returns the module handle for that library.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is a handle to the module.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// LoadLibrary can be used to map a DLL module and return a handle that can be used in GetProcAddress to get the address of a DLL function. LoadLibrary can also be used to map other executable modules.
		/// For example, the function can specify an .EXE file to get a handle that can be used in FindResource or LoadResource.
		/// 
		/// Module handles are not global or inheritable. A call to LoadLibrary by one process does not produce a handle that another process can use ¾ for example, in calling GetProcAddress.
		/// The other process must make its own call to LoadLibrary for the module before calling GetProcAddress.
		/// 
		/// If the module is a DLL not already mapped for the calling process, the system calls the DLL’s DllEntryPoint function with the DLL_PROCESS_ATTACH value.
		/// If the DLL’s entry-point function does not return TRUE, LoadLibrary fails and returns NULL.
		/// 
		/// Windows 95: If you are using LoadLibrary to load a module that contains a resource whose numeric identifier is greater than 0x7FFF, LoadLibrary fails.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber LoadLibraryA(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = KERNEL32.LoadLibraryA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle LoadModule(SalString param1, SalNumber param2)
		{
			SalWindowHandle retVal = 0;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;


			retVal = KERNEL32.LoadModule(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean MoveFileA(SalString param1, SalString param2)
		{
			SalBoolean retVal = false;
			string _param1 = param1.Value;
			string _param2 = param2.Value;


			retVal = KERNEL32.MoveFileA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber OpenProcess(SalNumber param1, SalBoolean param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			bool _param2 = (bool)param2;
			uint _param3 = (uint)param3;


			retVal = KERNEL32.OpenProcess(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean TerminateProcess(SalNumber param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;


			retVal = KERNEL32.TerminateProcess(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The Sleep function suspends the execution of the current thread for a specified interval, in milliseconds.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber Sleep(SalNumber param1)
		{
			uint _param1 = (uint)param1;


			KERNEL32.Sleep(_param1);

			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber WinExec(SalString param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;


			retVal = KERNEL32.WinExec(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber RtlZeroMemory(SalNumber param1, SalNumber param2)
		{
			int _param1 = (int)param1;
			uint _param2 = (uint)param2;


			KERNEL32.RtlZeroMemory(_param1, _param2);

			return 0;
		}
		
		/// <summary>
		/// The FindExecutable function retrieves the name and handle to the executable (.EXE) file associated with the specified filename.
		/// 
		/// Parameters:
		/// 	lpFile 		Pointer to a null-terminated string specifying a filename. This can be a document or executable file.
		/// 	lpDirectory 	Pointer to a null-terminated string specifying the default directory.
		/// 	lpResult 		Pointer to a buffer to receive the filename when the function returns. This filename is a null-terminated string specifying the executable file started when an “open” association
		/// 			is run on the file specified in the lpFile parameter.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is greater than 32.
		/// 	If the function fails, the return value is less than or equal to 32. The following table lists the possible error values:
		/// 	Value  				Meaning
		/// 	0 				The system is out of memory or resources.
		///  	31 				There is no association for the specified file type.
		///  	ERROR_FILE_NOT_FOUND 		The specified file was not found.
		/// 	ERROR_PATH_NOT_FOUND 	The specified path was not found.
		/// 	ERROR_BAD_FORMAT 		The .EXE file is invalid (non-Win32 .EXE or error in .EXE image).
		/// 
		/// Remarks:
		/// When FindExecutable returns, the lpResult parameter may contain the path to the DDE server started if no server responds to a request to initiate a DDE conversation.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber FindExecutableA(SalString param1, SalString param2, ref SalString param3)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			string _param2 = param2.Value;
			System.Text.StringBuilder _param3 = new System.Text.StringBuilder(param3.Value);


			retVal = SHELL32.FindExecutableA(_param1, _param2, _param3);

			param3 = _param3.ToString();
			return retVal;
		}
		
		/// <summary>
		/// Sends a message to the system to add, modify, or delete an icon from the taskbar status area.
		/// 
		/// Parameters:
		/// 	dwMessage 	Identifier of the message to send. This parameter can be one of these values:
		/// 			NIM_ADD 	Adds an icon to the status area.
		/// 			NIM_DELETE 	Deletes an icon from the status area.
		/// 			NIM_MODIFY 	Modifies an icon in the status area.
		/// 	pnid 		Pointer to a NOTIFYICONDATA structure. The content of the structure depends on the value of dwMessage.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean Shell_NotifyIconA(SalNumber param1, SalNumber param2, SalWindowHandle param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalString param8)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;

			Structures.STRUCT_11 _struct1 = new Structures.STRUCT_11();
			_struct1.Member1 = (uint)param2;
			_struct1.Member2 = (System.IntPtr)param3;
			_struct1.Member3 = (uint)param4;
			_struct1.Member4 = (uint)param5;
			_struct1.Member5 = (uint)param6;
			_struct1.Member6 = (uint)param7;
			_struct1.Member7 = param8.Value;

			retVal = SHELL32.Shell_NotifyIconA(_param1, ref _struct1);

			return retVal;
		}
		
		/// <summary>
		/// Function: ShellExecuteA
		/// Description: The ShellExecute function opens or prints a specified file. The file can be an executable file or a document file. See ShellExecuteEx also.
		/// 
		/// Parameters:
		/// 	hwnd 		Specifies a parent window. This window receives any message boxes that an application produces. For example, an application may report an error by producing a message box.
		/// 	lpOperation 	Pointer to a null-terminated string that specifies the operation to perform. The following operation strings are valid:
		/// 			String  		Meaning
		/// 			"open"		The function opens the file specified by lpFile. The file can be an executable file or a document file. The file can be a folder to open.
		/// 			"print" 		The function prints the file specified by lpFile. The file should be a document file. If the file is an executable file, the function opens the file, as if “open” had been specified.
		/// 			"explore"		The function explores the folder specified by lpFile.
		/// 			The lpOperation parameter can be NULL. In that case, the function opens the file specified by lpFile.
		/// 	lpFile 		Pointer to a null-terminated string that specifies the file to open or print or the folder to open or explore. The function can open an executable file or a document file. The function can print a document file.
		/// 	lpParameters 	If lpFile specifies an executable file, lpParameters is a pointer to a null-terminated string that specifies parameters to be passed to the application.
		/// 			If lpFile specifies a document file, lpParameters should be NULL.
		/// 	lpDirectory 	Pointer to a null-terminated string that specifies the default directory.
		/// 	nShowCmd 	If lpFile specifies an executable file, nShowCmd specifies how the application is to be shown when it is opened. This parameter can be one of the following values:
		/// 			Value 			Meaning
		///  			SW_HIDE 		Hides the window and activates another window.
		///  			SW_MAXIMIZE 		Maximizes the specified window.
		///  			SW_MINIMIZE 		Minimizes the specified window and activates the next top-level window in the Z order.
		///  			SW_RESTORE 		Activates and displays the window. If the window is minimized or maximized, Windows restores it to its original size and position.
		/// 						An application should specify this flag when restoring a minimized window.
		///  			SW_SHOW 		Activates the window and displays it in its current size and position.
		///  			SW_SHOWDEFAULT 	Sets the show state based on the SW_ flag specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application.
		/// 						An application should call ShowWindow with this flag to set the initial show state of its main window.
		///  			SW_SHOWMAXIMIZED 	Activates the window and displays it as a maximized window.
		/// 			SW_SHOWMINIMIZED 	Activates the window and displays it as a minimized window.
		///  			SW_SHOWMINNOACTIVE 	Displays the window as a minimized window. The active window remains active.
		///  			SW_SHOWNA 		Displays the window in its current state. The active window remains active.
		///  			SW_SHOWNOACTIVATE 	Displays a window in its most recent size and position. The active window remains active.
		///  			SW_SHOWNORMAL 	Activates and displays a window. If the window is minimized or maximized, Windows restores it to its original size and position.
		/// 						An application should specify this flag when displaying the window for the first time.
		/// 
		/// 			If lpFile specifies a document file, nShowCmd should be zero.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the instance handle of the application that was run, or the handle of a dynamic data exchange (DDE) server application.
		/// 	If the function fails, the return value is an error value that is less than or equal to 32. The following table lists these error values:
		/// 	Value  				Meaning
		///  	0 				The operating system is out of memory or resources.
		///  	ERROR_FILE_NOT_FOUND 		The specified file was not found.
		///  	ERROR_PATH_NOT_FOUND 	The specified path was not found.
		///  	ERROR_BAD_FORMAT 		The .EXE file is invalid (non-Win32 .EXE or error in .EXE image).
		///  	SE_ERR_ACCESSDENIED 		The operating system denied access to the specified file.
		///  	SE_ERR_ASSOCINCOMPLETE 	The filename association is incomplete or invalid.
		///  	SE_ERR_DDEBUSY 		The DDE transaction could not be completed because other DDE transactions were being processed.
		///  	SE_ERR_DDEFAIL 		The DDE transaction failed.
		///  	SE_ERR_DDETIMEOUT 		The DDE transaction could not be completed because the request timed out.
		///  	SE_ERR_DLLNOTFOUND 		The specified dynamic-link library was not found.
		///  	SE_ERR_FNF 			The specified file was not found.
		///  	SE_ERR_NOASSOC 		There is no application associated with the given filename extension.
		///  	SE_ERR_OOM 			There was not enough memory to complete the operation.
		///  	SE_ERR_PNF 			The specified path was not found.
		///  	SE_ERR_SHARE 			A sharing violation occurred.
		/// 
		/// Remarks:
		/// The file specified by the lpFile parameter can be a document file or an executable file. If the file is a document file, the ShellExecute function opens or prints it, depending on the value of the lpOperation parameter.
		/// If the file is an executable file, the ShellExecute function opens it, even if lpOperation specifies printing.
		/// 
		/// You can use ShellExecute to open or explore a shell folder. To open a folder, use either of the following calls:
		/// 
		/// ShellExecute(handle, NULL, path_to_folder, NULL, NULL, SW_SHOWNORMAL);
		/// or
		/// ShellExecute(handle, "open", path_to_folder, NULL, NULL, SW_SHOWNORMAL);
		/// 
		/// To explore a folder, use the following call:
		/// 
		/// ShellExecute(handle, "explore", path_to_folder, NULL, NULL, SW_SHOWNORMAL);
		/// 
		/// If lpOperation is NULL, the function opens the file specified by lpFile. If lpOperation is "open" or "explore", the function will force an open window or explorer.
		/// Export Ordinal: 0
		/// Returns
		/// Number: DWORD
		/// Parameters
		/// Window Handle: HWND
		/// String: LPSTR
		/// String: LPSTR
		/// String: LPSTR
		/// String: LPSTR
		/// Number: INT
		/// int SHFileOperation( LPSHFILEOPSTRUCT lpFileOp );
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber SHFileOperation(SalString param1)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;


			retVal = SHELL32.SHFileOperation(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The AppendMenu function appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu.
		/// You can use this function to specify the content, appearance, and behavior of the menu item.
		/// The AppendMenu function has been superseded by the InsertMenuItem function.
		/// You can still use AppendMenu, however, if you do not need any of the extended features of InsertMenuItem.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu bar, drop-down menu, submenu, or shortcut menu to be changed.
		/// 	uFlags 		Specifies flags to control the appearance and behavior of the new menu item.
		/// 			This parameter can be a combination of the values listed in the following Remarks section.
		/// 	uIDNewItem 	Specifies either the identifier of the new menu item or, if the uFlags parameter is set to MF_POPUP,
		/// 			the handle to the drop-down menu or submenu.
		/// 	lpNewItem 	Specifies the content of the new menu item. The interpretation of lpNewItem depends on whether
		/// 			the uFlags parameter includes the MF_BITMAP, MF_OWNERDRAW, or MF_STRING flag, as follows:
		/// 			Value 			Description
		/// 			MF_BITMAP 		Contains a bitmap handle.
		/// 			MF_OWNERDRAW 	Contains a 32-bit value supplied by the application that can be used to maintain
		/// 						additional data related to the menu item. The value is in the itemData member of
		/// 						the structure pointed to by the lparam parameter of the WM_MEASURE or
		/// 						WM_DRAWITEM message sent when the menu is created or its appearance is updated.
		/// 			MF_STRING 		Contains a pointer to a null-terminated string.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The application must call the DrawMenuBar function whenever a menu changes, whether or not the menu is in a displayed window.
		/// The following flags can be set in the uFlags parameter:
		/// Value 			Description
		/// MF_BITMAP 		Uses a bitmap as the menu item. The lpNewItem parameter contains the handle to the bitmap.
		/// MF_CHECKED 		Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps),
		/// 			this flag displays the check mark bitmap next to the menu item.
		/// MF_DISABLED 		Disables the menu item so it cannot be selected, but the flag does not gray it.
		/// MF_ENABLED 		Enables the menu item so it can be selected, and restores it from its grayed state.
		/// MF_GRAYED 		Disables the menu item and grays it so it cannot be selected.
		/// MF_MENUBARBREAK 	Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is separated from the old column by a vertical line.
		/// MF_MENUBREAK 		Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu)
		/// 			without separating columns.
		/// MF_OWNERDRAW 	Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns
		/// 			the menu receives a WM_MEASUREITEM message to retrieve the width and height of the menu item.
		/// 			The WM_DRAWITEM message is then sent to the window procedure of the owner window whenever the
		/// 			appearance of the menu item must be updated.
		/// MF_POPUP 		Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies the
		/// 			handle to the drop-down menu or submenu. This flag is used to add a menu name to a menu bar, or a menu item
		/// 			that opens a submenu to a drop-down menu, submenu, or shortcut menu.
		/// MF_SEPARATOR 		Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu.
		/// 			The line cannot be grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
		/// MF_STRING 		Specifies that the menu item is a text string; the lpNewItem parameter points to the string.
		/// MF_UNCHECKED 		Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps
		/// 			(see SetMenuItemBitmaps), this flag displays the unchecked bitmap next to the menu item.
		/// 
		/// The following groups of flags cannot be used together:
		/// · MF_DISABLED, MF_ENABLED, and MF_GRAYED
		/// · MF_BITMAP, MF_STRING, and MF_OWNERDRAW
		/// · MF_MENUBARBREAK and MF_MENUBREAK
		/// · MF_CHECKED and MF_UNCHECKED
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean AppendMenuA(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalString param4)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;
			string _param4 = param4.Value;


			retVal = USER32.AppendMenuA(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The AppendMenu function appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu.
		/// You can use this function to specify the content, appearance, and behavior of the menu item.
		/// The AppendMenu function has been superseded by the InsertMenuItem function.
		/// You can still use AppendMenu, however, if you do not need any of the extended features of InsertMenuItem.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu bar, drop-down menu, submenu, or shortcut menu to be changed.
		/// 	uFlags 		Specifies flags to control the appearance and behavior of the new menu item.
		/// 			This parameter can be a combination of the values listed in the following Remarks section.
		/// 	uIDNewItem 	Specifies either the identifier of the new menu item or, if the uFlags parameter is set to MF_POPUP,
		/// 			the handle to the drop-down menu or submenu.
		/// 	lpNewItem 	Specifies the content of the new menu item. The interpretation of lpNewItem depends on whether
		/// 			the uFlags parameter includes the MF_BITMAP, MF_OWNERDRAW, or MF_STRING flag, as follows:
		/// 			Value 			Description
		/// 			MF_BITMAP 		Contains a bitmap handle.
		/// 			MF_OWNERDRAW 	Contains a 32-bit value supplied by the application that can be used to maintain
		/// 						additional data related to the menu item. The value is in the itemData member of
		/// 						the structure pointed to by the lparam parameter of the WM_MEASURE or
		/// 						WM_DRAWITEM message sent when the menu is created or its appearance is updated.
		/// 			MF_STRING 		Contains a pointer to a null-terminated string.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The application must call the DrawMenuBar function whenever a menu changes, whether or not the menu is in a displayed window.
		/// The following flags can be set in the uFlags parameter:
		/// Value 			Description
		/// MF_BITMAP 		Uses a bitmap as the menu item. The lpNewItem parameter contains the handle to the bitmap.
		/// MF_CHECKED 		Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps),
		/// 			this flag displays the check mark bitmap next to the menu item.
		/// MF_DISABLED 		Disables the menu item so it cannot be selected, but the flag does not gray it.
		/// MF_ENABLED 		Enables the menu item so it can be selected, and restores it from its grayed state.
		/// MF_GRAYED 		Disables the menu item and grays it so it cannot be selected.
		/// MF_MENUBARBREAK 	Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is separated from the old column by a vertical line.
		/// MF_MENUBREAK 		Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu)
		/// 			without separating columns.
		/// MF_OWNERDRAW 	Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns
		/// 			the menu receives a WM_MEASUREITEM message to retrieve the width and height of the menu item.
		/// 			The WM_DRAWITEM message is then sent to the window procedure of the owner window whenever the
		/// 			appearance of the menu item must be updated.
		/// MF_POPUP 		Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies the
		/// 			handle to the drop-down menu or submenu. This flag is used to add a menu name to a menu bar, or a menu item
		/// 			that opens a submenu to a drop-down menu, submenu, or shortcut menu.
		/// MF_SEPARATOR 		Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu.
		/// 			The line cannot be grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
		/// MF_STRING 		Specifies that the menu item is a text string; the lpNewItem parameter points to the string.
		/// MF_UNCHECKED 		Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps
		/// 			(see SetMenuItemBitmaps), this flag displays the unchecked bitmap next to the menu item.
		/// 
		/// The following groups of flags cannot be used together:
		/// · MF_DISABLED, MF_ENABLED, and MF_GRAYED
		/// · MF_BITMAP, MF_STRING, and MF_OWNERDRAW
		/// · MF_MENUBARBREAK and MF_MENUBREAK
		/// · MF_CHECKED and MF_UNCHECKED
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean AppendMenuW(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalString param4)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;
			string _param4 = param4.Value;


			retVal = USER32.AppendMenuW(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting.
		/// 
		/// Parameters:
		/// 	hwnd 		Identifies the window to be repainted.
		/// 	lpPaint 		Pointer to the PAINTSTRUCT structure that will receive painting information.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to a display device context for the specified window.
		/// 	If the function fails, the return value is NULL, indicating that no display device context is available.
		/// 
		/// Remarks:
		/// The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
		/// The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling, or any other operation that affects the client area.
		/// If the update region is marked for erasing, BeginPaint sends a WM_ERASEBKGND message to the window.
		/// 
		/// An application should not call BeginPaint except in response to a WM_PAINT message. Each call to BeginPaint must have a corresponding call to the EndPaint function.
		/// 
		/// If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
		/// 
		/// If the window’s class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber BeginPaint(SalWindowHandle param1, ref SalString param2)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);


			retVal = USER32.BeginPaint(_param1, _param2);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The CallNextHookEx function passes the hook information to the next hook procedure in the current hook chain.
		/// A hook procedure can call this function either before or after processing the hook information.
		/// 
		/// Parameters:
		/// 	hhk 		Identifies the current hook. An application receives this handle as a result of a previous call to the SetWindowsHookEx function.
		/// 	nCode 		Specifies the hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook information.
		/// 	wParam 		Specifies the wParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.
		/// 	lParam 		Specifies the lParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the value returned by the next hook procedure in the chain. The current hook procedure must also return this value. The meaning of the return value depends on the hook type.
		/// 	For more information, see the descriptions of the individual hook procedures.
		/// 
		/// Remarks:
		/// Hook procedures are installed in chains for particular hook types. CallNextHookEx calls the next hook in the chain.
		/// 
		/// Calling CallNextHookEx is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not
		/// receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need
		/// to prevent the notification from being seen by other applications.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber CallNextHookEx(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;


			retVal = USER32.CallNextHookEx(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The ChangeMenu function has been replaced by the following specialized functions, which are available on both Windows NT and Windows 95:
		/// Function 		Description
		/// AppendMenu 	Appends a menu item to the end of a menu.
		/// InsertMenu 	Inserts a menu item into a menu.
		/// ModifyMenu 	Modifies a menu item in a menu.
		/// RemoveMenu 	Removes a menu item from a menu; if it is a pop-up item, the corresponding pop-up menu is not destroyed.
		/// 
		/// Windows 95:
		/// Instead of using AppendMenu, InsertMenu, and ModifyMenu, applications written exclusively for Window 95 should use the
		/// following new functions, which are available only on Windows 95.
		/// Function 		Description
		/// GetMenuItemInfo 	Gets information about a menu item.
		/// InsertMenuItem 	Inserts a new menu item at the specified position in a menu bar or pop-up menu.
		/// SetMenuItemInfo 	Changes information about a menu item.
		/// 
		/// Applications written for versions earlier than Windows 3.0 can continue to call ChangeMenu.
		/// Applications written for Windows versions 3.0 and later should call these new functions.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean ChangeMenuA(SalWindowHandle param1, SalNumber param2, SalString param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			string _param3 = param3.Value;
			ushort _param4 = (ushort)param4;
			ushort _param5 = (ushort)param5;


			retVal = USER32.ChangeMenuA(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// Function: CharToOemA
		/// Description: The CharToOem function translates a string into the OEM-defined character set.
		/// (OEM stands for original equipment manufacturer.) This function supersedes the AnsiToOem function.
		/// 
		/// Parameters:
		/// 	lpszSrc 		Pointer to the null-terminated string to translate.
		/// 	lpszDst 		Pointer to the buffer for the translated string. If the CharToOem function is being used as an ANSI function,
		/// 			the string can be translated in place by setting the lpszDst parameter to the same address as the lpszSrc parameter.
		/// 			This cannot be done if CharToOem is being used as a wide-character function.
		/// 
		/// Return Values:
		/// 	The return value is always nonzero.
		/// Export Ordinal: 0
		/// Returns
		/// Parameters
		/// String: LPSTR
		/// Receive String: LPSTR
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalWindowHandle ChildWindowFromPointEx(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			uint _param4 = (uint)param4;


			retVal = USER32.ChildWindowFromPointEx(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The CheckMenuItem function sets the state of the specified menu item's check mark attribute to either checked or unchecked.
		/// The CheckMenuItem function has been superseded by the SetMenuItemInfo function. You can still use CheckMenuItem, however,
		/// if you do not need any of the extended features of SetMenuItemInfo.
		/// 
		/// Parameters:
		/// 	hmenu 		Identifies the menu of interest.
		/// 	uIDCheckItem 	Specifies the menu item whose check-mark attribute is to be set, as determined by the uCheck parameter.
		/// 	uCheck 		Specifies flags that control the interpretation of the uIDCheckItem parameter and the state of the menu item’s
		/// 			check-mark attribute. This parameter can be a combination of either MF_BYCOMMAND, or MF_BYPOSITION and
		/// 			MF_CHECKED or MF_UNCHECKED.
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that the uIDCheckItem parameter gives the identifier of the menu item.
		/// 						The MF_BYCOMMAND flag is the default, if neither the MF_BYCOMMAND nor
		/// 						MF_BYPOSITION flag is specified.
		/// 			MF_BYPOSITION 		Indicates that the uIDCheckItem parameter gives the zero-based relative position of
		/// 						the menu item.
		/// 			MF_CHECKED 		Sets the check-mark attribute to the checked state.
		/// 			MF_UNCHECKED 		Sets the check-mark attribute to the unchecked state.
		/// 
		/// Return Values:
		/// 	The return value specifies the previous state of the menu item (either MF_CHECKED or MF_UNCHECKED).
		/// 	If the menu item does not exist, the return value is 0xFFFFFFFF.
		/// 
		/// Remarks:
		/// An item in a menu bar cannot have a check mark.
		/// The uIDCheckItem parameter identifies a item that opens a submenu or a command item.
		/// For a item that opens a submenu, the uIDCheckItem parameter must specify the position of the item.
		/// For a command item, the uIDCheckItem parameter can specify either the item’s position or its identifier.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean CheckMenuItem(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;


			retVal = USER32.CheckMenuItem(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The ClientToScreen function converts the client coordinates of a specified point to screen coordinates.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose client area is used for the conversion.
		/// 	lpPoint 		Points to a POINT structure that contains the client coordinates to be converted.
		/// 			The new screen coordinates are copied into this structure if the function succeeds.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The ClientToScreen function replaces the client coordinates in the POINT structure with the screen coordinates.
		/// The screen coordinates are relative to the upper-left corner of the screen.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber ClientToScreen(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;

			USER32.ClientToScreen(_param1, ref _struct1);

			param2 = (SalNumber)_struct1.Member1;
			param3 = (SalNumber)_struct1.Member2;
			return 0;
		}
		
		/// <summary>
		/// The CloseClipboard function closes the clipboard.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// When the window has finished examining or changing the clipboard, close the clipboard by calling CloseClipboard.
		/// This enables other windows to access the clipboard.
		/// 
		/// Do not place an object on the clipboard after calling CloseClipboard.
		/// </summary>
		/// <returns></returns>
		public static SalBoolean CloseClipboard()
		{
			SalBoolean retVal = false;


			retVal = USER32.CloseClipboard();

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalWindowHandle CopyIcon(SalWindowHandle param1)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.CopyIcon(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The CreateMenu function creates a menu. The menu is initially empty, but it can be filled with menu items
		/// by using the InsertMenuItem, AppendMenu, and InsertMenu functions.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to the newly created menu.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// Resources associated with a menu that is assigned to a window are freed automatically.
		/// If the menu is not assigned to a window, an application must free system resources associated with the menu before closing.
		/// An application frees menu resources by calling the DestroyMenu function.
		/// 
		/// Windows 95: The system can support a maximum of 16,364 menu handles.
		/// </summary>
		/// <returns></returns>
		public static SalWindowHandle CreateMenu()
		{
			SalWindowHandle retVal = 0;


			retVal = USER32.CreateMenu();

			return retVal;
		}
		
		/// <summary>
		/// The CreatePopupMenu function creates a drop-down menu, submenu, or shortcut menu.
		/// The menu is initially empty. You can insert or append menu items by using the InsertMenuItem function.
		/// You can also use the InsertMenu function to insert menu items and the AppendMenu function to append menu items.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to the newly created menu.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// The application can add the new menu to an existing menu, or it can display a shortcut menu by calling the
		/// TrackPopupMenuEx or TrackPopupMenu functions.
		/// 
		/// Resources associated with a menu that is assigned to a window are freed automatically.
		/// If the menu is not assigned to a window, an application must free system resources associated with the menu before closing.
		/// An application frees menu resources by calling the DestroyMenu function.
		/// 
		/// Windows 95: The system can support a maximum of 16,364 menu handles.
		/// </summary>
		/// <returns></returns>
		public static SalWindowHandle CreatePopupMenu()
		{
			SalWindowHandle retVal = 0;


			retVal = USER32.CreatePopupMenu();

			return retVal;
		}
		
		/// <summary>
		/// Function: CreateWindowExA
		/// Description: The CreateWindowEx function creates an overlapped, pop-up, or child window with an extended style;
		/// otherwise, this function is identical to the CreateWindow function.
		/// For more information about creating a window and for full descriptions of the other parameters of CreateWindowEx, see CreateWindow.
		/// 
		/// Parameters:
		/// 	dwExStyle 	Specifies the extended style of the window. This parameter can be one of the following values:
		/// 			Style  Meaning
		/// 			WS_EX_ACCEPTFILES 		Specifies that a window created with this style accepts drag-drop files.
		/// 			WS_EX_APPWINDOW 		Forces a top-level window onto the taskbar when the window is minimized.
		/// 			WS_EX_CLIENTEDGE 		Specifies that a window has a border with a sunken edge.
		/// 			WS_EX_CONTEXTHELP 		Includes a question mark in the title bar of the window. When the user clicks the question mark, the cursor changes to a question mark with a pointer.
		/// 							If the user then clicks a child window, the child receives a WM_HELP message. The child window should pass the message to the parent window procedure,
		/// 							which should call the WinHelp function using the HELP_WM_HELP command. The Help application displays a pop-up window that typically
		/// 							contains help for the child window.
		/// 							WS_EX_CONTEXTHELP cannot be used with the WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.
		/// 			WS_EX_CONTROLPARENT 		Allows the user to navigate among the child windows of the window by using the TAB key.
		/// 			WS_EX_DLGMODALFRAME 	Creates a window that has a double border; the window can, optionally, be created with a title bar by specifying the WS_CAPTION style in the dwStyle parameter.
		///  			WS_EX_LEFT 			Window has generic “left-aligned” properties. This is the default.
		/// 			WS_EX_LEFTSCROLLBAR 		If the shell language is Hebrew, Arabic, or another language that supports reading order alignment, the vertical scroll bar (if present) is to the left of the client area.
		/// 							For other languages, the style is ignored and not treated as an error.
		/// 			WS_EX_LTRREADING 		The window text is displayed using Left to Right reading-order properties. This is the default.
		/// 			WS_EX_MDICHILD 		Creates an MDI child window.
		/// 			WS_EX_NOPARENTNOTIFY 	Specifies that a child window created with this style does not send the WM_PARENTNOTIFY message to its parent window when it is created or destroyed.
		/// 			WS_EX_OVERLAPPEDWINDOW 	Combines the WS_EX_CLIENTEDGE and WS_EX_WINDOWEDGE styles.
		/// 			WS_EX_PALETTEWINDOW 	Combines the WS_EX_WINDOWEDGE, WS_EX_TOOLWINDOW, and WS_EX_TOPMOST styles.
		/// 			WS_EX_RIGHT 			Window has generic "right-aligned" properties. This depends on the window class. This style has an effect only if the shell language is Hebrew,
		/// 							Arabic, or another language that supports reading order alignment; otherwise, the style is ignored and not treated as an error.
		/// 			WS_EX_RIGHTSCROLLBAR 	Vertical scroll bar (if present) is to the right of the client area. This is the default.
		/// 			WS_EX_RTLREADING 		 If the shell language is Hebrew, Arabic, or another language that supports reading order alignment, the window text is displayed using Right
		/// 							to Left reading-order properties. For other languages, the style is ignored and not treated as an error.
		///  			WS_EX_STATICEDGE 		Creates a window with a three-dimensional border style intended to be used for items that do not accept user input.
		/// 			WS_EX_TOOLWINDOW 		Creates a tool window; that is, a window intended to be used as a floating toolbar. A tool window has a title bar that is shorter than a normal title bar,
		/// 							and the window title is drawn using a smaller font. A tool window does not appear in the taskbar or in the dialog that appears when the user presses ALT+TAB.
		/// 							If a tool window has a system menu, its icon is not displayed on the title bar. However, you can display the system menu by right-clicking or by typing ALT+SPACE.
		/// 			WS_EX_TOPMOST 		Specifies that a window created with this style should be placed above all non-topmost windows and should stay above them, even when the window is deactivated.
		/// 							To add or remove this style, use the SetWindowPos function.
		/// 			WS_EX_TRANSPARENT 		Specifies that a window created with this style is to be transparent. That is, any windows that are beneath the window are not obscured by the window.
		/// 							A window created with this style receives WM_PAINT messages only after all sibling windows beneath it have been updated.
		/// 			WS_EX_WINDOWEDGE 		Specifies that a window has a border with a raised edge.
		/// 
		/// 			Using the WS_EX_RIGHT style for static or edit controls has the same effect as using the SS_RIGHT or ES_RIGHT style, respectively.
		/// 			Using this style with button controls has the same effect as using BS_RIGHT and BS_RIGHTBUTTON styles.
		/// 
		/// 	lpClassName 	Points to a null-terminated string or is an integer atom. If lpClassName is an atom, it must be a global atom created by a previous call to GlobalAddAtom.
		/// 			The atom, a 16-bit value less than 0xC000, must be in the low-order word of lpClassName; the high-order word must be zero.
		/// 			If lpClassName is a string, it specifies the window class name. The class name can be any name registered with the RegisterClass function or any of the predefined control-class names.
		/// 	lpWindowName 	Points to a null-terminated string that specifies the window name.
		/// 	dwStyle 		Specifies the style of the window being created. For a list of the window styles that can be specified in dwStyle, see CreateWindow.
		/// 	x 		Specifies the initial horizontal position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the window’s upper-left corner, in screen coordinates.
		/// 			For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window’s client area.
		/// 			If x is set to CW_USEDEFAULT, Windows selects the default position for the window’s upper-left corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
		/// 			if it is specified for a pop-up or child window, the x and y parameters are set to zero.
		/// 	y 		Specifies the initial vertical position of the window. For an overlapped or pop-up window, the y parameter is the initial y-coordinate of the window’s upper-left corner, in screen coordinates.
		/// 			For a child window, y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window’s client area.
		/// 			For a list box, y is the initial y-coordinate of the upper-left corner of the list box’s client area relative to the upper-left corner of the parent window’s client area.
		/// 			If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter is set to CW_USEDEFAULT, Windows ignores the y parameter.
		/// 	nWidth 		Specifies the width, in device units, of the window. For overlapped windows, nWidth is the window’s width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
		/// 			Windows selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from
		/// 			the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window, the nWidth and
		/// 			nHeight parameter are set to zero.
		/// 	nHeight 		Specifies the height, in device units, of the window. For overlapped windows, nHeight is the window’s height, in screen coordinates. If the nWidth parameter is set to CW_USEDEFAULT, Windows ignores nHeight.
		/// 	hWndParent 	Identifies the parent or owner window of the window being created. A valid window handle must be supplied when a child window or an owned window is created. A child window is confined to the client
		/// 			area of its parent window. An owned window is an overlapped window that is destroyed when its owner window is destroyed or hidden when its owner is minimized; it is always displayed on top of its owner window.
		/// 			Although this parameter must specify a valid handle if the dwStyle parameter includes the WS_CHILD style, it is optional if dwStyle includes the WS_POPUP style.
		/// 	hMenu 		Identifies a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
		/// 			it can be NULL if the class menu is to be used. For a child window, hMenu specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events.
		/// 			The application determines the child-window identifier; it must be unique for all child windows with the same parent window.
		/// 	hInstance 	Identifies the instance of the module to be associated with the window.
		/// 	lpParam 		Points to a value passed to the window through the CREATESTRUCT structure referenced by the lParam parameter of the WM_CREATE message. If an application calls CreateWindow
		/// 			to create a multiple document interface client window, lpParam must point to a CLIENTCREATESTRUCT structure.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to the new window.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// The CreateWindowEx function sends WM_NCCREATE, WM_NCCALCSIZE, and WM_CREATE messages to the window being created.
		/// 
		/// For information about the window control classes, window styles, and control styles used with this function, see the description of the CreateWindow function.
		/// 
		/// Windows 95: The system can support a maximum of 16,364 window handles.
		/// Export Ordinal: 0
		/// Returns
		/// Window Handle: HWND
		/// Parameters
		/// Number: DWORD
		/// String: LPSTR
		/// String: LPSTR
		/// Number: DWORD
		/// Number: INT
		/// Number: INT
		/// Number: INT
		/// Number: INT
		/// Window Handle: HWND
		/// Number: HANDLE
		/// Number: HANDLE
		/// Number: DWORD
		/// The DefWindowProc function calls the default window procedure to provide default processing for any window messages
		/// that an application does not process. This function ensures that every message is processed.
		/// DefWindowProc is called with the same parameters received by the window procedure.
		/// 
		/// Parameters:
		/// hWnd 		Identifies the window procedure that received the message.
		/// Msg 		Specifies the message.
		/// wParam 		Specifies additional message information. The content of this parameter depends on the value of the Msg parameter.
		/// lParam 		Specifies additional message information. The content of this parameter depends on the value of the Msg parameter.
		/// 
		/// Return Values:
		/// The return value is the result of the message processing and depends on the message.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber DefWindowProcA(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;
			int _param4 = (int)param4;


			retVal = USER32.DefWindowProcA(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The DeleteMenu function deletes an item from the specified menu.
		/// If the menu item opens a menu or submenu, this function destroys the handle to the menu or submenu and frees the memory used by the menu or submenu.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu to be changed.
		/// 	uPosition 		Specifies the menu item to be deleted, as determined by the uFlags parameter.
		/// 	uFlags 		Specifies how the uPosition parameter is interpreted. This parameter must be one of the following values:
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that uPosition gives the identifier of the menu item.
		/// 						The MF_BYCOMMAND flag is the default flag if neither the MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
		/// 			MF_BYPOSITION 		Indicates that uPosition gives the zero-based relative position of the menu item.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The application must call the DrawMenuBar function whenever a menu changes, whether or not the menu is in a displayed window.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean DeleteMenu(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;


			retVal = USER32.DeleteMenu(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The DestroyMenu function destroys the specified menu and frees any memory that the menu occupies.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu to be destroyed.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Before closing, an application must use the DestroyMenu function to destroy a menu not assigned to a window.
		/// A menu that is assigned to a window is automatically destroyed when the application closes.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DestroyMenu(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.DestroyMenu(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The DestroyIcon function destroys an icon and frees any memory the icon occupied.
		/// 
		/// Parameters:
		/// 	hIcon 	Handle to the icon to be destroyed. The icon must not be in use.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, callGetLastError.
		/// 
		/// Remarks:
		/// It is only necessary to call DestroyIcon for icons and cursors created with the CreateIconIndirect function. Do not use this function to destroy a shared icon.
		/// A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon:
		/// 
		/// 	LoadIcon
		/// 	LoadImage (if you use the LR_SHARED flag)
		/// 	CopyImage (if you use the LR_COPYRETURNORG flag and the hImage parameter is a shared icon)
		/// 
		/// Windows CE: The DestroyIcon function may be called on the icon handle returned from CreateIconIndirect, ExtractIconEx, LoadImage or LoadIcon.
		/// The icon handle is invalid after calling DestroyIcon.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DestroyIcon(SalNumber param1)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;


			retVal = USER32.DestroyIcon(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber DispatchMessageA(ref SalString param1)
		{
			SalNumber retVal = 0;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);


			retVal = USER32.DispatchMessageA(_param1);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The DragDetect function captures the mouse and tracks its movement until the user releases the left button,
		/// presses the ESC key, or moves the mouse outside the "drag rectangle" around the specified point.
		/// The width and height of the drag rectangle are specified by the SM_CXDRAG and SM_CYDRAG values returned by the GetSystemMetrics function.
		/// 
		/// Parameters:
		/// 	hwnd 		Handle to the window receiving mouse input.
		/// 	pt 		Initial position of the mouse, in screen coordinates. The function determines the coordinates of the drag rectangle by using this point.
		/// 
		/// Return Values:
		/// 	If the user moved the mouse outside of the drag rectangle while holding the left button down, the return value is nonzero.
		/// 	If the user did not move the mouse outside of the drag rectangle while holding the left button down, the return value is zero.
		/// 
		/// Remarks:
		/// The system metrics for the drag rectangle are configurable, allowing for larger or smaller drag rectangles.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean DragDetect(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;

			retVal = USER32.DragDetect(_param1, ref _struct1);

			return retVal;
		}
		
		/// <summary>
		/// The DrawEdge function draws one or more edges of rectangle.
		/// 
		/// Parameters:
		/// 	hdc 		Identifies the device context.
		/// 	qrc 		Points to a RECT structure that contains the logical coordinates of the rectangle.edge
		/// 			Specifies the type of inner and outer edge to draw. This parameter must be a combination of one inner-border flag and one outer-border flag. The inner-border flags are as follows:
		/// 			Value 				Meaning
		/// 			BDR_RAISEDINNER 		Raised inner edge.
		/// 			BDR_SUNKENINNER 		Sunken inner edge.
		/// 
		/// 			The outer-border flags are as follows:
		/// 			Value 				Meaning
		/// 			BDR_RAISEDOUTER 		Raised outer edge.
		/// 			BDR_SUNKENOUTER 		Sunken outer edge.
		/// 
		/// 			Alternatively, the edge parameter can specify one of the following flags:
		/// 			Value 				Meaning
		/// 			EDGE_BUMP 			Combination of BDR_RAISEDOUTER and BDR_SUNKENINNER.
		/// 			EDGE_ETCHED 			Combination of BDR_SUNKENOUTER and BDR_RAISEDINNER.
		/// 			EDGE_RAISED 			Combination of BDR_RAISEDOUTER and BDR_RAISEDINNER.
		/// 			EDGE_SUNKEN 			Combination of BDR_SUNKENOUTER and BDR_SUNKENINNER.
		/// 	grfFlags 		Specifies the type of border. This parameter can be a combination of these values:
		/// 			Value 				Meaning
		/// 			BF_ADJUST 			Rectangle to be adjusted to leave space for client area.
		/// 			BF_BOTTOM 			Bottom of border rectangle.
		/// 			BF_BOTTOMLEFT 			Bottom and left side of border rectangle.
		/// 			BF_BOTTOMRIGHT 		Bottom and right side of border rectangle.
		/// 			BF_DIAGONAL 			Diagonal border.
		/// 			BF_DIAGONAL_ENDBOTTOMLEFT 	Diagonal border. The end point is the bottom-left corner of the rectangle; the origin is top-right corner.
		/// 			BF_DIAGONAL_ENDBOTTOMRIGHT 	Diagonal border. The end point is the bottom-right corner of the rectangle; the origin is top-left corner.
		/// 			BF_DIAGONAL_ENDTOPLEFT 	Diagonal border. The end point is the top-left corner of the rectangle; the origin is bottom-right corner.
		/// 			BF_DIAGONAL_ENDTOPRIGHT 	Diagonal border. The end point is the top-right corner of the rectangle; the origin is bottom-left corner.
		/// 			BF_FLAT 			Flat border.
		/// 			BF_LEFT 			Left side of border rectangle.
		/// 			BF_MIDDLE 			Interior of rectangle to be filled.
		/// 			BF_MONO 			One-dimensional border.
		/// 			BF_RECT 			Entire border rectangle.
		/// 			BF_RIGHT 			Right side of border rectangle.
		/// 			BF_SOFT 			Soft buttons instead of tiles.
		/// 			BF_TOP 				Top of border rectangle.
		/// 			BF_TOPLEFT 			Top and left side of border rectangle.
		/// 			BF_TOPRIGHT 			Top and right side of border rectangle.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean DrawEdge(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7)
		{
			SalBoolean retVal = false;
			int _param1 = (int)param1;
			uint _param6 = (uint)param6;
			uint _param7 = (uint)param7;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.DrawEdge(_param1, ref _struct1, _param6, _param7);

			return retVal;
		}
		
		/// <summary>
		/// The DrawFocusRect function draws a rectangle in the style used to indicate that the rectangle has the focus.
		/// 
		/// Parameters:
		/// 	hDC 		Identifies the device context.
		/// 	lprc 		Points to a RECT structure that specifies the logical coordinates of the rectangle.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Because DrawFocusRect is an XOR function, calling it a second time with the same rectangle removes the rectangle from the screen.
		/// 
		/// This function draws a rectangle that cannot be scrolled. To scroll an area containing a rectangle drawn by this function,
		/// call DrawFocusRect to remove the rectangle from the screen, scroll the area, and then call DrawFocusRect again to draw the rectangle in the new position.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean DrawFocusRect(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.DrawFocusRect(_param1, ref _struct1);

			return retVal;
		}
		
		/// <summary>
		/// The DrawFrameControl function draws a frame control of the specified type and style.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean DrawFrameControl(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7)
		{
			SalBoolean retVal = false;
			int _param1 = (int)param1;
			uint _param6 = (uint)param6;
			uint _param7 = (uint)param7;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.DrawFrameControl(_param1, ref _struct1, _param6, _param7);

			return retVal;
		}
		
		/// <summary>
		/// The DrawMenuBar function redraws the menu bar of the specified window.
		/// If the menu bar changes after Windows has created the window, this function must be called to draw the changed menu bar.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose menu bar needs redrawing.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean DrawMenuBar(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.DrawMenuBar(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber DrawTextA(SalNumber param1, SalString param2, SalNumber param3, ref SalNumber param4, ref SalNumber param5, ref SalNumber param6, ref SalNumber param7, SalNumber param8)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			string _param2 = param2.Value;
			int _param3 = (int)param3;
			int _param8 = (int)param8;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param4;
			_struct1.Member2 = (int)param5;
			_struct1.Member3 = (int)param6;
			_struct1.Member4 = (int)param7;

			retVal = USER32.DrawTextA(_param1, _param2, _param3, ref _struct1, _param8);

			param4 = (SalNumber)_struct1.Member1;
			param5 = (SalNumber)_struct1.Member2;
			param6 = (SalNumber)_struct1.Member3;
			param7 = (SalNumber)_struct1.Member4;
			return retVal;
		}
		
		/// <summary>
		/// The EmptyClipboard function empties the clipboard and frees handles to data in the clipboard. The function then assigns ownership of the clipboard to the window that currently has the clipboard open.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Before calling EmptyClipboard, an application must open the clipboard by using the OpenClipboard function.
		/// If the application specifies a NULL window handle when opening the clipboard, EmptyClipboard succeeds but sets the clipboard owner to NULL.
		/// </summary>
		/// <returns></returns>
		public static SalBoolean EmptyClipboard()
		{
			SalBoolean retVal = false;


			retVal = USER32.EmptyClipboard();

			return retVal;
		}
		
		/// <summary>
		/// The EnableMenuItem function enables, disables, or grays the specified menu item.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu.
		/// 	uIDEnableItem 	Specifies the menu item to be enabled, disabled, or grayed, as determined by the uEnable parameter. This parameter specifies an item in a menu bar, menu, or submenu.
		/// 	uEnable 		Specifies flags that control the interpretation of the uIDEnableItem parameter and indicate whether the menu item is enabled, disabled, or grayed.
		/// 			This parameter must be a combination of either MF_BYCOMMAND or MF_BYPOSITION and MF_ENABLED, MF_DISABLED, or MF_GRAYED.
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that uIDEnableItem gives the identifier of the menu item. If neither the MF_BYCOMMAND nor MF_BYPOSITION flag
		/// 						is specified, the MF_BYCOMMAND flag is the default flag.
		/// 			MF_BYPOSITION 		Indicates that uIDEnableItem gives the zero-based relative position of the menu item.
		/// 			MF_DISABLED 		Indicates that the menu item is disabled, but not grayed, so it cannot be selected.
		/// 			MF_ENABLED 		Indicates that the menu item is enabled and restored from a grayed state so that it can be selected.
		/// 			MF_GRAYED 		Indicates that the menu item is disabled and grayed so that it cannot be selected.
		/// 
		/// Return Values:
		/// 	The return value specifies the previous state of the menu item (it is either MF_DISABLED, MF_ENABLED, or MF_GRAYED).
		/// 	If the menu item does not exist, the return value is 0xFFFFFFFF.
		/// 
		/// Remarks:
		/// An application must use the MF_BYPOSITION flag to specify the correct menu handle. If the menu handle to the menu bar is specified, the top-level menu item (an item in the menu bar) is affected.
		/// To set the state of an item in a drop-down menu or submenu by position, an application must specify the handle to the drop-down menu or submenu.
		/// 
		/// When an application specifies the MF_BYCOMMAND flag, Windows checks all items that open submenus in the menu identified by the specified menu handle.
		/// Therefore, unless duplicate menu items are present, specifying the menu handle to the menu bar is sufficient.
		/// 
		/// The InsertMenu, InsertMenuItem, LoadMenuIndirect, ModifyMenu, and SetMenuItemInfo functions can also set the state (enabled, disabled, or grayed) of a menu item.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber EnableMenuItem(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;


			retVal = USER32.EnableMenuItem(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The EndPaint function marks the end of painting in the specified window.
		/// This function is required for each call to the BeginPaint function, but only after painting is complete.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window that has been repainted.
		/// 	lpPaint 		Points to a PAINTSTRUCT structure that contains the painting information retrieved by BeginPaint.
		/// 
		/// Return Values:
		/// 	The return value is always nonzero.
		/// 
		/// Remarks:
		/// If the caret was hidden by BeginPaint, EndPaint restores the caret to the screen.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber EndPaint(SalWindowHandle param1, SalString param2)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;
			string _param2 = param2.Value;


			USER32.EndPaint(_param1, _param2);

			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean ExitWindowsEx(SalNumber param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;


			retVal = USER32.ExitWindowsEx(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber FillRect(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param6 = (uint)param6;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.FillRect(_param1, ref _struct1, _param6);

			return retVal;
		}
		
		/// <summary>
		/// The FindWindow function retrieves the handle to the top-level window whose class name and window name match the specified strings.
		///  This function does not search child windows.
		/// 
		/// Parameters:
		/// 	lpClassName 	Points to a null-terminated string that specifies the class name or is an atom that identifies the class-name string.
		/// 			If this parameter is an atom, it must be a global atom created by a previous call to the GlobalAddAtom function.
		/// 			The atom, a 16-bit value, must be placed in the low-order word of lpClassName; the high-order word must be zero.
		/// 	lpWindowName 	Points to a null-terminated string that specifies the window name (the window’s title). If this parameter is NULL,
		/// 			all window names match.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to the window that has the specified class name and window name.
		/// 	If the function fails, the return value is NULL.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle FindWindowA(SalString param1, SalString param2)
		{
			SalWindowHandle retVal = 0;
			string _param1 = param1.Value;
			string _param2 = param2.Value;


			retVal = USER32.FindWindowA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The GetActiveWindow function retrieves the window handle to the active window associated with the thread that calls the function.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle to the active window associated with the thread that calls the function.
		/// 	If the calling thread does not have an active window, the return value is NULL.
		/// </summary>
		/// <returns></returns>
		public static SalWindowHandle GetActiveWindow()
		{
			SalWindowHandle retVal = 0;


			retVal = USER32.GetActiveWindow();

			return retVal;
		}
		
		/// <summary>
		/// The GetAsyncKeyState function determines whether a key is up or down at the time the function is called,
		/// and whether the key was pressed after a previous call to GetAsyncKeyState.
		/// 
		/// Parameters:
		/// 	vKey 	Specifies one of 256 possible virtual-key codes.
		/// 		For more information, see Virtual-Key Codes.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value specifies whether the key was pressed since the last call to
		/// GetAsyncKeyState, and whether the key is currently up or down. If the most significant bit is set, the key is down,
		/// and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.
		/// The return value is zero if a window in another thread or process currently has the keyboard focus.
		/// 
		/// Windows 95: Windows 95 does not support the left- and right-distinguishing constants.
		/// If you call GetAsyncKeyState with these constants, the return value is zero.
		/// 
		/// Remarks:
		/// The GetAsyncKeyState function works with mouse buttons. However, it checks on the state of the physical
		/// mouse buttons, not on the logical mouse buttons that the physical buttons are mapped to. For example,
		/// the call GetAsyncKeyState(VK_LBUTTON) always returns the state of the left physical mouse button,
		/// regardless of whether it is mapped to the left or right logical mouse button. You can determine the system's
		/// current mapping of physical mouse buttons to logical mouse buttons by calling
		/// 
		/// GetSystemMetrics(SM_SWAPBUTTON)
		/// 
		/// which returns TRUE if the mouse buttons have been swapped.
		/// 
		/// You can use the virtual-key code constants VK_SHIFT, VK_CONTROL, and VK_MENU as values for the
		/// vKey parameter. This gives the state of the SHIFT, CTRL, or ALT keys without distinguishing between left and right.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetAsyncKeyState(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = USER32.GetAsyncKeyState(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetClassName function retrieves the name of the class to which the specified window belongs.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window and, indirectly, the class to which the window belongs.
		/// 	lpClassName 	Points to the buffer that is to receive the class name string.
		/// 	nMaxCount 	Specifies the length, in characters, of the buffer pointed to by the lpClassName parameter.
		/// 			The class name string is truncated if it is longer than the buffer.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the number of characters copied to the specified buffer.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetClassNameA(SalWindowHandle param1, ref SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.Text.StringBuilder _param2 = new System.Text.StringBuilder(param2.Value);
			int _param3 = (int)param3;


			retVal = USER32.GetClassNameA(_param1, _param2, _param3);

			param2 = _param2.ToString();
			return retVal;
		}
		
		/// <summary>
		/// Function: GetClientRect
		/// Description: The GetClientRect function retrieves the coordinates of a window’s client area.
		/// The client coordinates specify the upper-left and lower-right corners of the client area.
		/// Because client coordinates are relative to the upper-left corner of a window’s client area, the coordinates of the upper-left corner are (0,0).
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose client coordinates are to be retrieved.
		/// 	lpRect 		Points to a RECT structure that receives the client coordinates. The left and top members are zero.
		/// 			The right and bottom members contain the width and height of the window.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// Export Ordinal: 0
		/// Returns
		/// Parameters
		/// Window Handle: HWND
		/// structPointer
		/// Receive Number: LONG
		/// Receive Number: LONG
		/// Receive Number: LONG
		/// Receive Number: LONG
		/// The GetClipboardData function retrieves data from the clipboard in a specified format. The clipboard must have been opened previously.
		/// 
		/// Parameters:
		/// 	uFormat 		Specifies a clipboard format. For a description of the clipboard formats, see the SetClipboardData function.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of a clipboard object in the specified format.
		/// 	If the function fails, the return value is NULL. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// An application can enumerate the available formats in advance by using the EnumClipboardFormats function.
		/// 
		/// The clipboard controls the handle that the GetClipboardData function returns, not the application. The application should copy the data immediately.
		/// The application cannot rely on being able to make long-term use of the handle. The application must not free the handle nor leave it locked.
		/// 
		/// The operating system performs implicit data format conversions between certain clipboard formats when an application calls the GetClipboardData
		/// function. For example, if the CF_OEMTEXT format is on the clipboard, a window can retrieve data in the CF_TEXT format.
		/// The format on the clipboard is converted to the requested format on demand. The following table shows the clipboard data type conversions
		/// that are available. Note that some of these automatic type conversions are not available on all platforms.
		/// Clipboard Format 		Conversion Format 		Platform Support
		/// CF_BITMAP 		CF_DIB 			Windows NT, Windows 95
		/// CF_DIB 			CF_BITMAP 		Windows NT, Windows 95
		/// CF_DIB 			CF_PALETTE 		Windows NT, Windows 95
		/// CF_ENHMETAFILE 	CF_METAFILEPICT 	Windows NT, Windows 95
		/// CF_METAFILEPICT 	CF_ENHMETAFILE 	Windows NT, Windows 95
		/// CF_OEMTEXT 		CF_TEXT 		Windows NT, Windows 95
		/// CF_OEMTEXT 		CF_UNICODETEXT 	Windows NT
		/// CF_TEXT 		CF_OEMTEXT 		Windows NT, Windows 95
		/// CF_TEXT 		CF_UNICODETEXT 	Windows NT
		/// CF_UNICODETEXT 	CF_OEMTEXT 		Windows NT
		/// CF_UNICODETEXT 	CF_TEXT 		Windows NT
		/// 
		/// If the operating system provides an automatic type conversion for a particular clipboard format, there is no advantage to placing the conversion
		/// format(s) on the clipboard.
		/// 
		/// If the system provides an automatic type conversion for a particular clipboard format, and you call EnumClipboardFormats to enumerate the
		/// clipboard data formats, the operating system first enumerates the format that is on the clipboard, followed by the formats to which it can be converted.
		/// 
		/// If the clipboard contains data in the CF_PALETTE format, the application should use the SelectPalette and RealizePalette functions to realize
		/// any other data in the clipboard against that logical palette.
		/// 
		/// See SetClipboardData for further information on specific clipboard data formats.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetClipboardData(SalNumber param1)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;


			retVal = USER32.GetClipboardData(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public static SalWindowHandle GetCursor()
		{
			SalWindowHandle retVal = 0;


			retVal = USER32.GetCursor();

			return retVal;
		}
		
		/// <summary>
		/// The GetCursorPos function retrieves the cursor’s position, in screen coordinates.
		/// 
		/// Parameters:
		/// 	lpPoint 		Points to a POINT structure that receives the screen coordinates of the cursor.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The cursor position is always given in screen coordinates and is not affected by the mapping mode of the window that contains the cursor.
		/// 
		/// The calling process must have WINSTA_READATTRIBUTES access to the window station.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetCursorPos(ref SalNumber param1, ref SalNumber param2)
		{

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param1;
			_struct1.Member2 = (int)param2;

			USER32.GetCursorPos(ref _struct1);

			param1 = (SalNumber)_struct1.Member1;
			param2 = (SalNumber)_struct1.Member2;
			return 0;
		}
		
		/// <summary>
		/// The GetDC function retrieves a handle of a display device context (DC) for the client area of the specified window.
		/// The display device context can be used in subsequent GDI functions to draw in the client area of the window.
		/// 
		/// This function retrieves a common, class, or private device context depending on the class style specified for the specified window.
		/// For common device contexts, GetDC assigns default attributes to the device context each time it is retrieved.
		/// For class and private device contexts, GetDC leaves the previously assigned attributes unchanged.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose device context is to be retrieved.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value identifies the device context for the given window’s client area.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// After painting with a common device context, the ReleaseDC function must be called to release the device context.
		/// Class and private device contexts do not have to be released. The number of device contexts is limited only by available memory.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetDC(SalWindowHandle param1)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.GetDC(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetDesktopWindow function returns a handle to the desktop window.
		/// The desktop window covers the entire screen.
		/// The desktop window is the area on top of which all icons and other windows are painted.
		/// </summary>
		/// <returns></returns>
		public static SalWindowHandle GetDesktopWindow()
		{
			SalWindowHandle retVal = 0;


			retVal = USER32.GetDesktopWindow();

			return retVal;
		}
		
		/// <summary>
		/// The GetDlgItem function retrieves the handle of a control in the specified dialog box.
		/// 
		/// Parameters:
		/// 	hDlg 		Identifies the dialog box that contains the control.
		/// 	nIDDlgItem 	Specifies the identifier of the control to be retrieved.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the window handle of the given control.
		/// 	If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control.
		/// 
		/// Remarks:
		/// You can use the GetDlgItem function with any parent-child window pair, not just with dialog boxes.
		/// As long as the hDlg parameter specifies a parent window and the child window has a unique identifier
		/// (as specified by the hMenu parameter in the CreateWindow or CreateWindowEx function that created the child window),
		/// GetDlgItem returns a valid handle to the child window.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle GetDlgItem(SalWindowHandle param1, SalNumber param2)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.GetDlgItem(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The GetForegroundWindow function returns the handle of the foreground window (the window with which the user is currently working).
		/// The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	The return value is the handle of the foreground window.
		/// </summary>
		/// <returns></returns>
		public static SalWindowHandle GetForegroundWindow()
		{
			SalWindowHandle retVal = 0;


			retVal = USER32.GetForegroundWindow();

			return retVal;
		}
		
		/// <summary>
		/// The GetKeyState function retrieves the status of the specified virtual key.
		/// The status specifies whether the key is up, down, or toggled (on, off ¾ alternating each time the key is pressed).
		/// 
		/// Parameters:
		/// 	nVirtKey 		Specifies a virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set to the ASCII value of that character. For other keys, it must be a virtual-key code.
		/// 			If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example,
		/// 			for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value specifies the status of the given virtual key. If the high-order bit is 1, the key is down; otherwise, it is up. If the low-order bit is 1, the key is toggled.
		/// 	A key, such as the CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0. A toggle key’s indicator light (if any) on the keyboard
		/// 	will be on when the key is toggled, and off when the key is untoggled.
		/// 
		/// Remarks:
		/// The key status returned from this function changes as a given thread reads key messages from its message queue.
		/// The status does not reflect the interrupt-level state associated with the hardware. Use the GetAsyncKeyState function to retrieve that information.
		/// 
		/// An application calls GetKeyState in response to a keyboard-input message. This function retrieves the state of the key when the input message was generated.
		/// 
		/// To retrieve state information for all the virtual keys, use the GetKeyboardState function.
		/// 
		/// An application can use the virtual-key code constants VK_SHIFT, VK_CONTROL, and VK_MENU as values for the nVirtKey parameter.
		/// This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between left and right.
		/// An application can also use the following virtual-key code constants as values for nVirtKey to distinguish between the left and right instances of those keys:
		/// VK_LSHIFT  VK_RSHIFT  VK_LCONTROL  VK_RCONTROL  VK_LMENU  VK_RMENU
		/// 
		/// These left- and right-distinguishing constants are available to an application only through the
		/// GetKeyboardState, SetKeyboardState, GetAsyncKeyState, GetKeyState, and MapVirtualKey functions.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetKeyState(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = USER32.GetKeyState(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetMenu function retrieves the handle of the menu assigned to the given window.
		/// 
		/// Parameters
		/// 	hWnd 		Identifies the window whose menu handle is retrieved.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the menu. If the given window has no menu, the return value is NULL.
		/// 	If the window is a child window, the return value is undefined.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalWindowHandle GetMenu(SalWindowHandle param1)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.GetMenu(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetMenuItemCount function determines the number of items in the specified menu.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the handle of the menu to be examined.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value specifies the number of items in the menu.
		/// 	If the function fails, the return value is -1. To get extended error information, call GetLastError.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetMenuItemCount(SalWindowHandle param1)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.GetMenuItemCount(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetMenuItemID function retrieves the menu item identifier of a menu item located at the specified position in a menu.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu that contains the item whose identifier is to be retrieved.
		/// 	nPos 		Specifies the zero-based relative position of the menu item whose identifier is to be retrieved.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value specifies the identifier of the given menu item.
		/// If the menu item identifier is NULL or if the specified item opens a submenu, the return value is 0xFFFFFFFF.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetMenuItemID(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.GetMenuItemID(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// This function is obsolete. Use the GetSystemMetrics with the CXMENUCHECK and CYMENUCHECK values to retrieve the bitmap dimensions.
		/// 
		/// The GetMenuCheckMarkDimensions function returns the dimensions of the default check mark bitmap.
		/// Windows displays this bitmap next to checked menu items. Before calling the SetMenuItemBitmaps function to replace the default
		/// check mark bitmap for a menu item, an application must determine the correct bitmap size by calling GetMenuCheckMarkDimensions.
		/// 
		/// LONG GetMenuCheckMarkDimensions(VOID)
		/// 
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	The return value specifies the height and width, in pixels, of the default check mark bitmap.
		/// 	The high-order word contains the height; the low-order word contains the width.
		/// </summary>
		/// <returns></returns>
		public static SalNumber GetMenuCheckMarkDimensions()
		{
			SalNumber retVal = 0;


			retVal = USER32.GetMenuCheckMarkDimensions();

			return retVal;
		}
		
		/// <summary>
		/// The GetMenuState function retrieves the menu flags associated with the specified menu item.
		/// If the menu item opens a submenu, this function also returns the number of items in the submenu.
		/// 
		/// The GetMenuState function has been superseded by the GetMenuItemInfo function.
		/// You can still use GetMenuState, however, if you do not need any of the extended features of GetMenuItemInfo.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu that contains the menu item whose flags are to be retrieved.
		/// 	uId 		Specifies the menu item for which the menu flags are to be retrieved, as determined by the uFlags parameter.
		/// 	uFlags 		Specifies how the uId parameter is interpreted. This parameter can be one of the following values:
		/// 			Value 			Description
		/// 			MF_BYCOMMAND 		Indicates that the uId parameter gives the identifier of the menu item.
		/// 						The MF_BYCOMMAND flag is the default if neither the MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
		///  			MF_BYPOSITION 		Indicates that the uId parameter gives the zero-based relative position of the menu item.
		/// 
		/// Return Values:
		/// 	If the specified item does not exist, the return value is 0xFFFFFFFF.
		/// 	If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order byte contains the number of items in the submenu opened by the item.
		/// 
		/// 	Otherwise, the return value is a mask (Boolean OR) of the menu flags. Following are the menu flags associated with the menu item.
		/// 	Value 			Description
		///  	MF_CHECKED 		Places a check mark next to the item (for drop-down menus, submenus, and shortcut menus only).
		/// 	MF_DISABLED 		Disables the item.
		/// 	MF_GRAYED 		Disables and grays the item.
		/// 	MF_HILITE 		Highlights the item.
		/// 	MF_MENUBARBREAK 	Functions the same as the MF_MENUBREAK flag, except for drop-down menus, submenus, and shortcut menus,
		/// 				where the new column is separated from the old column by a vertical line.
		/// 	MF_MENUBREAK 		Places the item on a new line (for menu bars) or in a new column (for drop-down menus, submenus, and shortcut menus) without separating columns.
		/// 	MF_SEPARATOR 		Creates a horizontal dividing line (for drop-down menus, submenus, and shortcut menus only).
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetMenuState(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;


			retVal = USER32.GetMenuState(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The GetMenuString function copies the text string of the specified menu item into the specified buffer.
		/// GetMenuString works, but is obsolete. Use GetMenuItemInfo instead.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu.
		/// 	uIDItem 		Specifies the menu item to be changed, as determined by the uFlag parameter.
		/// 	lpString 		Points to the buffer that is to receive the null-terminated string.
		/// 			If lpString is NULL, the function returns the length of the menu string.
		/// 	nMaxCount 	Specifies the maximum length, in characters, of the string to be copied. If the string is longer than the maximum
		/// 			specified in the nMaxCount parameter, the extra characters are truncated.
		/// 			If nMaxCount is 0, the function returns the length of the menu string.
		/// 	uFlag 		Specifies how the uIDItem parameter is interpreted. This parameter must be one of the following values:
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that uIDItem gives the identifier of the menu item. If neither the
		/// 						MF_BYCOMMAND nor MF_BYPOSITION flag is specified, the MF_BYCOMMAND flag is the default flag.
		/// 			MF_BYPOSITION 		 Indicates that uIDItem gives the zero-based relative position of the menu item.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The nMaxCount parameter must be one larger than the number of characters in the text string to accommodate the terminating null character.
		/// If nMaxCount is 0, the function returns the length of the menu string.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber GetMenuStringA(SalWindowHandle param1, SalNumber param2, ref SalString param3, SalNumber param4, SalNumber param5)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			System.Text.StringBuilder _param3 = new System.Text.StringBuilder(param3.Value);
			int _param4 = (int)param4;
			ushort _param5 = (ushort)param5;


			retVal = USER32.GetMenuStringA(_param1, _param2, _param3, _param4, _param5);

			param3 = _param3.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The GetNextWindow function retrieves the handle of the next or previous window in the Z order.
		/// The next window is below the specified window; the previous window is above. If the specified window is a topmost window,
		/// the function retrieves the handle of the next (or previous) topmost window. If the specified window is a top-level window,
		/// the function retrieves the handle of the next (or previous) top-level window. If the specified window is a a child window,
		/// the function searches for a handle of the next (or previous) child window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies a window. The window handle retrieved is relative to this window, based on the value of the wCmd parameter.
		/// 	wCmd 		Specifies whether the function returns the handle of the next window or of the previous window.
		/// 			This parameter can be either of the following values:
		/// 			Value 			Meaning
		/// 			GW_HWNDNEXT 		Returns the handle of the window below the given window.
		/// 			GW_HWNDPREV 		Returns the handle of the window above the given window.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the next (or previous) window.
		/// 	If there is no next (or previous) window, the return value is NULL. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Using this function is the same as calling the GetWindow function with the GW_HWNDNEXT or GW_HWNDPREV flag set.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle GetNextWindow(SalWindowHandle param1, SalNumber param2)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.GetNextWindow(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The GetParent function retrieves the handle of the specified child window’s parent window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose parent window handle is to be retrieved.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the parent window.
		/// 	If the window has no parent window, the return value is NULL. To get extended error information, call GetLastError.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalWindowHandle GetParent(SalWindowHandle param1)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.GetParent(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetScrollInfo function retrieves the parameters of a scroll bar,
		/// including the minimum and maximum scrolling positions, the page size,
		/// and the position of the scroll box (thumb).
		/// 
		/// Parameters:
		/// hwnd 	Handle to a scroll bar control or a window with a standard scroll bar,
		/// 	depending on the value of the fnBar parameter.
		/// fnBar 	Specifies the type of scroll bar for which to retrieve parameters.
		/// 	This parameter can be one of the following values:
		/// 	Value 		Meaning
		/// 	SB_CTL 		Retrieves the parameters for a scroll bar control.
		/// 			The hwnd parameter must be the handle to the scroll bar control.
		/// 	SB_HORZ 	Retrieves the parameters for the given window's standard horizontal scroll bar.
		/// 	SB_VERT 	Retrieves the parameters for the given window's standard vertical scroll bar.
		/// lpsi 	Pointer to a SCROLLINFO structure. Before calling GetScrollInfo, set the cbSize member of the
		/// 	structure to sizeof(SCROLLINFO), and set the fMask member to specify the scroll bar parameters to retrieve.
		/// 	Before returning, the function copies the specified parameters to the appropriate members of the structure.
		/// 	The fMask member can be a combination of the following values:
		/// 	Value 		Meaning
		/// 	SIF_PAGE 	Copies the scroll page to the nPage member of the SCROLLINFO structure pointed to by lpsi.
		/// 	SIF_POS 		Copies the scroll position to the nPos member of the SCROLLINFO structure pointed to by lpsi.
		/// 	SIF_RANGE 	Copies the scroll range to the nMin and nMax members of the SCROLLINFO structure pointed to by lpsi.
		/// 	SIF_TRACKPOS 	Copies the current scroll box tracking position to the nTrackPos member of the
		/// 			SCROLLINFO structure pointed to by lpsi.
		/// 
		/// Return Values:
		/// If the function retrieved any values, the return value is nonzero.
		/// If the function does not retrieve any values, the return value is zero. To get extended error information, callGetLastError.
		/// 
		/// Remarks:
		/// The GetScrollInfo function enables applications to use 32-bit scroll positions. Although the messages that indicate
		/// scroll-bar position, WM_HSCROLL and WM_VSCROLL, provide only 16 bits of position data, the functions
		/// SetScrollInfo and GetScrollInfo provide 32 bits of scroll-bar position data. Thus, an application can call
		/// GetScrollInfo while processing either the WM_HSCROLL or WM_VSCROLL messages to obtain 32-bit scroll-bar position data.
		/// 
		/// To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK notification in a WM_HSCROLL or
		/// WM_VSCROLL message, call GetScrollInfo with the SIF_TRACKPOS value in the fMask member of the
		/// SCROLLINFO structure. The function returns the tracking position of the scroll box in the nTrackPos member
		/// of the SCROLLINFO structure. This allows you to get the position of the scroll box as the user moves it.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean GetScrollInfo(SalWindowHandle param1, SalNumber param2, ref SalNumber param3, ref SalNumber param4, ref SalNumber param5, ref SalNumber param6, ref SalNumber param7, ref SalNumber param8, ref SalNumber param9)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;

			Structures.STRUCT_12 _struct1 = new Structures.STRUCT_12();
			_struct1.Member1 = (uint)param3;
			_struct1.Member2 = (uint)param4;
			_struct1.Member3 = (int)param5;
			_struct1.Member4 = (int)param6;
			_struct1.Member5 = (uint)param7;
			_struct1.Member6 = (int)param8;
			_struct1.Member7 = (int)param9;

			retVal = USER32.GetScrollInfo(_param1, _param2, ref _struct1);

			param3 = (SalNumber)_struct1.Member1;
			param4 = (SalNumber)_struct1.Member2;
			param5 = (SalNumber)_struct1.Member3;
			param6 = (SalNumber)_struct1.Member4;
			param7 = (SalNumber)_struct1.Member5;
			param8 = (SalNumber)_struct1.Member6;
			param9 = (SalNumber)_struct1.Member7;
			return retVal;
		}
		
		/// <summary>
		/// The GetSubMenu function retrieves the handle of the drop-down menu or submenu activated by the specified menu item.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu.
		/// 	nPos 		Specifies the zero-based relative position in the given menu of an item that activates a drop-down menu or submenu.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the drop-down menu or submenu activated by the menu item.
		/// 	If the menu item does not activate a drop-down menu or submenu, the return value is NULL.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle GetSubMenu(SalWindowHandle param1, SalNumber param2)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.GetSubMenu(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetSysColor(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = USER32.GetSysColor(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetSystemMenu function allows the application to access the window menu (also known as the System menu or the Control menu) for copying and modifying.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window that will own a copy of the window menu.
		/// 	bRevert 		Specifies the action to be taken. If this parameter is FALSE, GetSystemMenu returns the handle of the copy of the window menu currently in use.
		/// 			The copy is initially identical to the window menu, but it can be modified.
		/// 
		/// 			If this parameter is TRUE, GetSystemMenu resets the window menu back to the Windows default state. The previous window menu, if any, is destroyed.
		/// 
		/// Return Values:
		/// 	If the bRevert parameter is FALSE, the return value is the handle of a copy of the window menu.
		/// 	If the bRevert parameter is TRUE, the return value is NULL.
		/// 
		/// Remarks:
		/// Any window that does not use the GetSystemMenu function to make its own copy of the window menu receives the standard window menu.
		/// 
		/// The window menu initially contains items with various identifier values, such as SC_CLOSE, SC_MOVE, and SC_SIZE.
		/// 
		/// Menu items on the window menu send WM_SYSCOMMAND messages.
		/// 
		/// All predefined window menu items have identifier numbers greater than 0xF000. If an application adds commands to the window menu,
		/// it should use identifier numbers less than 0xF000.
		/// 
		/// Windows automatically grays items on the standard window menu, depending on the situation.
		/// The application can perform its own checking or graying by responding to the WM_INITMENU message that is sent before any menu is displayed.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle GetSystemMenu(SalWindowHandle param1, SalBoolean param2)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			bool _param2 = (bool)param2;


			retVal = USER32.GetSystemMenu(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The GetSystemMetrics function retrieves various system metrics and system configuration settings.
		/// 
		/// System metrics are the dimensions (widths and heights) of Windows display elements. All dimensions retrieved by GetSystemMetrics are in pixels.
		/// 
		/// Parameters:
		/// 	nIndex 		Specifies the system metric or configuration setting to retrieve. All SM_CX* values are widths. All SM_CY* values are heights.
		/// 			The following values are defined:
		/// 			Value 				Meaning
		/// 			SM_ARRANGE 			Flags specifying how the system arranged minimized windows. For more information about minimized windows, see the following Remarks section.
		/// 			SM_CLEANBOOT 			Value that specifies how the system was started:
		/// 							0 Normal boot
		/// 							1 Fail-safe boot
		/// 							2 Fail-safe with network boot
		/// 							Fail-safe boot (also called SafeBoot) bypasses the user’s startup files.
		/// 			SM_CMOUSEBUTTONS 		Number of buttons on mouse, or zero if no mouse is installed.
		/// 			SM_CXBORDER, SM_CYBORDER 	The width and height, in pixels, of a window border. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.
		///  			SM_CXCURSOR, SM_CYCURSOR 	Width and height, in pixels, of a cursor. These are the cursor dimensions supported by the current display driver.
		/// 							The system cannot create cursors of other sizes.
		///  			SM_CXDLGFRAME, SM_CYDLGFRAME 	Same as SM_CXFIXEDFRAME and SM_CYFIXEDFRAME.
		///  			SM_CXDOUBLECLK, SM_CYDOUBLECLK 	Width and height, in pixels, of the rectangle around the location of a first click in a double-click sequence.
		/// 								The second click must occur within this rectangle for the system to consider the two clicks a double-click.
		/// 								(The two clicks must also occur within a specified time.)
		/// 			SM_CXDRAG, SM_CYDRAG 		Width and height, in pixels, of a rectangle centered on a drag point to allow for limited movement of the mouse pointer before a drag operation begins.
		/// 							This allows the user to click and release the mouse button easily without unintentionally starting a drag operation.
		/// 			SM_CXEDGE, SM_CYEDGE 		Dimensions, in pixels, of a 3-D border. These are the 3-D counterparts of SM_CXBORDER and SM_CYBORDER.
		/// 			SM_CXFIXEDFRAME,SM_CYFIXEDFRAME 	Thickness, in pixels, of the frame around the perimeter of a window that has a caption but is not sizable.
		/// 								SM_CXFIXEDFRAME is the width of the horizontal border and SM_CYFIXEDFRAME is the height of the vertical border.
		/// 								Same as SM_CXDLGFRAME and SM_CYDLGFRAME.
		/// 			SM_CXFRAME, SM_CYFRAME 	Same as SM_CXSIZEFRAME and SM_CYSIZEFRAME.
		/// 			SM_CXFULLSCREEN, SM_CYFULLSCREEN 	Width and height of the client area for a full-screen window. To get the coordinates of the portion of the screen not
		/// 								obscured by the tray, call the SystemParametersInfo function with the SPI_GETWORKAREA value.
		/// 			SM_CXHSCROLL, SM_CYHSCROLL 	Width, in pixels, of the arrow bitmap on a horizontal scroll bar; and height, in pixels, of a horizontal scroll bar.
		/// 			SM_CXHTHUMB 			Width, in pixels, of the thumb box in a horizontal scroll bar.
		/// 			SM_CXICON, SM_CYICON 		The default width and height, in pixels, of an icon. These values are typically 32x32, but can vary depending on the installed display hardware.
		/// 							The LoadIcon function can only load icons of these dimensions.
		/// 			SM_CXICONSPACING, SM_CYICONSPACING 	Dimensions, in pixels, of a grid cell for items in large icon view. Each item fits into a rectangle of this size when arranged.
		/// 								These values are always greater than or equal to SM_CXICON and SM_CYICON.
		/// 			SM_CXMAXIMIZED,SM_CYMAXIMIZED 	Default dimensions, in pixels, of a maximized top-level window.
		/// 			SM_CXMAXTRACK, SM_CYMAXTRACK 	Default maximum dimensions, in pixels, of a window that has a caption and sizing borders. The user cannot drag the window frame to
		/// 								a size larger than these dimensions. A window can override these values by processing the WM_GETMINMAXINFO message.
		/// 			SM_CXMENUCHECK, SM_CYMENUCHECK 	Dimensions, in pixels, of the default menu check-mark bitmap.
		/// 			SM_CXMENUSIZE, SM_CYMENUSIZE 	Dimensions, in pixels, of menu bar buttons, such as multiple document (MIDI) child close.
		/// 			SM_CXMIN, SM_CYMIN 		Minimum width and height, in pixels, of a window.
		/// 			SM_CXMINIMIZED, SM_CYMINIMIZED 	Dimensions, in pixels, of a normal minimized window.
		/// 			SM_CXMINSPACING, SM_CYMINSPACING 	Dimensions, in pixels, of a grid cell for minimized windows. Each minimized window fits into a rectangle this size when arranged.
		/// 								These values are always greater than or equal to SM_CXMINIMIZED and SM_CYMINIMIZED.
		/// 			SM_CXMINTRACK, SM_CYMINTRACK 	Minimum tracking width and height, in pixels, of a window. The user cannot drag the window frame to a size smaller than these dimensions.
		/// 								A window can override these values by processing the WM_GETMINMAXINFO message.
		/// 			SM_CXSCREEN, SM_CYSCREEN 		Width and height, in pixels, of the screen.
		/// 			SM_CXSIZE, SM_CYSIZE 		 Width and height, in pixels, of a button in a window's caption or title bar.
		/// 			SM_CXSIZEFRAME, SM_CYSIZEFRAME 	Thickness, in pixels, of the sizing border around the perimeter of a window that can be resized.
		/// 								SM_CXSIZEFRAME is the width of the horizontal border and SM_CYSIZEFRAME is the height of the vertical border.
		/// 								Same as SM_CXFRAME and SM_CYFRAME.
		/// 			SM_CXSMICON, SM_CYSMICON 	Recommended dimensions, in pixels, of a small icon. Small icons typically appear in window captions and in small icon view.
		/// 			SM_CXSMSIZE, SM_CYSMSIZE 	Dimensions, in pixels, of small caption buttons.
		/// 			SM_CXVSCROLL, SM_CYVSCROLL 	Width, in pixels, of a vertical scroll bar; and height, in pixels, of the arrow bitmap on a vertical scroll bar.
		/// 			SM_CYCAPTION 			Height, in pixels, of normal caption area.
		/// 			SM_CYKANJIWINDOW 		For double-byte character set versions of Windows, height, in pixels, of the Kanji window at the bottom of the screen.
		/// 			SM_CYMENU 			Height, in pixels, of single-line menu bar.
		/// 			SM_CYSMCAPTION 		Height, in pixels, of a small caption.
		/// 			SM_CYVTHUMB 			Height , in pixels, of the thumb box in a vertical scroll bar.
		/// 			SM_DBCSENABLED 		TRUE or nonzero if the double-byte character set (DBCS) version of USER.EXE is installed; FALSE, or zero otherwise.
		/// 			SM_DEBUG 			TRUE or nonzero if the debugging version of USER.EXE is installed; FALSE, or zero, otherwise.
		/// 			SM_MENUDROPALIGNMENT 	TRUE, or nonzero if drop-down menus are right-aligned relative to the corresponding menu-bar item; FALSE, or zero if they are left-aligned.
		/// 			SM_MIDEASTENABLED 		TRUE if the system is enabled for Hebrew/Arabic languages.
		/// 			SM_MOUSEPRESENT 		TRUE or nonzero if a mouse is installed; FALSE, or zero, otherwise.
		/// 			SM_MOUSEWHEELPRESENT 	Windows NT only: TRUE or nonzero if a mouse with a wheel is installed; FALSE, or zero, otherwise.
		/// 			SM_NETWORK 			The least significant bit is set if a network is present; otherwise, it is cleared. The other bits are reserved for future use.
		/// 			SM_PENWINDOWS 		TRUE or nonzero if the Microsoft Windows for Pen computing extensions are installed; zero, or FALSE, otherwise.
		/// 			SM_SECURE 			TRUE if security is present, FALSE otherwise.
		/// 			SM_SHOWSOUNDS 		TRUE or nonzero if the user requires an application to present information visually in situations where it would otherwise present the
		/// 							information only in audible form; FALSE, or zero, otherwise.
		/// 			SM_SLOWMACHINE 		TRUE if the computer has a low-end (slow) processor, FALSE otherwise.
		/// 			SM_SWAPBUTTON 		TRUE or nonzero if the meanings of the left and right mouse buttons are swapped; FALSE, or zero, otherwise.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the requested system metric or configuration setting.
		/// 	If the function fails, the return value is zero. GetLastError does not provide extended error information.
		/// 
		/// Remarks:
		/// System metrics may vary from display to display.
		/// 
		/// The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting position and a direction.
		/// The starting position can be one of the following values.
		/// Value 			Meaning
		/// ARW_BOTTOMLEFT 	Start at lower-left corner of screen (default position).
		/// ARW_BOTTOMRIGHT 	Start at lower-right corner of screen. Equivalent to ARW_STARTRIGHT.
		/// ARW_HIDE 		Hide minimized windows by moving them off of the visible area of the screen.
		/// ARW_TOPLEFT 		Start at upper-left corner of screen. Equivalent to ARV_STARTTOP.
		/// ARW_TOPRIGHT 		Start at upper-right corner of screen. Equivalent to ARW_STARTTOP | SRW_STARTRIGHT.
		/// 
		/// The direction in which to arrange can be one of the following values.
		/// Value 			Meaning
		/// ARW_DOWN 		Arrange vertically, top to bottom.
		/// ARW_LEFT 		Arrange horizontally, left to right.
		/// ARW_RIGHT 		Arrange horizontally, right to left.
		/// ARW_UP 		Arrange vertically, bottom to top.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetSystemMetrics(SalNumber param1)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;


			retVal = USER32.GetSystemMetrics(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The GetWindowLong function retrieves information about the specified window.
		/// The function also retrieves the 32-bit (long) value at the specified offset into the extra window memory of a window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window and, indirectly, the class to which the window belongs.
		/// 	nIndex 		Specifies the zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra window memory, minus four; for example,
		/// 			if you specified 12 or more bytes of extra memory, a value of 8 would be an index to the third 32-bit integer. To retrieve any other value, specify one of the following values:
		/// 			Value 			Action
		/// 			GWL_EXSTYLE 		Retrieves the extended window styles.
		/// 			GWL_STYLE 		Retrieves the window styles.
		/// 			GWL_WNDPROC 		Retrieves the address of the window procedure, or a handle representing the address of the window procedure.
		/// 						You must use the CallWindowProc function to call the window procedure.
		/// 			GWL_HINSTANCE 	Retrieves the handle of the application instance.
		/// 			GWL_HWNDPARENT 	Retrieves the handle of the parent window, if any.
		/// 			GWL_ID 			Retrieves the identifier of the window.
		/// 			GWL_USERDATA 		Retrieves the 32-bit value associated with the window. Each window has a corresponding 32-bit value intended for use by the application that created the window.
		/// 
		/// 			The following values are also available when the hWnd parameter identifies a dialog box:
		/// 			Value 			Action
		/// 			DWL_DLGPROC 		Retrieves the address of the dialog box procedure, or a handle representing the address of the dialog box procedure.
		/// 						You must use the CallWindowProc function to call the dialog box procedure.
		/// 			DWL_MSGRESULT 	Retrieves the return value of a message processed in the dialog box procedure.
		/// 			DWL_USER 		Retrieves extra information private to the application, such as handles or pointers.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the requested 32-bit value.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASS structure used with the RegisterClass function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetWindowLongA(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.GetWindowLongA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// Function: GetWindowRect
		/// Description: The GetWindowRect function retrieves the dimensions of the bounding rectangle of the specified window.
		/// The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window.
		/// 	lpRect 		Points to a RECT structure that receives the screen coordinates of the upper-left and lower-right corners of the window.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// Export Ordinal: 0
		/// Returns
		/// Boolean: BOOL
		/// Parameters
		/// Window Handle: HWND
		/// structPointer
		/// Receive Number: LONG
		/// Receive Number: LONG
		/// Receive Number: LONG
		/// Receive Number: LONG
		/// The GetWindow function retrieves the handle of a window that has the specified relationship (Z order or owner) to the specified window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies a window. The window handle retrieved is relative to this window,
		/// 			based on the value of the uCmd parameter.
		/// 	uCmd 		Specifies the relationship between the specified window and the window whose handle is to be retrieved.
		/// 			This parameter can be one of the following values:
		/// 			Value 		 	Meaning
		/// 			GW_CHILD 		The retrieved handle identifies the child window at the top of the Z order,
		/// 						if the specified window is a parent window; otherwise, the retrieved handle is NULL.
		/// 						The function examines only child windows of the specified window.
		/// 						It does not examine descendant windows.
		/// 			GW_HWNDFIRST 		The retrieved handle identifies the window of the same type that is highest in the Z
		/// 						order. If the specified window is a topmost window, the handle identifies the topmost
		/// 						window that is highest in the Z order. If the specified window is a top-level window,
		/// 						the handle identifies the top-level window that is highest in the Z order.
		/// 						If the specified window is a child window, the handle identifies the sibling window
		/// 						that is highest in the Z order.
		/// 			GW_HWNDLAST 		The retrieved handle identifies the window of the same type that is lowest in the Z order.
		/// 						If the specified window is a topmost window, the handle identifies the topmost window
		/// 						that is lowest in the Z order. If the specified window is a top-level window, the handle
		/// 						identifies the top-level window that is lowest in the Z order. If the specified window is a
		/// 						child window, the handle identifies the sibling window that is lowest in the Z order.
		/// 			GW_HWNDNEXT 		The retrieved handle identifies the window below the specified window in the Z order.
		/// 						If the specified window is a topmost window, the handle identifies the topmost window
		/// 						below the specified window. If the specified window is a top-level window, the handle
		/// 						identifies the top-level window below the specified window. If the specified window is a
		/// 						child window, the handle identifies the sibling window below the specified window.
		/// 			GW_HWNDPREV 		The retrieved handle identifies the window above the specified window in the Z order.
		/// 						If the specified window is a topmost window, the handle identifies the topmost window
		/// 						above the specified window. If the specified window is a top-level window, the handle
		/// 						identifies the top-level window above the specified window. If the specified window is
		/// 						a child window, the handle identifies the sibling window above the specified window.
		/// 			GW_OWNER 		The retrieved handle identifies the specified window’s owner window, if any.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is a window handle.
		/// 	If no window exists with the specified relationship to the specified window, the return value is NULL.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle GetWindow(SalWindowHandle param1, SalNumber param2)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;


			retVal = USER32.GetWindow(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber GetWindowDC(SalWindowHandle param1)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.GetWindowDC(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber GetWindowTextA(SalWindowHandle param1, SalString param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			string _param2 = param2.Value;
			int _param3 = (int)param3;


			retVal = USER32.GetWindowTextA(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The GetWindowWord function retrieves a 16-bit (word) value at the specified offset into the extra window memory for the specified window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window and, indirectly, the class to which the window belongs.
		/// 	nIndex 		Specifies the zero-based byte offset of the value to be retrieved. Valid values are in the range zero through
		/// 			the number of bytes of extra window memory, minus two; for example, if you specified 10 or more bytes
		/// 			of extra window memory, a value of 8 would be an index to the fifth 16-bit integer.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the requested 16-bit value.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASS structure used with the RegisterClass function.
		/// The GWW_ values are obsolete in Win32. You must use the GetWindowLong function to retrieve information about the window.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetWindowWord(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.GetWindowWord(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The HiliteMenuItem function highlights or removes the highlighting from an item in a menu bar.
		/// 
		/// Parameters:
		/// 	hwnd 		Identifies the window that contains the menu.
		/// 	hmenu 		Identifies the menu bar that contains the item to be highlighted.
		/// 	uItemHilite 	Specifies the menu item to be highlighted. This parameter is either the identifier of the menu item or the offset of the menu item in the menu bar, depending on the value of the uHilite parameter.
		/// 	uHilite 		Specifies flags that control the interpretation of the uItemHilite parameter and indicates whether the menu item is highlighted.
		/// 			This parameter must be a combination of either MF_BYCOMMAND or MF_BYPOSITION and MF_HILITE or MF_UNHILITE.
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that uItemHilite gives the identifier of the menu item.
		/// 			MF_BYPOSITION 		Indicates that uItemHilite gives the zero-based relative position of the menu item.
		/// 			MF_HILITE 		Highlights the menu item. If this flag is not specified, the highlighting is removed from the item.
		/// 			MF_UNHILITE 		Removes highlighting from the menu item.
		/// 
		/// Return Values:
		/// 	If the menu item is set to the specified highlight state, the return value is nonzero.
		/// 	If the menu item is not set to the specified highlight state, the return value is zero.
		/// 
		/// Remarks:
		/// The MF_HILITE and MF_UNHILITE flags can be used only with the HiliteMenuItem function; they cannot be used with the ModifyMenu function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean HiliteMenuItem(SalWindowHandle param1, SalWindowHandle param2, SalNumber param3, SalNumber param4)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;
			ushort _param3 = (ushort)param3;
			ushort _param4 = (ushort)param4;


			retVal = USER32.HiliteMenuItem(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The IsIconic function determines whether the specified window is minimized (iconic).
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window.
		/// 
		/// Return Values:
		/// 	If the window is iconic, the return value is nonzero.
		/// 	If the window is not iconic, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean IsIconic(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.IsIconic(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The IsWindow function determines whether the specified window handle identifies an existing window.
		/// 
		/// Parameters:
		/// 	hWnd 		Specifies the window handle.
		/// 
		/// Return Values:
		/// 	If the window handle identifies an existing window, the return value is nonzero.
		/// 	If the window handle does not identify an existing window, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean IsWindow(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.IsWindow(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The IsWindowEnabled function determines whether the specified window is enabled for mouse and keyboard input.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window to test.
		/// 
		/// Return Values:
		/// 	If the window is enabled, the return value is nonzero.
		/// 	If the window is not enabled, the return value is zero.
		/// 
		/// Remarks:
		/// A child window receives input only if it is both enabled and visible.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean IsWindowEnabled(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.IsWindowEnabled(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The InsertMenu function inserts a new menu item into a menu, moving other items down the menu.
		/// 
		/// The InsertMenu function has been superseded by the InsertMenuItem function.
		/// You can still use InsertMenu, however, if you do not need any of the extended features of InsertMenuItem.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu to be changed.
		/// 	uPosition 		Specifies the menu item before which the new menu item is to be inserted, as determined by the uFlags parameter.
		/// 	uFlags 		Specifies flags that control the interpretation of the uPosition parameter and the content, appearance, and behavior of the new menu item.
		/// 			This parameter must be a combination of one of the following required values and at least one of the values listed in the following Remarks section.
		/// 			Value 			Description
		/// 			MF_BYCOMMAND 		Indicates that the uPosition parameter gives the identifier of the menu item.
		/// 						The MF_BYCOMMAND flag is the default if neither the MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
		/// 			MF_BYPOSITION 		Indicates that the uPosition parameter gives the zero-based relative position of the new menu item. If uPosition is 0xFFFFFFFF,
		/// 						the new menu item is appended to the end of the menu.
		///  	uIDNewItem 	Specifies either the identifier of the new menu item or, if the uFlags parameter has the MF_POPUP flag set, the handle of the drop-down menu or submenu.
		/// 	lpNewItem 	Specifies the content of the new menu item. The interpretation of lpNewItem depends on whether the uFlags parameter includes the MF_BITMAP, MF_OWNERDRAW,
		/// 			or MF_STRING flag, as follows:
		/// 			Value 			Description
		/// 			MF_BITMAP 		Contains a bitmap handle.
		/// 			MF_OWNERDRAW 	Contains a 32-bit value supplied by the application that can be used to maintain additional data related to the menu item.
		/// 						The value is in the itemData member of the structure pointed to by the lparam parameter of the WM_MEASUREITEM or
		/// 						WM_DRAWITEM message sent when the menu item is created or its appearance is updated.
		/// 			MF_STRING 		Contains a pointer to a null-terminated string (the default).
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The application must call the DrawMenuBar function whenever a menu changes, whether or not the menu is in a displayed window.
		/// 
		/// The following list describes the flags that can be set in the uFlags parameter:
		/// Value 			Description
		/// MF_BITMAP 		Uses a bitmap as the menu item. The lpNewItem parameter contains the handle of the bitmap.
		/// MF_CHECKED 		Places a check mark next to the menu item. If the application provides check mark bitmaps (see SetMenuItemBitmaps), this flag displays the check mark bitmap next to the menu item.
		/// MF_DISABLED 		Disables the menu item so that it cannot be selected, but does not gray it.
		/// MF_ENABLED 		Enables the menu item so that it can be selected and restores it from its grayed state.
		/// MF_GRAYED 		Disables the menu item and grays it so it cannot be selected.
		/// MF_MENUBARBREAK 	Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is separated from the old column by a vertical line.
		/// MF_MENUBREAK 		Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without separating columns.
		/// MF_OWNERDRAW 	Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu receives a WM_MEASUREITEM
		/// 			message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the window procedure of the owner window whenever the appearance of the menu item must be updated.
		/// MF_POPUP 		Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies the handle of the drop-down menu or submenu.
		/// 			This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down menu, submenu, or shortcut menu.
		/// MF_SEPARATOR 		Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
		/// MF_STRING 		Specifies that the menu item is a text string; the lpNewItem parameter points to the string.
		/// MF_UNCHECKED 		Does not place a check mark next to the menu item (default). If the application supplies check mark bitmaps (see the SetMenuItemBitmaps function), this flag displays the unchecked bitmap next to the menu item.
		/// 
		/// The following groups of flags cannot be used together:
		/// 
		/// · MF_BYCOMMAND and MF_BYPOSITION
		/// · MF_DISABLED, MF_ENABLED, and MF_GRAYED
		/// · MF_BITMAP, MF_STRING, MF_OWNERDRAW, and MF_SEPARATOR
		/// · MF_MENUBARBREAK and MF_MENUBREAK
		/// · MF_CHECKED and MF_UNCHECKED
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean InsertMenuA(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalString param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;
			ushort _param4 = (ushort)param4;
			string _param5 = param5.Value;


			retVal = USER32.InsertMenuA(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber LoadCursorA(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;


			retVal = USER32.LoadCursorA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalWindowHandle LoadCursorFromFileA(SalString param1)
		{
			SalWindowHandle retVal = 0;
			string _param1 = param1.Value;


			retVal = USER32.LoadCursorFromFileA(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The LoadIcon function loads the specified icon resource from the executable (.EXE) file associated with an application instance.
		/// 
		/// Parameters:
		/// 	hInstance 		Identifies an instance of the module whose executable file contains the icon to be loaded. This parameter must be NULL when a standard icon is being loaded.
		/// 	lpIconName 		Points to a null-terminated string that contains the name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier
		/// 				in the low-order word and zero in the high-order word. Use the MAKEINTRESOURCE macro to create this value.
		/// 				To use one of the Windows predefined icons, set the hInstance parameter to NULL and the lpIconName parameter to one of the following values:
		/// 				Value 			Description
		/// 				IDI_APPLICATION 		Default application icon.
		/// 				IDI_ASTERISK 		Asterisk (used in informative messages).
		/// 				IDI_EXCLAMATION 	Exclamation point (used in warning messages).
		/// 				IDI_HAND 		Hand-shaped icon (used in serious warning messages).
		/// 				IDI_QUESTION 		Question mark (used in prompting messages).
		/// 				IDI_WINLOGO 		Windows logo.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the newly loaded icon.
		/// 	If the function fails, the return value is NULL. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// LoadIcon loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource.
		/// The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap.
		/// 
		/// LoadIcon can only load an icon whose size conforms to the SM_CXICON and SM_CYICON system metric values. Use the LoadImage function to load icons of other sizes.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber LoadIconA(SalNumber param1, SalString param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			string _param2 = param2.Value;


			retVal = USER32.LoadIconA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The LoadImage function loads an icon, cursor, or bitmap.
		/// 
		/// Parameters:
		/// 	hinst 		Handle to an instance of the module that contains the image to be loaded.
		/// 			To load an OEM image, set this parameter to zero.
		/// 	lpszName 	Handle to the image to load. If the hinst parameter is non-NULL and the fuLoad
		/// 			parameter does not include LR_LOADFROMFILE, lpszName is a pointer to a
		/// 			null-terminated string that contains the name of the image resource in the hinst module.
		/// 
		/// 			If hinst is NULL and LR_LOADFROMFILE is not specified, the low-order word of this
		/// 			parameter must be the identifier of the OEM image to load. The OEM image identifiers
		/// 			are defined in WINUSER.H and have the following prefixes:
		/// 			Prefix 		Meaning
		/// 			OBM_ OEM 	bitmaps
		/// 			OIC_ OEM 	icons
		/// 			OCR_ OEM 	cursors
		/// 
		/// 			If the fuLoad parameter includes the LR_LOADFROMFILE value, lpszName is the name
		/// 			of the file that contains the image.
		/// 
		/// 	uType 		Specifies the type of image to be loaded. This parameter can be one of the following values:
		/// 			Value 		Meaning
		/// 			IMAGE_BITMAP 	Loads a bitmap.
		/// 			IMAGE_CURSOR 	Loads a cursor.
		/// 			IMAGE_ICON 	Loads an icon.
		/// 
		/// 	cxDesired 	Specifies the width, in pixels, of the icon or cursor. If this parameter is zero and the
		/// 			fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or
		/// 			SM_CXCURSOR system metric value to set the width. If this parameter is zero and
		/// 			LR_DEFAULTSIZE is not used, the function uses the actual resource width.
		/// 	cyDesired 	Specifies the height, in pixels, of the icon or cursor. If this parameter is zero and the
		/// 			fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or
		/// 			SM_CYCURSOR system metric value to set the height. If this parameter is zero and
		/// 			LR_DEFAULTSIZE is not used, the function uses the actual resource height.
		/// 	fuLoad 		Specifies a combination of the following values:
		/// 			Value 			Meaning
		/// 			LR_DEFAULTCOLOR 	The default flag; it does nothing. All it means is "not LR_MONOCHROME".
		/// 			LR_CREATEDIBSECTION 	When the uType parameter specifies IMAGE_BITMAP, causes the function
		/// 						to return a DIB section bitmap rather than a compatible bitmap.
		/// 						This flag is useful for loading a bitmap without mapping it to the colors of the display device.
		/// 			LR_DEFAULTSIZE 		Uses the width or height specified by the system metric values for cursors or icons,
		/// 						if the cxDesired or cyDesired values are set to zero. If this flag is not specified and
		/// 						cxDesired and cyDesired are set to zero, the function uses the actual resource size.
		/// 						If the resource contains multiple images, the function uses the size of the first image.
		/// 			LR_LOADFROMFILE 	Loads the image from the file specified by the lpszName parameter.
		/// 						If this flag is not specified, lpszName is the name of the resource.
		/// 			LR_LOADMAP3DCOLORS 	Searches the color table for the image and replaces the following
		/// 						shades of gray with the corresponding 3D color:
		/// 	 					Color 				Replaced with
		/// 						Dk Gray, RGB(128,128,128) 		COLOR_3DSHADOW
		/// 						Gray, RGB(192,192,192) 		COLOR_3DFACE
		/// 						Lt Gray, RGB(223,223,223) 		COLOR_3DLIGHT
		/// 			LR_LOADTRANSPARENT 	Retrieves the color value of the first pixel in the image and replaces the
		/// 						corresponding entry in the color table with the default window color (COLOR_WINDOW).
		/// 						All pixels in the image that use that entry become the default window color.
		/// 						This value applies only to images that have corresponding color tables.
		/// 						If fuLoad includes both the LR_LOADTRANSPARENT and LR_LOADMAP3DCOLORS values,
		/// 						LRLOADTRANSPARENT takes precedence. However, the color table entry is replaced with
		/// 						COLOR_3DFACE rather than COLOR_WINDOW.
		/// 			LR_MONOCHROME 		Loads the image in black and white.
		/// 			LR_SHARED 		Shares the image handle if the image is loaded multiple times. If LR_SHARED is not set,
		/// 						a second call to LoadImage for the same resource will load the image again and return a different handle.
		/// 						Do not use LR_SHARED for images that have non-standard sizes, that may change after loading,
		/// 						or that are loaded from a file.
		/// 						Windows 95 and Windows 98: The function finds the first image with the requested resource name
		/// 						in the cache, regardless of the size requested.
		/// 			LR_VGACOLOR 		Uses true VGA colors.
		/// 
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the newly loaded image.
		/// 	If the function fails, the return value is NULL. To get extended error information, callGetLastError.
		/// 
		/// Remarks:
		/// When you are finished using the bitmap, cursor, or icon, you can release its associated memory by calling one of the functions in the following table.
		/// 
		/// Resource 	Release function
		/// Bitmap 		DeleteObject
		/// Cursor 		DestroyCursor
		/// Icon 		DestroyIcon
		/// 
		/// The system automatically deletes these resources when the process that created them terminates, however, calling the appropriate function
		/// saves memory and decreases the size of the process's working set.
		/// 
		/// Windows CE: The cxDesired and cyDesired parameters must be zero for IMAGE_BITMAP.
		/// Windows CE does not support stretching and shrinking of icons.
		/// 
		/// The fuLoad parameter must be zero (==LR_DEFAULTCOLOR).
		/// 
		/// If you are targeting a platform that does not support mouse cursors, you cannot specify the SM_CXCURSOR and SM_CYCURSOR values
		/// in the cxDesired and cyDesired parameters, and you cannot specify IMAGE_CURSOR for the uType parameter.
		/// 
		/// If you are targeting a platform that supports mouse cursors, you can specify SM_CXCURSOR and SM_CYCURSOR in the cxDesired and
		/// cyDesired parameters, and IMAGE_CURSOR in the uType parameter.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalNumber LoadImageA(SalNumber param1, SalString param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			string _param2 = param2.Value;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			uint _param6 = (uint)param6;


			retVal = USER32.LoadImageA(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// The ModifyMenu function changes an existing menu item. This function is used to specify the content, appearance, and behavior of the menu item.
		/// The ModifyMenu function has been superseded by the SetMenuItemInfo function. You can still use ModifyMenu, however,
		/// if you do not need any of the extended features of SetMenuItemInfo.
		/// 
		/// Parameters:
		/// 	hMnu 		Identifies the menu to be changed.
		/// 	uPosition 		Specifies the menu item to be changed, as determined by the uFlags parameter.
		/// 	uFlags 		Specifies flags that control the interpretation of the uPosition parameter and the content, appearance,
		/// 			and behavior of the menu item. This parameter must be a combination of one of the following required values and
		/// 			at least one of the values listed in the following Remarks section.
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that the uPosition parameter gives the identifier of the menu item.
		/// 						The MF_BYCOMMAND flag is the default if neither the MF_BYCOMMAND nor
		/// 						MF_BYPOSITION flag is specified.
		/// 			MF_BYPOSITION 		Indicates that the uPosition parameter gives the zero-based relative position of the menu item.
		/// 	uIDNewItem 	Specifies either the identifier of the modified menu item or, if the uFlags parameter has the MF_POPUP flag set,
		/// 			the handle of the drop-down menu or submenu.
		/// 	lpNewItem 	Points to the content of the changed menu item. The interpretation of this parameter depends on whether the
		/// 			uFlags parameter includes the MF_BITMAP, MF_OWNERDRAW, or MF_STRING flag.
		/// 			Value 			Meaning
		/// 			MF_BITMAP 		Contains a bitmap handle.
		/// 			MF_OWNERDRAW 	Contains a 32-bit value supplied by an application that is used to maintain additional
		/// 						data related to the menu item. The value is in the itemData member of the structure
		/// 						pointed to by the lparam parameter of the WM_MEASUREITEM or WM_DRAWITEM
		/// 						messages sent when the menu item is created or its appearance is updated.
		/// 			MF_STRING 		Contains a pointer to a null-terminated string (the default).
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean ModifyMenuA(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalString param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			string _param5 = param5.Value;


			retVal = USER32.ModifyMenuA(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// Function: MoveWindow
		/// Description: The MoveWindow function changes the position and dimensions of the specified window.
		/// For a top-level window, the position and dimensions are relative to the upper-left corner of the screen.
		/// For a child window, they are relative to the upper-left corner of the parent window’s client area.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window.
		/// 	X 		Specifies the new position of the left side of the window.
		/// 	Y 		Specifies the new position of the top of the window.
		/// 	nWidth 		Specifies the new width of the window.
		/// 	nHeight 		Specifies the new height of the window.
		/// 	bRepaint 		Specifies whether the window is to be repainted. If this parameter is TRUE, the window receives a WM_PAINT message. If the parameter is FALSE, no repainting of any kind occurs.
		/// 			This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window.
		/// 			If this parameter is FALSE, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// If the bRepaint parameter is TRUE, Windows sends the WM_PAINT message to the window procedure immediately after moving the window (that is, the MoveWindow function calls the UpdateWindow function).
		/// If bRepaint is FALSE, Windows places the WM_PAINT message in the message queue associated with the window.
		/// The message loop dispatches the WM_PAINT message only after dispatching all other messages in the queue.
		/// Export Ordinal: 0
		/// Returns
		/// Parameters
		/// Window Handle: HWND
		/// Number: INT
		/// Number: INT
		/// Number: INT
		/// Number: INT
		/// Number: BYTE
		/// Function: OemToCharA
		/// Description: The OemToChar function translates a string from the OEM-defined character set into either an ANSI or a wide-character string.
		/// (OEM stands for original equipment manufacturer.) This function supersedes the OemToAnsi function.
		/// 
		/// Parameters:
		/// 	lpszSrc 		Points to a null-terminated string of characters from the OEM-defined character set.
		/// 	lpszDst 		Points to the buffer for the translated string. If the OemToChar function is being used as an ANSI function, the string can be translated in place
		/// 			by setting the lpszDst parameter to the same address as the lpszSrc parameter. This cannot be done if OemToChar is being used as a wide-character function.
		/// 
		/// Return Values:
		/// 	The return value is always nonzero.
		/// Export Ordinal: 0
		/// Returns
		/// Parameters
		/// String: LPSTR
		/// Receive String: LPSTR
		/// The OpenClipboard function opens the clipboard for examination and prevents other applications from modifying the clipboard content.
		/// 
		/// Parameters:
		/// 	hWndNewOwner 		Identifies the window to be associated with the open clipboard. If this parameter is NULL,
		/// 				the open clipboard is associated with the current task.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks
		/// OpenClipboard fails if another window has the clipboard open.
		/// An application should call the CloseClipboard function after every successful call to OpenClipboard.
		/// The window identified by the hWndNewOwner parameter does not become the clipboard owner unless the EmptyClipboard function is called.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean OpenClipboard(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.OpenClipboard(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean PeekMessageA(ref SalString param1, SalWindowHandle param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);
			System.IntPtr _param2 = (System.IntPtr)param2;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;
			uint _param5 = (uint)param5;


			retVal = USER32.PeekMessageA(_param1, _param2, _param3, _param4, _param5);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The RedrawWindow function updates the specified rectangle or region in a window's client area.
		/// 
		/// Parameters:
		/// hWnd 		Handle to the window to be redrawn. If this parameter is NULL, the desktop window is updated.
		/// lprcUpdate 	Pointer to a RECT structure containing the coordinates of the update rectangle.
		/// 		This parameter is ignored if the hrgnUpdate parameter identifies a region.
		/// hrgnUpdate 	Handle to the update region. If both the hrgnUpdate and lprcUpdate parameters are NULL,
		/// 		the entire client area is added to the update region.
		/// flags 		Specifies one or more redraw flags. This parameter can be a combination of flags that invalidate
		/// 		or validate a window, control repainting, and control which windows are affected by RedrawWindow.
		/// 		The following flags are used to invalidate the window:
		/// 		Flag (invalidation) 		Description
		/// 		RDW_ERASE 		Causes the window to receive a WM_ERASEBKGND message when the
		/// 					window is repainted. The RDW_INVALIDATE flag must also be specified;
		/// 					otherwise, RDW_ERASE has no effect.
		/// 		RDW_FRAME 		Causes any part of the nonclient area of the window that intersects the update
		/// 					region to receive a WM_NCPAINT message. The RDW_INVALIDATE flag must
		/// 					also be specified; otherwise, RDW_FRAME has no effect. The WM_NCPAINT
		/// 					message is typically not sent during the execution of RedrawWindow unless either
		/// 					RDW_UPDATENOW or RDW_ERASENOW is specified.
		/// 		RDW_INTERNALPAINT 	Causes a WM_PAINT message to be posted to the window regardless of whether
		/// 					any portion of the window is invalid.
		/// 		RDW_INVALIDATE 	Invalidates lprcUpdate or hrgnUpdate (only one may be non-NULL). If both are NULL,
		/// 					the entire window is invalidated.
		/// 
		/// 		The following flags are used to validate the window:
		/// 		Flag (validation) 		Description
		/// 		RDW_NOERASE 		Suppresses any pending WM_ERASEBKGND messages.
		/// 		RDW_NOFRAME 		Suppresses any pending WM_NCPAINT messages. This flag must be used with
		/// 					RDW_VALIDATE and is typically used with RDW_NOCHILDREN. RDW_NOFRAME
		/// 					should be used with care, as it could cause parts of a window to be painted improperly.
		/// 		RDW_NOINTERNALPAINT 	Suppresses any pending internal WM_PAINT messages. This flag does not affect
		/// 					WM_PAINT messages resulting from a non-NULL update area.
		/// 		RDW_VALIDATE 		Validates lprcUpdate or hrgnUpdate (only one may be non-NULL). If both are NULL,
		/// 					the entire window is validated. This flag does not affect internal WM_PAINT messages.
		/// 
		/// 		The following flags control when repainting occurs. RedrawWindow will not repaint unless one of these flags is specified.
		/// 		Flag 			Description
		/// 		RDW_ERASENOW 	Causes the affected windows (as specified by the RDW_ALLCHILDREN and
		/// 					RDW_NOCHILDREN flags) to receive WM_NCPAINT and WM_ERASEBKGND messages,
		/// 					if necessary, before the function returns. WM_PAINT messages are received at the ordinary
		/// 					time.
		/// 		RDW_UPDATENOW 	Causes the affected windows (as specified by the RDW_ALLCHILDREN and
		/// 					RDW_NOCHILDREN flags) to receive WM_NCPAINT, WM_ERASEBKGND,
		/// 					and WM_PAINT messages, if necessary, before the function returns.
		/// 
		/// 		By default, the windows affected by RedrawWindow depend on whether the given window has the WS_CLIPCHILDREN style.
		/// 		Child windows that are not the WS_CLIPCHILDREN style are unaffected; non-WS_CLIPCHILDREN windows are
		/// 		recursively validated or invalidated until a WS_CLIPCHILDREN window is encountered.
		/// 		The following flags control which windows are affected by the RedrawWindow function:
		/// 		Flag 			Description
		/// 		RDW_ALLCHILDREN 	Includes child windows, if any, in the repainting operation.
		/// 		RDW_NOCHILDREN 	Excludes child windows, if any, from the repainting operation.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is nonzero.
		/// If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// When RedrawWindow is used to invalidate part of the desktop window, the desktop window does not receive a WM_PAINT message.
		/// To repaint the desktop, an application uses the RDW_ERASE flag to generate a WM_ERASEBKGND message.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean RedrawWindow(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param6 = (int)param6;
			ushort _param7 = (ushort)param7;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			retVal = USER32.RedrawWindow(_param1, ref _struct1, _param6, _param7);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean RegisterHotKey(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;


			retVal = USER32.RegisterHotKey(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The ReleaseCapture function releases the mouse capture from a window in the current thread and restores normal mouse input processing.
		/// A window that has captured the mouse receives all mouse input, regardless of the position of the cursor,
		/// except when a mouse button is clicked while the cursor hot spot is in the window of another thread.
		/// 
		/// Parameters:
		/// 	This function has no parameters.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// An application calls this function after calling the SetCapture function.
		/// 
		/// Windows 95: Calling this function causes the window that is losing the mouse capture to receive a WM_CAPTURECHANGED message.
		/// </summary>
		/// <returns></returns>
		public static SalBoolean ReleaseCapture()
		{
			SalBoolean retVal = false;


			retVal = USER32.ReleaseCapture();

			return retVal;
		}
		
		/// <summary>
		/// The ReleaseDC function releases a device context (DC), freeing it for use by other applications.
		/// The effect of the ReleaseDC function depends on the type of device context. It frees only common and window device contexts.
		/// It has no effect on class or private device contexts.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose device context is to be released.
		/// 	hDC 		Identifies the device context to be released.
		/// 
		/// Return Values:
		/// 	The return value specifies whether the device context is released. If the device context is released, the return value is 1.
		/// 	If the device context is not released, the return value is zero.
		/// 
		/// Remarks:
		/// The application must call the ReleaseDC function for each call to the GetWindowDC function and for each call to the GetDC function that retrieves a common device context.
		/// 
		/// An application cannot use the ReleaseDC function to release a device context that was created by calling the CreateDC function; instead, it must use the DeleteDC function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber ReleaseDC(SalWindowHandle param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;


			retVal = USER32.ReleaseDC(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The RemoveMenu function deletes a menu item from the specified menu. If the menu item opens a drop-down menu or submenu,
		/// RemoveMenu does not destroy the menu or its handle, allowing the menu to be reused.
		/// Before this function is called, the GetSubMenu function should retrieve the handle of the drop-down menu or submenu.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu to be changed.
		/// 	uPosition 		Specifies the menu item to be deleted, as determined by the uFlags parameter.
		/// 	uFlags 		Specifies how the uPosition parameter is interpreted. This parameter must be one of the following values:
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that uPosition gives the identifier of the menu item. If neither the MF_BYCOMMAND nor MF_BYPOSITION flag is specified, the MF_BYCOMMAND flag is the default flag.
		/// 			MF_BYPOSITION 		Indicates that uPosition gives the zero-based relative position of the menu item.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The application must call the DrawMenuBar function whenever a menu changes, whether or not the menu is in a displayed window.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalBoolean RemoveMenu(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			ushort _param2 = (ushort)param2;
			ushort _param3 = (ushort)param3;


			retVal = USER32.RemoveMenu(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// The ScreenToClient function converts the screen coordinates of a specified point on the screen to client coordinates.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose client area will be used for the conversion.
		/// 	lpPoint 		Points to a POINT structure that contains the screen coordinates to be converted.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The function uses the window identified by the hWnd parameter and the screen coordinates given in the POINT structure to compute client coordinates.
		/// It then replaces the screen coordinates with the client coordinates. The new coordinates are relative to the upper-left corner of the specified window’s client area.
		/// 
		/// The ScreenToClient function assumes the specified point is in screen coordinates.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean ScreenToClient(SalWindowHandle param1, ref SalNumber param2, ref SalNumber param3)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;

			Structures.STRUCT_8 _struct1 = new Structures.STRUCT_8();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;

			retVal = USER32.ScreenToClient(_param1, ref _struct1);

			param2 = (SalNumber)_struct1.Member1;
			param3 = (SalNumber)_struct1.Member2;
			return retVal;
		}
		
		/// <summary>
		/// The ShowScrollBar function shows or hides the specified scroll bar.
		/// 
		/// Parameters:
		/// hWnd 		Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the wBar parameter.
		/// wBar 		Specifies the scroll bar(s) to be shown or hidden. This parameter can be one of the following values:
		/// 		Value Meaning
		/// 		SB_BOTH 	Shows or hides a window's standard horizontal and vertical scroll bars.
		/// 		SB_CTL 		Shows or hides a scroll bar control. The hWnd parameter must be
		/// 				the handle to the scroll bar control.
		/// 		SB_HORZ 	Shows or hides a window's standard horizontal scroll bars.
		/// 		SB_VERT 	Shows or hides a window's standard vertical scroll bar.
		/// bShow 		Specifies whether the scroll bar is shown or hidden. If this parameter is TRUE, the scroll bar is shown;
		/// 		otherwise, it is hidden.
		/// Return Values:
		/// If the function succeeds, the return value is nonzero.
		/// If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// You should not call this function to hide a scroll bar while processing a scroll bar message.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber ShowScrollBar(SalWindowHandle param1, SalNumber param2, SalBoolean param3)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			bool _param3 = (bool)param3;


			USER32.ShowScrollBar(_param1, _param2, _param3);

			return 0;
		}
		
		/// <summary>
		/// Retrieve a string pointer in lParam
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalNumber SendMessageTimeoutA(SalWindowHandle param1, SalNumber param2, SalNumber param3, ref SalString param4, SalNumber param5, SalNumber param6, ref SalNumber param7)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;
			int _param3 = (int)param3;
			System.Text.StringBuilder _param4 = new System.Text.StringBuilder(param4.Value);
			uint _param5 = (uint)param5;
			uint _param6 = (uint)param6;
			int _param7 = (int)param7;


			retVal = USER32.SendMessageTimeoutA(_param1, _param2, _param3, _param4, _param5, _param6, ref _param7);

			param4 = _param4.ToString();
			param7 = _param7;
			return retVal;
		}
		
		/// <summary>
		/// The SetActiveWindow function activates a window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the top-level window to be activated.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the window that was previously active.
		/// 
		/// Remarks:
		/// The SetActiveWindow function activates a window, but not if the application is in the background.
		/// The window will be brought into the foreground (top of Z order) if the application is in the foreground when it sets the activation.
		/// 
		/// If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd.
		/// Otherwise, the active window status of the calling thread is set to NULL.
		/// 
		/// The SetForegroundWindow window function, on the other hand, activates a window and forces it into the foreground.
		/// An application should only call SetForegroundWindow if it needs to display critical errors or information that needs the user’s immediate attention.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalWindowHandle SetActiveWindow(SalWindowHandle param1)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.SetActiveWindow(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The SetCapture function sets the mouse capture to the specified window belonging to the current thread.
		/// Once a window has captured the mouse, all mouse input is directed to that window, regardless of whether the cursor is within the borders of that window.
		/// Only one window at a time can capture the mouse.
		/// 
		/// If the mouse cursor is over a window created by another thread, the system will direct mouse input to the specified window only if a mouse button is down.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window in the current thread that is to capture the mouse.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the window that had previously captured the mouse.
		/// 	If there is no such window, the return value is NULL.
		/// 
		/// Remarks:
		/// Only the foreground window can capture the mouse. When a background window attempts to do so, the window receives messages
		/// only for mouse events that occur when the cursor hot spot is within the visible portion of the window.
		/// Also, even if the foreground window has captured the mouse, the user can still click another window, bringing it to the foreground.
		/// 
		/// When the window no longer requires all mouse input, the thread that created the window should call the ReleaseCapture function to release the mouse.
		/// 
		/// This function cannot be used to capture mouse input meant for another process.
		/// 
		/// Windows 95: Calling this function causes the window that is losing the mouse capture to receive a WM_CAPTURECHANGED message.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalWindowHandle SetCapture(SalWindowHandle param1)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.SetCapture(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The SetClipboardData function places data on the clipboard in a specified clipboard format. The window must be the current clipboard owner,
		/// and the application must have called the OpenClipboard function. (When responding to the WM_RENDERFORMAT and
		/// WM_RENDERALLFORMATS messages, the clipboard owner must not call OpenClipboard before calling SetClipboardData.)
		/// 
		/// Parameters:
		/// 	uFormat 		Specifies a clipboard format. This parameter can be a registered format or any of the standard clipboard formats
		/// 			listed in the following Remarks section. For information about registered clipboard formats,
		/// 			see the RegisterClipboardFormat function.
		/// 	hMem 		Identifies the data in the specified format. This parameter can be NULL, indicating that the window provides data
		/// 			in the specified clipboard format (renders the format) upon request. If a window delays rendering,
		/// 			it must process the WM_RENDERFORMAT and WM_RENDERALLFORMATS messages.
		/// 
		/// 	Once SetClipboardData is called, the system owns the object identified by the hMem parameter. The application can read the data,
		/// 	but must not free the handle or leave it locked. If the hMem parameter identifies a memory object, the object must have been allocated
		/// 	using the GlobalAlloc function with the GMEM_MOVEABLE and GMEM_DDESHARE flags.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the data.
		/// 	If the function fails, the return value is NULL. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The uFormat parameter can identify a registered clipboard format, or it can be one of the following values:
		/// Value 			Meaning
		/// CF_BITMAP 		A handle to a bitmap (HBITMAP).
		/// CF_DIB 			A memory object containing a BITMAPINFO structure followed by the bitmap bits.
		/// CF_DIF 			Software Arts’ Data Interchange Format.
		/// CF_DSPBITMAP 		Bitmap display format associated with a private format. The hMem parameter must be a handle of data that can be
		/// 			displayed in bitmap format in lieu of the privately formatted data.
		/// CF_DSPENHMETAFILE 	Enhanced metafile display format associated with a private format. The hMem parameter must be a handle of data
		/// 			that can be displayed in enhanced metafile format in lieu of the privately formatted data.
		/// CF_DSPMETAFILEPICT 	Metafile-picture display format associated with a private format. The hMem parameter must be a handle of data
		/// 			that can be displayed in metafile-picture format in lieu of the privately formatted data.
		/// CF_DSPTEXT 		Text display format associated with a private format. The hMem parameter must be a handle of data that can be
		/// 			displayed in text format in lieu of the privately formatted data.
		/// CF_ENHMETAFILE 	A handle of an enhanced metafile (HENHMETAFILE).
		/// CF_GDIOBJFIRST through  	Range of integer values for application-defined GDI object clipboard formats. Handles associated with clipboard
		/// CF_GDIOBJLAST		formats in this range are not automatically deleted using the GlobalFree function when the
		/// 			clipboard is emptied. Also, when using values in this range, the hMem parameter is not a handle to a GDI object,
		/// 			but is a handle allocated by the GlobalAlloc function with the GMEM_DDESHARE and GMEM_MOVEABLE flags.
		/// CF_HDROP 		A handle of type HDROP that identifies a list of files. An application can retrieve information about the files by
		/// 			passing the handle to the DragQueryFile functions.
		/// CF_LOCALE 		The data is a handle to the locale identifier associated with text in the clipboard. When you close the clipboard,
		/// 			if it contains CF_TEXT data but no CF_LOCALE data, the system automatically sets the CF_LOCALE format to the
		/// 			current input locale. You can use the CF_LOCALE format to associate a different locale with the clipboard text.
		/// 
		/// 			An application that pastes text from the clipboard can retrieve this format to determine which character set was
		/// 			used to generate the text.
		/// 
		/// 			Note that the clipboard does not support plain text in multiple character sets. To achieve this, use a fomatted text
		/// 			data type such as RTF instead.
		/// 
		/// 			Windows NT: The system uses the code page associated with CF_LOCALE to implicitly convert from CF_TEXT
		/// 			to CF_UNICODETEXT. Therefore, the correct code page table is used for the conversion.
		/// CF_METAFILEPICT 	Handle of a metafile picture format as defined by the METAFILEPICT structure. When passing a
		/// 			CF_METAFILEPICT handle by means of dynamic data exchange (DDE), the application responsible for deleting
		/// 			hMem should also free the metafile referred to by the CF_METAFILEPICT handle.
		/// CF_OEMTEXT 		Text format containing characters in the OEM character set. Each line ends with a carriage return/linefeed (CR-LF)
		/// 			combination. A null character signals the end of the data.
		/// CF_OWNERDISPLAY 	Owner-display format. The clipboard owner must display and update the clipboard viewer window, and receive the
		/// 			WM_ASKCBFORMATNAME, WM_HSCROLLCLIPBOARD, WM_PAINTCLIPBOARD, WM_SIZECLIPBOARD, and
		/// 			WM_VSCROLLCLIPBOARD messages. The hMem parameter must be NULL.
		/// CF_PALETTE 		Handle of a color palette. Whenever an application places data in the clipboard that depends on or assumes a
		/// 			color palette, it should place the palette on the clipboard as well.
		/// 
		/// 			If the clipboard contains data in the CF_PALETTE (logical color palette) format, the application should use the
		/// 			SelectPalette and RealizePalette functions to realize (compare) any other data in the clipboard against that logical palette.
		/// 
		/// 			When displaying clipboard data, Windows clipboard always uses as its current palette any object on the clipboard
		/// 			that is in the CF_PALETTE format.
		/// CF_PENDATA 		Data for the pen extensions to the Microsoft Windows for Pen Computing.
		/// CF_PRIVATEFIRST through	Range of integer values for private clipboard formats. Handles associated with private clipboard formats are not
		/// CF_PRIVATELAST 		freed automatically; the clipboard owner must free such handles, typically in response to the
		/// 			WM_DESTROYCLIPBOARD message.
		/// CF_RIFF 			Represents audio data more complex than can be represented in a CF_WAVE standard wave format.
		/// CF_SYLK			Microsoft Symbolic Link (SYLK) format.
		/// CF_TEXT 		Text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the
		/// 			end of the data. Use this format for ANSI text.
		/// CF_WAVE 		Represents audio data in one of the standard wave formats, such as 11 kHz or 22 kHz pulse code modulation (PCM).
		/// CF_TIFF 			Tagged-image file format.
		/// CF_UNICODETEXT 	Windows NT only: Unicode text format. Each line ends with a carriage return/linefeed (CR-LF) combination.
		/// 			A null character signals the end of the data.
		/// 
		/// The operating system performs implicit data format conversions between certain clipboard formats when an application calls the GetClipboardData
		/// function. For example, if the CF_OEMTEXT format is on the clipboard, a window can retrieve data in the CF_TEXT format.
		/// The format on the clipboard is converted to the requested format on demand. The following table shows the clipboard data type conversions
		/// that are available. Note that some of these automatic type conversions are not available on all platforms.
		/// Clipboard Format 		Conversion Format 		Platform Support
		/// CF_BITMAP 		CF_DIB 			Windows NT, Windows 95
		/// CF_DIB 			CF_BITMAP 		Windows NT, Windows 95
		/// CF_DIB 			CF_PALETTE 		Windows NT, Windows 95
		/// CF_ENHMETAFILE 	CF_METAFILEPICT 	Windows NT, Windows 95
		/// CF_METAFILEPICT 	CF_ENHMETAFILE 	Windows NT, Windows 95
		/// CF_OEMTEXT 		CF_TEXT 		Windows NT, Windows 95
		/// CF_OEMTEXT 		CF_UNICODETEXT 	Windows NT
		/// CF_TEXT 		CF_OEMTEXT 		Windows NT, Windows 95
		/// CF_TEXT 		CF_UNICODETEXT 	Windows NT
		/// CF_UNICODETEXT 	CF_OEMTEXT 		Windows NT
		/// CF_UNICODETEXT 	CF_TEXT 		Windows NT
		/// 
		/// If the operating system provides an automatic type conversion for a particular clipboard format, there is no advantage to placing the
		/// conversion format(s) on the clipboard.
		/// 
		/// When copying bitmaps, it is best to place only the CF_DIB format on the clipboard. This is because the colors in a device-dependent bitmap
		/// (CF_BITMAP) are relative to the system palette, which may change before the bitmap is pasted. If only the CF_DIB format is on the clipboard
		/// and a window requests the CF_BITMAP format, the system renders the device-dependent bitmap using the current palette at that time.
		/// 
		/// If you place the CF_BITMAP format on the clipboard (and not CF_DIB), the system renders the CF_DIB clipboard format as soon as the
		/// clipboard is closed. This ensures that the correct palette is used to generate the device-independent bitmap
		/// (DIB). Conversions between other clipboard formats occur upon demand.
		/// 
		/// Windows platforms support two clipboard formats for metafiles: CF_ENHMETAFILE and CF_METAFILEPICT.
		/// Specify CF_ENHMETAFILE for enhanced metafiles and CF_METAFILEPICT for Windows metafiles.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber SetClipboardData(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			ushort _param1 = (ushort)param1;
			ushort _param2 = (ushort)param2;


			retVal = USER32.SetClipboardData(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber SetCursor(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = USER32.SetCursor(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The SetForegroundWindow function puts the thread that created the specified window into the foreground and activates the window.
		/// Keyboard input is directed to the window, and various visual cues are changed for the user.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window that should be activated and brought to the foreground.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// The foreground window is the window at the top of the Z order. It is the window that the user is working with.
		/// In a preemptive multitasking environment, you should generally let the user control which window is the foreground window.
		/// However, an application can call SetForegroundWindow if it wants to put itself into the foreground to display a critical error or information
		/// that requires the user’s immediate attention. A good example is a debugger when it hits a breakpoint.
		/// 
		/// The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean SetForegroundWindow(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.SetForegroundWindow(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The SetMenu function assigns a new menu to the specified window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window to which the menu is to be assigned.
		/// 	hMenu 		Identifies the new menu. If this parameter is NULL, the window’s current menu is removed.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean SetMenu(SalWindowHandle param1, SalWindowHandle param2)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;


			retVal = USER32.SetMenu(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetMenuDefaultItem function sets the default menu item for the specified menu.
		/// 
		/// Parameters:
		/// 	hMenu 		Handle to the menu to set the default item for.
		/// 	uItem 		Identifier or position of the new default menu item or 1 for no default item.
		/// 			The meaning of this parameter depends on the value of fByPos.
		/// 	fByPos 		Value specifying the meaning of uItem. If this parameter is FALSE, uItem is a menu item identifier.
		/// 			Otherwise, it is a menu item position.
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, use theGetLastError function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber SetMenuDefaultItem(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;


			USER32.SetMenuDefaultItem(_param1, _param2, _param3);

			return 0;
		}
		
		/// <summary>
		/// The SetMenuItemBitmaps function associates the specified bitmap with a menu item. Whether the menu item is checked or unchecked,
		/// Windows displays the appropriate bitmap next to the menu item.
		/// 
		/// Parameters:
		/// 	hMenu 		Identifies the menu containing the item to receive new check-mark bitmaps.
		/// 	uPosition 		Specifies the menu item to be changed, as determined by the uFlags parameter.
		/// 	uFlags 		Specifies how the uPosition parameter is interpreted. The uFlags parameter must be one of the following values.
		/// 			Value 			Meaning
		/// 			MF_BYCOMMAND 		Indicates that uPosition gives the identifier of the menu item. If neither MF_BYCOMMAND
		/// 						nor MF_BYPOSITION is specified, MF_BYCOMMAND is the default flag.
		/// 			MF_BYPOSITION 		Indicates that uPosition gives the zero-based relative position of the menu item.
		///  	hBitmapUnchecked Identifies the bitmap displayed when the menu item is not checked.
		/// 	hBitmapChecked 	Identifies the bitmap displayed when the menu item is checked.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// If either the hBitmapUnchecked or hBitmapChecked parameter is NULL, Windows displays nothing next to the menu item for the corresponding
		/// check state. If both parameters are NULL, Windows displays the default check-mark bitmap when the item is checked, and removes the bitmap
		/// when the item is not checked.
		/// 
		/// When the menu is destroyed, these bitmaps are not destroyed; it is up to the application to destroy them.
		/// 
		/// The checked and unchecked bitmaps should be monochrome. The system uses the Boolean AND operator to combine bitmaps with the
		/// menu so that the white part becomes transparent and the black part becomes the menu-item color. If you use color bitmaps,
		/// the results may be undesirable.
		/// 
		/// The GetMenuCheckMarkDimensions function is obsolete. Use the GetSystemMetrics function with the CXMENUCHECK and CYMENUCHECK
		/// values to retrieve the bitmap dimensions.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean SetMenuItemBitmaps(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalString param4, SalString param5)
		{
			SalBoolean retVal = false;
			// TODO: Implement the external function.
			return retVal;
		}
		
		/// <summary>
		/// The SetParent function changes the parent window of the specified child window.
		/// 
		/// Parameters:
		/// 	hWndChild 		Identifies the child window.
		/// 	hWndNewParent 		Identifies the new parent window. If this parameter is NULL, the desktop window becomes the new parent window.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the previous parent window.
		/// 	If the function fails, the return value is NULL. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// An application can use the SetParent function to set the parent window of a pop-up, overlapped, or child window.
		/// The new parent window and the child window must belong to the same application.
		/// 
		/// If the window identified by the hWndChild parameter is visible, Windows performs the appropriate redrawing and repainting.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle SetParent(SalWindowHandle param1, SalWindowHandle param2)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;


			retVal = USER32.SetParent(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetScrollInfo function sets the parameters of a scroll bar, including the minimum and
		/// maximum scrolling positions, the page size, and the position of the scroll box (thumb).
		/// The function also redraws the scroll bar, if requested.
		/// 
		/// Parameters:
		/// hwnd 	Handle to a scroll bar control or a window with a standard scroll bar, depending on the
		/// 	value of the fnBar parameter.
		/// fnBar 	Specifies the type of scroll bar for which to set parameters. This parameter can be one
		/// 	of the following values:
		/// 	Value 		Meaning
		/// 	SB_CTL 		Sets the parameters of a scroll bar control. The hwnd parameter must be
		/// 			the handle to the scroll bar control.
		/// 	SB_HORZ 	Sets the parameters of the given window's standard horizontal scroll bar.
		/// 	SB_VERT 	Sets the parameters of the given window's standard vertical scroll bar.
		/// lpsi 	Pointer to a SCROLLINFO structure. Before calling SetScrollInfo, set the cbSize member of
		/// 	the structure to sizeof(SCROLLINFO), set the fMask member to indicate the parameters to set,
		/// 	and specify the new parameter values in the appropriate members.
		/// 	The fMask member can be a combination of the following values:
		/// 	Value 			Meaning
		/// 	SIF_DISABLENOSCROLL 	Disables the scroll bar instead of removing it, if the scroll bar's
		/// 				new parameters make the scroll bar unnecessary.
		/// 	SIF_PAGE 		Sets the scroll page to the value specified in the nPage
		/// 				member of the SCROLLINFO structure pointed to by lpsi.
		/// 	SIF_POS 			Sets the scroll position to the value specified in the nPos
		/// 				member of the SCROLLINFO structure pointed to by lpsi.
		/// 	SIF_RANGE 		Sets the scroll range to the value specified in the nMin and
		/// 				nMax members of the SCROLLINFO structure pointed to by lpsi.
		/// fRedraw 	Specifies whether the scroll bar is redrawn to reflect the changes to the scroll bar.
		/// 	If this parameter is TRUE, the scroll bar is redrawn, otherwise, it is not redrawn.
		/// 
		/// Return Values:
		/// The return value is the current position of the scroll box.
		/// 
		/// Remarks:
		/// The SetScrollInfo function performs range checking on the values specified by the nPage and nPos
		/// members of the SCROLLINFO structure. The nPage member must specify a value from 0 to nMax - nMin +1.
		/// The nPos member must specify a value between nMin and nMax - max(nPage – 1, 0). If either value is
		/// beyond its range, the function sets it to a value that is just within the range.
		/// 
		/// Windows CE: In Windows CE 2.0, if you pass a null pointer in the lpsi parameter,
		/// SetScrollInfo returns zero, rather than the current position of the scroll box.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber SetScrollInfo(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalNumber param8, SalNumber param9, SalBoolean param10)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			bool _param10 = (bool)param10;

			Structures.STRUCT_12 _struct1 = new Structures.STRUCT_12();
			_struct1.Member1 = (uint)param3;
			_struct1.Member2 = (uint)param4;
			_struct1.Member3 = (int)param5;
			_struct1.Member4 = (int)param6;
			_struct1.Member5 = (uint)param7;
			_struct1.Member6 = (int)param8;
			_struct1.Member7 = (int)param9;

			retVal = USER32.SetScrollInfo(_param1, _param2, ref _struct1, _param10);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean SetSystemCursor(SalWindowHandle param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;


			retVal = USER32.SetSystemCursor(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetWindowLong function changes an attribute of the specified window.
		/// The function also sets a 32-bit (long) value at the specified offset into the extra window memory of a window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window and, indirectly, the class to which the window belongs.
		/// 	nIndex 		Specifies the zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window memory, minus 4;
		/// 			for example, if you specified 12 or more bytes of extra memory, a value of 8 would be an index to the third 32-bit integer.
		/// 			To set any other value, specify one of the following values:
		/// 			Value 			Action
		/// 			GWL_EXSTYLE 		Sets a new extended window style.
		/// 			GWL_STYLE 		Sets a new window style.
		/// 			GWL_WNDPROC 		Sets a new address for the window procedure.
		/// 			GWL_HINSTANCE 	Sets a new application instance handle.
		/// 			GWL_ID 			Sets a new identifier of the window.
		/// 			GWL_USERDATA 		Sets the 32-bit value associated with the window. Each window has a corresponding 32-bit
		/// 						value intended for use by the application that created the window.
		/// 
		/// 			The following values are also available when the hWnd parameter identifies a dialog box:
		/// 			Value 			Action
		/// 			DWL_DLGPROC 		Sets the new address of the dialog box procedure.
		/// 			DWL_MSGRESULT 	Sets the return value of a message processed in the dialog box procedure.
		/// 			DWL_USER 		Sets new extra information that is private to the application, such as handles or pointers.
		/// 	dwNewLong 	Specifies the replacement value.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the previous value of the specified 32-bit integer.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// 	If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information.
		/// 	This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling SetLastError(0) before calling SetWindowLong.
		/// 	Then, function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
		/// 
		/// Remarks:
		/// The SetWindowLong function fails if the window specified by the hWnd parameter does not belong to the same process as the calling thread.
		/// 
		/// If you use the SetWindowLong function and the GWL_WNDPROC index to replace the window procedure, the window procedure must conform
		/// to the guidelines specified in the description of the WindowProc callback function.
		/// 
		/// Calling SetWindowLong with the GWL_WNDPROC index creates a subclass of the window class used to create the window.
		/// An application should not subclass a window created by another process.
		/// The SetWindowLong function creates the window subclass by changing the window procedure associated with a particular window, causing Windows to call the new window procedure instead of the previous one.
		/// An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc.
		/// This allows the application to create a chain of window procedures.
		/// 
		/// Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASS structure used with the RegisterClass function.
		/// 
		/// You must not call SetWindowLong with the GWL_HWNDPARENT index to change the parent of a child window. Instead, use the SetParent function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber SetWindowLongA(SalWindowHandle param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;


			retVal = USER32.SetWindowLongA(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// Function: SetWindowPos
		/// Description: The SetWindowPos function changes the size, position, and Z order of a child, pop-up, or top-level window.
		/// Child, pop-up, and top-level windows are ordered according to their appearance on the screen.
		/// The topmost window receives the highest rank and is the first window in the Z order.
		/// 
		/// Parameters:
		/// 	hWnd 		Handle to the window.
		/// 	hWndInsertAfter 	Handle to the window to precede the positioned window in the Z order.
		/// 			This parameter must be a window handle or one of the following values:
		/// 			Value 			Meaning
		/// 			HWND_BOTTOM 		Places the window at the bottom of the Z order.
		/// 						If the hWnd parameter identifies a topmost window,
		/// 						the window loses its topmost status and is placed at the bottom of all other windows.
		/// 			HWND_NOTOPMOST 	Places the window above all non-topmost windows (that is, behind all topmost windows).
		/// 						This flag has no effect if the window is already a non-topmost window.
		/// 			HWND_TOP 		Places the window at the top of the Z order.
		/// 			HWND_TOPMOST 	Places the window above all non-topmost windows.
		/// 						The window maintains its topmost position even when it is deactivated.
		/// 	X 		Specifies the new position of the left side of the window, in client coordinates.
		/// 	Y 		Specifies the new position of the top of the window, in client coordinates.
		/// 	cx 		Specifies the new width of the window, in pixels.
		/// 	cy 		Specifies the new height of the window, in pixels.
		/// 	uFlags 		Specifies the window sizing and positioning flags.
		/// 			This parameter can be a combination of the following values:
		/// 			Value 				Meaning
		/// 			SWP_ASYNCWINDOWPOS 		If the calling thread does not own the window, the system posts the
		/// 							request to the thread that owns the window. This prevents the calling
		/// 							thread from blocking its execution while other threads process the request.
		/// 			SWP_DEFERERASE 		Prevents generation of the WM_SYNCPAINT message.
		/// 			SWP_DRAWFRAME 		Draws a frame (defined in the window's class description) around the window.
		/// 			SWP_FRAMECHANGED 		Sends a WM_NCCALCSIZE message to the window, even if the window's
		/// 							size is not being changed. If this flag is not specified,
		/// 							WM_NCCALCSIZE is sent only when the window's size is being changed.
		/// 			SWP_HIDEWINDOW 		Hides the window.
		/// 			SWP_NOACTIVATE 		Does not activate the window. If this flag is not set, the window is
		/// 							activated and moved to the top of either the topmost or non-topmost
		/// 							group (depending on the setting of the hWndInsertAfter parameter).
		/// 			SWP_NOCOPYBITS 		Discards the entire contents of the client area. If this flag is not specified,
		/// 							the valid contents of the client area are saved and copied back into the
		/// 							client area after the window is sized or repositioned.
		/// 			SWP_NOMOVE 			Retains the current position (ignores the X and Y parameters).
		/// 			SWP_NOOWNERZORDER 		Does not change the owner window's position in the Z order.
		/// 			SWP_NOREDRAW 		Does not redraw changes. If this flag is set, no repainting of any kind occurs.
		/// 							This applies to the client area, the nonclient area (including the title bar and
		/// 							scroll bars), and any part of the parent window uncovered as a result of the
		/// 							window being moved. When this flag is set, the application must explicitly
		/// 							invalidate or redraw any parts of the window and parent window that need redrawing.
		/// 			SWP_NOREPOSITION 		Same as the SWP_NOOWNERZORDER flag.
		/// 			SWP_NOSENDCHANGING 		Prevents the window from receiving the WM_WINDOWPOSCHANGING message.
		/// 			SWP_NOSIZE 			Retains the current size (ignores the cx and cy parameters).
		/// 			SWP_NOZORDER 		Retains the current Z order (ignores the hWndInsertAfter parameter).
		/// 			SWP_SHOWWINDOW 		Displays the window.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, callGetLastError.
		/// 
		/// Remarks:
		/// If the SWP_SHOWWINDOW or SWP_HIDEWINDOW flag is set, the window cannot be moved or sized.
		/// 
		/// If you have changed certain window data using SetWindowLong, you must call SetWindowPos to have the changes take effect.
		/// Use the following combination for uFlags: SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED.
		/// 
		/// A window can be made a topmost window either by setting the hWndInsertAfter parameter to HWND_TOPMOST and ensuring
		/// that the SWP_NOZORDER flag is not set, or by setting a window's position in the Z order so that it is above any existing topmost windows.
		/// When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed.
		/// 
		/// If neither the SWP_NOACTIVATE nor SWP_NOZORDER flag is specified (that is, when the application requests that a window be
		/// simultaneously activated and its position in the Z order changed), the value specified in hWndInsertAfter is used only in the following circumstances:
		/// 
		/// Neither the HWND_TOPMOST nor HWND_NOTOPMOST flag is specified in hWndInsertAfter.
		/// The window identified by hWnd is not the active window.
		/// An application cannot activate an inactive window without also bringing it to the top of the Z order. Applications can change an activated
		/// window's position in the Z order without restrictions, or it can activate a window and then move it to the top of the topmost or non-topmost windows.
		/// 
		/// If a topmost window is repositioned to the bottom (HWND_BOTTOM) of the Z order or after any non-topmost window, it is no longer topmost.
		/// When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows.
		/// 
		/// A non-topmost window can own a topmost window, but the reverse cannot occur. Any window (for example, a dialog box) owned by a topmost
		/// window is itself made a topmost window, to ensure that all owned windows stay above their owner.
		/// 
		/// If an application is not in the foreground, and should be in the foreground, it must call the SetForegroundWindow function.
		/// 
		/// Windows CE: If this is a visible top-level window, and the SWP_NOACTIVATE flag is not specified, this function will activate the window.
		/// If this is the currently active window, and either the SWP_NOACTIVATE flag or the SWP_HIDEWINDOW flag is specified, the activation is
		/// passed on to another visible top-level window.
		/// 
		/// When you set the SWP_FRAMECHANGED flag in the nFlags parameter to this function, Windows CE redraws the entire non-client area of the window,
		/// which may change the size of the client area. This is the only way to get the non-client area to be recalculated and is typically used after a you've
		/// changed the window style by calling SetWindowLong.
		/// 
		/// SetWindowPos will always cause a WM_WINDOWPOSCHANGED message to be sent to the window. The flags passed in this message are
		/// exactly the same as those passed into the function. No other messages are sent by this function.
		/// 
		/// Windows CE 1.0 does not support the HWND_TOPMOST and HWND_NOTOPMOST constants in the hwndInsertAfter parameter.
		/// 
		/// Windows CE 1.0 does not support the SWP_DRAWFRAME or SWP_NOCOPYBITS flags in the fuFlags paramete.
		/// 
		/// QuickInfo:
		/// Windows NT: Requires version 3.1 or later.
		/// Windows: Requires Windows 95 or later.
		/// Windows CE: Requires version 1.0 or later.
		/// Header: Declared in winuser.h.
		/// Import Library: Use user32.lib.
		/// Export Ordinal: 0
		/// Returns
		/// Parameters
		/// Window Handle: HWND
		/// Window Handle: HWND
		/// Number: LONG
		/// Number: LONG
		/// Number: LONG
		/// Number: LONG
		/// Number: UINT
		/// The SetWindowRgn function sets the window region of a window.
		/// The window region determines the area within the window where the system permits drawing.
		/// The system does not display any portion of a window that lies outside of the window region
		/// 
		/// int SetWindowRgn(
		///   HWND hWnd,     // handle to window whose window region is to be set
		///   HRGN hRgn,     // handle to region
		///   BOOL bRedraw   // window redraw flag
		/// );
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber SetWindowRgn(SalWindowHandle param1, SalWindowHandle param2, SalBoolean param3)
		{
			System.IntPtr _param1 = (System.IntPtr)param1;
			System.IntPtr _param2 = (System.IntPtr)param2;
			bool _param3 = (bool)param3;


			USER32.SetWindowRgn(_param1, _param2, _param3);

			return 0;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean SetWindowTextA(SalWindowHandle param1, SalString param2)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			string _param2 = param2.Value;


			retVal = USER32.SetWindowTextA(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The SetWindowsHookEx function installs an application-defined hook procedure into a hook chain.
		/// You would install a hook procedure to monitor the system for certain types of events.
		/// These events are associated either with a specific thread or with all threads in the system.
		/// 
		/// Parameters:
		/// 	idHook 		Specifies the type of hook procedure to be installed. This parameter can be one of the following values:
		/// 			Value 			Description
		///  			WH_CALLWNDPROC 	Installs a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure.
		/// 			WH_CALLWNDPROCRET 	Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the CallWndRetProc hook procedure.
		/// 			WH_CBT 		Installs a hook procedure that receives notifications useful to a computer-based training (CBT) application. For more information, see the CBTProc hook procedure.
		/// 			WH_DEBUG 		Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure.
		/// 			WH_GETMESSAGE 	Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure.
		/// 			WH_JOURNALPLAYBACK 	Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure.
		/// 			WH_JOURNALRECORD 	Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros.
		/// 						For more information, see the JournalRecordProc hook procedure.
		/// 
		/// 			WH_KEYBOARD 		Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure.
		/// 			WH_MOUSE 		Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure.
		/// 			WH_MSGFILTER 		Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar.
		/// 						For more information, see the MessageProc hook procedure.
		/// 
		/// 			WH_SHELL 		 Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc hook procedure.
		/// 			WH_SYSMSGFILTER 	Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar.
		/// 						The hook procedure monitors these messages for all applications in the system. For more information, see the SysMsgProc hook procedure.
		/// 	lpfn 		Points to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process,
		/// 			the lpfn parameter must point to a hook procedure in a dynamic-link library (DLL). Otherwise, lpfn can point to a hook procedure in the code associated with the current process.
		/// 	hMod 		Identifies the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter
		/// 			specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.
		/// 	dwThreadId 	Specifies the identifier of the thread with which the hook procedure is to be associated. If this parameter is zero, the hook procedure is associated with all existing threads.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the hook procedure.
		/// 	If the function fails, the return value is NULL.
		/// 
		/// Remarks:
		/// An error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.
		/// 
		/// Calling the CallNextHookEx function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks
		/// will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.
		/// 
		/// Before terminating, an application must call the UnhookWindowsHookEx function to free system resources associated with the hook.
		/// 
		/// The scope of a hook depends on the hook type. Some hooks can be set only with system scope; others can also be set for only a specific thread, as shown in the following list:
		/// Hook 				Scope
		/// WH_CALLWNDPROC 		Thread or system
		/// WH_CALLWNDPROCRET 		Thread or system
		/// WH_CBT 			Thread or system
		/// WH_DEBUG 			Thread or system
		/// WH_GETMESSAGE 		Thread or system
		/// WH_JOURNALPLAYBACK 		System only
		/// WH_JOURNALRECORD 		System only
		/// WH_KEYBOARD 			Thread or system
		/// WH_MOUSE 			Thread or system
		/// WH_MSGFILTER 			Thread or system
		/// WH_SHELL 			Thread or system
		/// WH_SYSMSGFILTER 		System only
		/// 
		/// For a specified hook type, thread hooks are called first, then system hooks.
		/// 
		/// The system hooks are a shared resource, and installing one affects all applications. All system hook functions must be in libraries.
		/// System hooks should be restricted to special-purpose applications or to use as a development aid during application debugging.
		/// Libraries that no longer need a hook should remove the hook procedure.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber SetWindowsHookExA(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;
			uint _param4 = (uint)param4;


			retVal = USER32.SetWindowsHookExA(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The ShowCaret function makes the caret visible on the screen at the caret's current position. When the caret becomes visible, it begins flashing automatically.
		/// 
		/// BOOL ShowCaret(
		///   HWND hWnd   // handle of window with caret
		/// );
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean ShowCaret(SalWindowHandle param1)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;


			retVal = USER32.ShowCaret(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The ShowCursor function displays or hides the cursor.
		/// 
		/// int ShowCursor(
		///   BOOL bShow   // cursor visibility flag
		/// );
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber ShowCursor(SalBoolean param1)
		{
			SalNumber retVal = 0;
			bool _param1 = (bool)param1;


			retVal = USER32.ShowCursor(_param1);

			return retVal;
		}
		
		/// <summary>
		/// The ShowWindow function sets the specified window’s show state.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window.
		/// 	nCmdShow 	Specifies how the window is to be shown. This parameter is ignored the first time an application calls ShowWindow,
		/// 			if the program that launched the application provides a STARTUPINFO structure. Otherwise, the first time ShowWindow is called,
		/// 			the value should be the value obtained by the WinMain function in its nCmdShow parameter. In subsequent calls, this parameter can be one of the following values:
		/// 			Value 			Meaning
		/// 			SW_HIDE 		Hides the window and activates another window.
		/// 			SW_MAXIMIZE 		Maximizes the specified window.
		/// 			SW_MINIMIZE 		Minimizes the specified window and activates the next top-level window in the Z order.
		/// 			SW_RESTORE 		Activates and displays the window. If the window is minimized or maximized, Windows restores it to its original size and position.
		/// 						An application should specify this flag when restoring a minimized window.
		/// 			SW_SHOW 		Activates the window and displays it in its current size and position.
		/// 			SW_SHOWDEFAULT 	Sets the show state based on the SW_ flag specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application.
		/// 			SW_SHOWMAXIMIZED 	Activates the window and displays it as a maximized window.
		/// 			SW_SHOWMINIMIZED 	Activates the window and displays it as a minimized window.
		/// 			SW_SHOWMINNOACTIVE 	Displays the window as a minimized window. The active window remains active.
		/// 			SW_SHOWNA 		Displays the window in its current state. The active window remains active.
		/// 			SW_SHOWNOACTIVATE 	Displays a window in its most recent size and position. The active window remains active.
		/// 			SW_SHOWNORMAL 	Activates and displays a window. If the window is minimized or maximized, Windows restores it to its original size and position.
		/// 						An application should specify this flag when displaying the window for the first time.
		/// 
		/// Return Values:
		/// 	If the window was previously visible, the return value is nonzero.
		/// 	If the window was previously hidden, the return value is zero.
		/// 
		/// Remarks:
		/// The first time a program calls ShowWindow, it uses the WinMain function’s nCmdShow parameter as its nCmdShow parameter.
		/// Subsequent calls to ShowWindow must use one of the values in the given list, instead of the one specified by the WinMain function’s nCmdShow parameter.
		/// 
		/// As noted in the discussion of the nCmdShow parameter, the nCmdShow value is ignored in the first call to ShowWindow if the program that launched the application
		/// specifies startup information in the STARTUPINFO structure. In this case, ShowWindow uses the information specified in the STARTUPINFO structure to show the window.
		/// On subsequent calls, the application must call ShowWindow with nCmdShow set to SW_SHOWDEFAULT to use the startup information provided by the program that launched the application.
		/// For example, Program Manager specifies that applications start with a minimized main window. This behavior is designed for the following situations:
		/// 
		/// · Applications create their main window by calling CreateWindow with the WS_VISIBLE flag set.
		/// · Applications create their main window by calling CreateWindow with the WS_VISIBLE flag cleared, and later call ShowWindow with the SW_SHOW flag set to make it visible.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean ShowWindow(SalWindowHandle param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.ShowWindow(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The TrackPopupMenu function displays a shortcut menu at the specified location and tracks the selection of items on the menu.
		/// The shortcut menu can appear anywhere on the screen.
		/// 
		/// Parameters:
		/// 	hMenu 			Identifies the shortcut menu to be displayed. The handle can be obtained by calling CreatePopupMenu to create
		/// 				a new shortcut menu, or by calling GetSubMenu to retrieve the handle of a submenu associated with an existing menu item.
		/// 	uFlags 			A set of bit flags that specify function options.
		/// 				Use one of the following bit flag constants to specify how the function positions the shortcut menu horizontally.
		/// 				Value 			Meaning
		///  				TPM_CENTERALIGN 	If this flag is set, the function centers the shortcut menu horizontally relative to the coordinate specified by the x parameter.
		/// 				TPM_LEFTALIGN 		If this flag is set, the function positions the shortcut menu so that its left side is aligned with the coordinate specified by the x parameter.
		/// 				TPM_RIGHTALIGN 	Positions the shortcut menu so that its right side is aligned with the coordinate specified by the x parameter.
		/// 
		/// 				Use one of the following bit flag constants to specify how the function positions the shortcut menu vertically.
		/// 				Value 			Meaning
		/// 				TPM_BOTTOMALIGN 	If this flag is set, the function positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the y parameter.
		/// 				TPM_TOPALIGN 		If this flag is set, the function positions the shortcut menu so that its top side is aligned with the coordinate specified by the y parameter.
		/// 				TPM_VCENTERALIGN 	If this flag is set, the function centers the shortcut menu vertically relative to the coordinate specified by the y parameter.
		/// 
		/// 				Use the following bit flag constants to determine the user selection without having to set up a parent window for the menu.
		/// 				Value 			Meaning
		/// 				TPM_NONOTIFY 		If this flag is set, the function does not send notification messages when the user clicks on a menu item.
		/// 				TPM_RETURNCMD 	If this flag is set, the function returns the menu item identifier of the user's selection in the return value.
		/// 
		/// 				Use one of the following bit flag constants to specify which mouse button the shortcut menu tracks.
		/// 				Value 			Meaning
		/// 				TPM_LEFTBUTTON 	If this flag is set, the shortcut menu tracks the left mouse button.
		/// 				TPM_RIGHTBUTTON 	If this flag is set, the shortcut menu tracks the right mouse button
		/// 	x 			Specifies the horizontal location of the shortcut menu, in screen coordinates.
		/// 	y 			Specifies the vertical location of the shortcut menu, in screen coordinates.
		/// 	nReserved 		Reserved; must be zero.
		/// 	hWnd 			Identifies the window that owns the shortcut menu. This window receives all messages from the menu.
		/// 				The window does not receive a WM_COMMAND message from the menu until the function returns.
		/// 				If you specify TPM_NONOTIFY in the uFlags parameter, the function does not send messages to the window identified by hWnd.
		/// 				However, you must still pass a window handle in hWnd. It can be any window handle from your application.
		/// 	prcRect 			Points to a RECT structure that specifies the portion of the screen in which the user can select without dismissing the shortcut menu.
		/// 				If this parameter is NULL, the shortcut menu is dismissed if the user clicks outside the shortcut menu.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// 	If you specify TPM_RETURNCMD in the uFlags parameter, the return value is the menu-item identifier of the item selected.
		/// 	If no item is selected, the return value is zero.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <returns></returns>
		public static SalBoolean TrackPopupMenu(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalWindowHandle param6, SalString param7)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			System.IntPtr _param6 = (System.IntPtr)param6;
			string _param7 = param7.Value;


			retVal = USER32.TrackPopupMenu(_param1, _param2, _param3, _param4, _param5, _param6, _param7);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean TranslateMessage(ref SalString param1)
		{
			SalBoolean retVal = false;
			System.Text.StringBuilder _param1 = new System.Text.StringBuilder(param1.Value);


			retVal = USER32.TranslateMessage(_param1);

			param1 = _param1.ToString();
			return retVal;
		}
		
		/// <summary>
		/// The UnhookWindowsHookEx function removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.
		/// 
		/// Parameters:
		/// 	hhk 		Identifies the hook to be removed. This parameter is a hook handle obtained by a previous call to SetWindowsHookEx.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The hook procedure can be in the state of being called by another thread even after UnhookWindowsHookEx returns.
		/// If the hook procedure is not being called concurrently, the hook procedure is removed immediately before UnhookWindowsHookEx returns.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean UnhookWindowsHookEx(SalNumber param1)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;


			retVal = USER32.UnhookWindowsHookEx(_param1);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean UnregisterHotKey(SalWindowHandle param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;


			retVal = USER32.UnregisterHotKey(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The ValidateRect function validates the client area within a rectangle by removing the rectangle from the update region of the specified window.
		/// 
		/// Parameters:
		/// 	hWnd 		Identifies the window whose update region is to be modified. If this parameter is NULL,
		/// 			Windows invalidates and redraws all windows and sends the WM_ERASEBKGND and WM_NCPAINT
		/// 			messages to the window procedure before the function returns.
		/// 	lpRect 		Points to a RECT structure that contains the client coordinates of the rectangle to be removed from the update region.
		/// 			If this parameter is NULL, the entire client area is removed.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero.
		/// 
		/// Remarks:
		/// The BeginPaint function automatically validates the entire client area. Neither the ValidateRect nor ValidateRgn function should be called if a
		/// portion of the update region must be validated before the next WM_PAINT message is generated.
		/// 
		/// Windows continues to generate WM_PAINT messages until the current update region is validated.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalBoolean ValidateRect(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			int _param2 = (int)param2;
			int _param3 = (int)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;


			retVal = USER32.ValidateRect(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// The ValidateRgn function validates the client area within a region by removing the region from the current update region of the specified window.
		/// 
		/// BOOL ValidateRgn(
		///   HWND hWnd,  // handle of window
		///   HRGN hRgn   // handle of valid region
		/// );
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalBoolean ValidateRgn(SalWindowHandle param1, SalNumber param2)
		{
			SalBoolean retVal = false;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;


			retVal = USER32.ValidateRgn(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The WindowFromPoint function retrieves the handle of the window that contains the specified point.
		/// 
		/// Parameters:
		/// 	Point 		Specifies a POINT structure that defines the point to be checked.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the handle of the window that contains the point.
		/// 	If no window exists at the given point, the return value is NULL.
		/// 
		/// Remarks:
		/// The WindowFromPoint function does not retrieve the handle of a hidden or disabled window, even if the point is within the window.
		/// An application should use the ChildWindowFromPoint function for a nonrestrictive search.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalWindowHandle WindowFromPoint(SalNumber param1, SalNumber param2)
		{
			SalWindowHandle retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;


			retVal = USER32.WindowFromPoint(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The GetFileVersionInfo function returns version information about a specified file.
		/// As with other file installation functions, GetFileVersionInfo works only with Win32 file images. It does not work with 16-bit Windows file images.
		/// 
		/// Parameters:
		/// 	lptstrFilename 		Pointer to a null-terminated filename string that specifies the file of interest.
		/// 	dwHandle 		This parameter is ignored.
		/// 	dwLen 			Specifies the size, in bytes, of the buffer pointed to by lpData.
		/// 				Call the GetFileVersionInfoSize function to determine the size in bytes of a file’s version information. dwLen should be equal to or greater than that value.
		/// 				If the buffer pointed to by lpData is not large enough, the function truncates the file’s-version information to the size of the buffer.
		/// 	lpData 			Pointer to a buffer to receive file-version information.
		/// 				You can use this value in a subsequent call to the VerQueryValue function.
		/// 
		/// The file version information is always in Unicode format.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is nonzero.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean GetFileVersionInfoA(SalString param1, SalNumber param2, SalNumber param3, SalNumber param4)
		{
			SalBoolean retVal = false;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;


			retVal = VERSION.GetFileVersionInfoA(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// The GetFileVersionInfoSize function determines whether the operating system can obtain version information about a specified file.
		/// If version information is available, GetFileVersionInfoSize returns the size in bytes of that information.
		/// 
		/// As with other file installation functions, GetFileVersionInfo works only with Win32 file images. It does not work with 16-bit Windows file images.
		/// 
		/// Parameters:
		/// 	lptstrFilename 		Pointer to a null-terminated filename string that specifies the file of interest.
		/// 	lpdwHandle 		Pointer to a variable that the function sets to zero.
		/// 
		/// Return Values:
		/// 	If the function succeeds, the return value is the size in bytes of the file’s version information.
		/// 	If the function fails, the return value is zero. To get extended error information, call GetLastError.
		/// 
		/// Remarks:
		/// Call the GetFileVersionInfoSize function before calling the GetFileVersionInfo function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber GetFileVersionInfoSizeA(SalString param1, ref SalNumber param2)
		{
			SalNumber retVal = 0;
			string _param1 = param1.Value;
			uint _param2 = (uint)param2;


			retVal = VERSION.GetFileVersionInfoSizeA(_param1, ref _param2);

			param2 = _param2;
			return retVal;
		}
		
		/// <summary>
		/// The VerQueryValue function returns selected version information from the specified version-information resource.
		/// To retrieve the appropriate resource, the GetFileVersionInfo function must be called before VerQueryValue.
		/// 
		/// As with the other file installation functions, VerQueryValue will only work with Win32 file images. 16-bit Windows file images are not supported.
		/// 
		/// Parameters:
		/// 	pBlock 		Points to the buffer containing the version-information resource returned by GetFileVersionInfo.
		/// 	lpSubBlock 	Points to a zero-terminated string specifying which version-information value to retrieve. The string consists of names separated by backslashes (\) and can have one of the following forms:
		/// 			Form  Description
		///  			\ 					Specifies the root block. The function retrieves a pointer to the VS_FIXEDFILEINFO structure for the version-information resource.
		///  			\VarFileInfo\Translation 			Specifies the translation table in the variable information structure. The function retrieves a pointer to an array of language and character-set identifiers.
		/// 								An application uses these identifiers to create the name of a language-specific structure in the version-information resource.
		///  			\StringFileInfo\lang-charset\string-name 		Specifies a value in a language-specific structure. The lang-charset name is a concatenation of a language and character-set identifier pair
		/// 								found in the translation table for the resource. The lang-charset name must be specified as a hexadecimal string.
		/// 								The string-name name is one of the predefined strings described in the following Remarks section.
		///  	lplpBuffer 		Points to a buffer that receives a pointer to the version-information value.
		/// 	puLen 		Points to a buffer that receives the length, in characters, of the version-information value.
		/// 
		/// Return Values:
		/// 	If the specified structure exists and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name.
		/// 	If the specified name does not exist or the specified resource is not valid, the return value is zero.
		/// 
		/// Remarks:
		/// The Win32 API contains the following predefined version information strings:
		/// 
		/// CompanyName FileDescription FileVersion InternalName LegalCopyright OriginalFilename ProductName ProductVersion
		/// 
		/// The following example shows how to retrieve the FileDescription string-value from a block of version information:
		/// 
		/// VerQueryValue(pBlock,
		///               TEXT("\\StringFileInfo\\040904E4\\FileDescription"),
		///               &lpBuffer,
		///               &dwBytes);
		/// 
		/// Call the GetFileVersionInfoSize and GetFileVersionInfo functions to properly initialize the pBlock buffer before calling the VerQueryValue function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalBoolean VerQueryValueA(SalNumber param1, SalString param2, ref SalNumber param3, ref SalNumber param4)
		{
			SalBoolean retVal = false;
            //FC:FINAL: not needed anymore
            //int _param1 = (int)param1;
            //string _param2 = param2.Value;
            //System.Text.StringBuilder _param3 = new System.Text.StringBuilder(param3.Value);
            //uint _param4 = (uint)param4;


            //retVal = VERSION.VerQueryValueA(_param1, _param2, _param3, ref _param4);

            //param3 = _param3.ToString();
            //param4 = _param4;
            return retVal;
		}
		
		/// <summary>
		/// The sndPlaySound function plays a waveform sound specified either by a filename or by an entry in the registry or the WIN.INI file.
		/// This function offers a subset of the functionality of the PlaySound function; sndPlaySound is being maintained for backward compatibility.
		/// 
		/// Parameters:
		/// 	lpszSound 		A string that specifies the sound to play. This parameter can be either an entry in the registry or in WIN.INI that identifies a system sound, or it can be the name of a waveform-audio file.
		/// 				(If the function does not find the entry, the parameter is treated as a filename.) If this parameter is NULL, any currently playing sound is stopped.
		/// 	fuSound 			Flags for playing the sound. The following values are defined:
		/// 				SND_ASYNC 		The sound is played asynchronously and the function returns immediately after beginning the sound.
		/// 							To terminate an asynchronously played sound, call sndPlaySound with lpszSoundName set to NULL.
		/// 				SND_LOOP 		The sound plays repeatedly until sndPlaySound is called again with the lpszSoundName parameter set to NULL.
		/// 							You must also specify the SND_ASYNC flag to loop sounds.
		/// 				SND_MEMORY 		The parameter specified by lpszSoundName points to an image of a waveform sound in memory.
		/// 				SND_NODEFAULT 	If the sound cannot be found, the function returns silently without playing the default sound.
		/// 				SND_NOSTOP 		If a sound is currently playing, the function immediately returns FALSE, without playing the requested sound.
		/// 				SND_SYNC 		The sound is played synchronously and the function does not return until the sound ends.
		/// 
		/// Return Values:
		/// 	Returns TRUE if successful or FALSE otherwise.
		/// 
		/// Remarks:
		/// If the specified sound cannot be found, sndPlaySound plays the system default sound. If there is no system default entry in the registry or WIN.INI file,
		/// or if the default sound cannot be found, the function makes no sound and returns FALSE.
		/// 
		/// The specified sound must fit in available physical memory and be playable by an installed waveform-audio device driver.
		/// If sndPlaySound does not find the sound in the current directory, the function searches for it using the standard directory-search order.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber sndPlaySoundA(SalString param1, SalNumber param2)
		{
			string _param1 = param1.Value;
			int _param2 = (int)param2;


			WINMM.sndPlaySoundA(_param1, _param2);

			return 0;
		}
		
		/// <summary>
		/// Registers and initializes the common control window classes. This function is obsolete.
		/// </summary>
		/// <returns></returns>
		public static SalNumber InitCommonControls()
		{


			COMCTL32.InitCommonControls();

			return 0;
		}
		
		/// <summary>
		/// Registers specific common control classes from the common control dynamic-link library (DLL).
		/// Returns TRUE if successful, or FALSE otherwise.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean InitCommonControlsEx(SalNumber param1, SalNumber param2)
		{
			SalBoolean retVal = false;

			Structures.STRUCT_4 _struct1 = new Structures.STRUCT_4();
			_struct1.Member1 = (uint)param1;
			_struct1.Member2 = (uint)param2;

			retVal = COMCTL32.InitCommonControlsEx(ref _struct1);

			return retVal;
		}
		
		/// <summary>
		/// Creates a status window, which is typically used to display the status of an application.
		/// The window generally appears at the bottom of the parent window, and it contains the
		/// specified text.
		/// 
		/// Returns the handle for the status window if successful, or NULL otherwise.
		/// 
		/// Parameters:
		/// 	style 		Window styles for the status window. This parameter must include
		/// 			the WS_CHILD style and should also include the WS_VISIBLE style.
		/// 	lpszText		Address of a null-terminated string that specifies the status text for the first part.
		/// 	hwndParent 	Handle to the parent window.
		/// 	wID 		Control identifier for the status window. The window procedure uses this value to
		/// 			identify messages it sends to the parent window.
		/// 
		/// The CreateStatusWindow function calls theCreateWindow function to create the window.
		/// It passes the parameters to CreateWindow without modification and sets the position, width,
		/// and height parameters to default values.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalWindowHandle CreateStatusWindow(SalNumber param1, SalString param2, SalWindowHandle param3, SalNumber param4)
		{
			SalWindowHandle retVal = 0;
			int _param1 = (int)param1;
			string _param2 = param2.Value;
			System.IntPtr _param3 = (System.IntPtr)param3;
			uint _param4 = (uint)param4;


			retVal = COMCTL32.CreateStatusWindow(_param1, _param2, _param3, _param4);

			return retVal;
		}
		
		/// <summary>
		/// Creates a toolbar window and adds the specified buttons to the toolbar.
		/// 
		/// Returns the window handle to the toolbar if successful, or NULL otherwise.
		/// 
		/// Parameters:
		/// 	hwnd 		Handle to the parent window for the toolbar.
		/// 	ws 		Window styles for the toolbar. This parameter must specify at least the WS_CHILD style.
		/// 			It can also include a combination of styles as discussed in Toolbar Control and Button Styles.
		/// 	wID 		Control identifier for the toolbar.
		/// 	nBitmaps 	Number of button images contained in the bitmap specified by hBMInst and wBMID.
		/// 	hBMInst 		Module instance with the executable file that contains the bitmap resource.
		/// 	wBMID 		Resource identifier for the bitmap resource. If hBMInst is NULL, this parameter must be a valid bitmap handle.
		/// 	lpButtons 	Address of an array of TBBUTTON structures that contain information about the buttons to add to the toolbar.
		/// 	iNumButtons 	Number of buttons to add to the toolbar.
		/// 	dxButton 		Width, in pixels, of the buttons to add to the toolbar.
		/// 	dyButton 		Height, in pixels, of the buttons to add to the toolbar.
		/// 	dxBitmap 	Width, in pixels, of the button images to add to the buttons in the toolbar.
		/// 	dyBitmap 	Height, in pixels, of the button images to add to the buttons in the toolbar.
		/// 	uStructSize 	Size of a TBBUTTON structure.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <param name="param11"></param>
		/// <param name="param12"></param>
		/// <param name="param13"></param>
		/// <returns></returns>
		public static SalWindowHandle CreateToolbarEx(SalWindowHandle param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalString param7, SalNumber param8, SalNumber param9, SalNumber param10, SalNumber param11, SalNumber param12, SalNumber param13)
		{
			SalWindowHandle retVal = 0;
			System.IntPtr _param1 = (System.IntPtr)param1;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;
			uint _param5 = (uint)param5;
			uint _param6 = (uint)param6;
			string _param7 = param7.Value;
			int _param8 = (int)param8;
			int _param9 = (int)param9;
			int _param10 = (int)param10;
			int _param11 = (int)param11;
			int _param12 = (int)param12;
			uint _param13 = (uint)param13;


			retVal = COMCTL32.CreateToolbarEx(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8, _param9, _param10, _param11, _param12, _param13);

			return retVal;
		}
		
		/// <summary>
		/// Draws the specified text in the style of a status window with borders.
		/// 
		/// This function does not return a value.
		/// 
		/// Parameters:
		/// 	hdc 	Handle to the display context for the window.
		/// 	lprc 	Address of aRECT structure that contains the position, in client coordinates, of the rectangle in which the text is drawn.
		/// 		The function draws the borders just inside the edges of the specified rectangle.
		/// 	pszText 	Address of a null-terminated string that specifies the text to display. Tab characters in the string determine
		/// 		whether the string is left-aligned, right-aligned, or centered.
		/// 	uFlags 	Text drawing flags. This parameter can be a combination of these values:
		/// 		SBT_NOBORDERS  	Prevents borders from being drawn around the specified text.
		/// 		SBT_POPOUT  		Draws highlighted borders that make the text stand out.
		/// 		SBT_RTLREADING  	Displays text using right-to-left reading order on Hebrew or Arabic systems.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <returns></returns>
		public static SalNumber DrawStatusText(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalString param6, SalNumber param7)
		{
			uint _param1 = (uint)param1;
			string _param6 = param6.Value;
			uint _param7 = (uint)param7;

			Structures.STRUCT_3 _struct1 = new Structures.STRUCT_3();
			_struct1.Member1 = (int)param2;
			_struct1.Member2 = (int)param3;
			_struct1.Member3 = (int)param4;
			_struct1.Member4 = (int)param5;

			COMCTL32.DrawStatusText(_param1, ref _struct1, _param6, _param7);

			return 0;
		}
		
		/// <summary>
		/// Adds an image or images to an image list.
		/// 
		/// Returns the index of the first new image if successful, or -1 otherwise.
		/// 
		/// Parameters:
		/// 	himl 		Handle to the image list.
		/// 	hbmImage 	Handle to the bitmap that contains the image or images.
		/// 			The number of images is inferred from the width of the bitmap.
		/// 	hbmMask 	Handle to the bitmap that contains the mask. If no mask is used
		/// 			with the image list, this parameter is ignored.
		/// 
		/// The ImageList_Add function copies the bitmap to an internal data structure.
		/// Be sure to use theDeleteObject function to delete hbmImage and hbmMask after the function returns.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber ImageList_Add(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;
			uint _param3 = (uint)param3;


			retVal = COMCTL32.ImageList_Add(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// Adds an icon or cursor to an image list. ImageList_AddIcon calls the ImageList_ReplaceIcon function.
		/// 
		/// Returns the index of the new image if successful, or -1 otherwise.
		/// 
		/// Parameters:
		/// 	himl 	Handle to the image list. If this parameter identifies a masked image list, the macro copies
		/// 		both the image and mask bitmaps of the icon or cursor. If this parameter identifies a nonmasked
		/// 		image list, the macro copies only the image bitmap.
		/// 	hicon 	Handle to the icon or cursor that contains the bitmap and mask for the new image.
		/// 
		/// Because the system does not save hicon, you can destroy it after the macro returns if the icon or cursor was
		/// created by theCreateIcon function. You do not need to destroy hicon if it was loaded by theLoadIcon function;
		/// the system automatically frees an icon resource when it is no longer needed.
		/// 
		/// The ImageList_AddIcon macro is defined as follows:
		/// #define  ImageList_AddIcon(himl, hicon) ImageList_ReplaceIcon(himl, -1, hicon)
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber ImageList_AddIcon(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;


			retVal = COMCTL32.ImageList_AddIcon(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// Adds an image or images to an image list, generating a mask from the specified bitmap.
		/// 
		/// Returns the index of the first new image if successful, or -1 otherwise.
		/// 
		/// Parameters:
		/// 	himl 		Handle to the image list.
		/// 	hbmImage 	Handle to the bitmap that contains one or more images.
		/// 			The number of images is inferred from the width of the bitmap.
		/// 	crMask 		Color used to generate the mask. Each pixel of this color in the specified bitmap is
		/// 			changed to black, and the corresponding bit in the mask is set to 1.
		/// 
		/// The ImageList_AddMasked function copies the bitmap to an internal data structure.
		/// Be sure to use theDeleteObject function to delete hbmImage and crMask after the function returns.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber ImageList_AddMasked(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			uint _param2 = (uint)param2;
			int _param3 = (int)param3;


			retVal = COMCTL32.ImageList_AddMasked(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// Creates a new image list.
		/// 
		/// Returns the handle to the image list if successful, or NULL otherwise.
		/// 
		/// Parameters:
		/// 	cx 	Width, in pixels, of each image.
		/// 	cy 	Height, in pixels, of each image.
		/// 	flags 	Set of bit flags that specify the type of image list to create.
		/// 		This parameter can be a combination of the following values,
		/// 		but it can include only one of the ILC_COLOR values.
		/// 		ILC_COLOR  	Use the default behavior if none of the other ILC_COLOR* flags is specified.
		/// 				Typically, the default is ILC_COLOR4, but for older display drivers,
		/// 				the default is ILC_COLORDDB.
		/// 		ILC_COLOR4  	Use a 4-bit (16-color) device-independent bitmap (DIB) section as the bitmap
		/// 				for the image list.
		/// 		ILC_COLOR8  	Use an 8-bit DIB section. The colors used for the color table are the same
		/// 				colors as the halftone palette.
		/// 		ILC_COLOR16  	Use a 16-bit (32/64k-color) DIB section.
		/// 		ILC_COLOR24  	Use a 24-bit DIB section.
		/// 		ILC_COLOR32  	Use a 32-bit DIB section.
		/// 		ILC_COLORDDB  	Use a device-dependent bitmap.
		/// 		ILC_MASK  	Use a mask. The image list contains two bitmaps, one of which is a
		/// 				monochrome bitmap used as a mask. If this value is not included,
		/// 				the image list contains only one bitmap.
		/// 	cInitial 	Number of images that the image list initially contains.
		/// 	cGrow 	Number of images by which the image list can grow when the system needs to make room
		/// 		for new images. This parameter represents the number of new images that the resized
		/// 		image list can contain.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <returns></returns>
		public static SalNumber ImageList_Create(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5)
		{
			SalNumber retVal = 0;
			int _param1 = (int)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;


			retVal = COMCTL32.ImageList_Create(_param1, _param2, _param3, _param4, _param5);

			return retVal;
		}
		
		/// <summary>
		/// Destroys an image list.
		/// 
		/// Returns nonzero if successful, or zero otherwise.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean ImageList_Destroy(SalNumber param1)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;


			retVal = COMCTL32.ImageList_Destroy(_param1);

			return retVal;
		}
		
		/// <summary>
		/// Draws an image list item in the specified device context.
		/// 
		/// Returns nonzero if successful, or zero otherwise.
		/// 
		/// Parameters:
		/// 	himl 	Handle to the image list.
		/// 	i 	Index of the image to draw.
		/// 	hdcDst 	Handle to the destination device context.
		/// 	x 	X-coordinate at which to draw within the specified device context.
		/// 	y 	Y-coordinate at which to draw within the specified device context.
		/// 	fStyle 	Drawing style and, optionally, the overlay image. For information
		/// 		about specifying an overlay image index, see the comments section
		/// 		at the end of this topic. This parameter can be a combination of an
		/// 		overlay image index and one or more of the following values:
		/// 		ILD_BLEND25,
		/// 		ILD_FOCUS  	Draws the image, blending 25 percent with the
		/// 				system highlight color. This value has no effect if the
		/// 				image list does not contain a mask.
		/// 		ILD_BLEND50,
		/// 		ILD_SELECTED,
		/// 		ILD_BLEND  	Draws the image, blending 50 percent with the
		/// 				system highlight color. This value has no effect if the
		/// 				image list does not contain a mask.
		/// 		ILD_MASK  	Draws the mask.
		/// 		ILD_NORMAL  	Draws the image using the background color for the
		/// 				image list. If the background color is the CLR_NONE
		/// 				value, the image is drawn transparently using the mask.
		/// 		ILD_TRANSPARENT  Draws the image transparently using the mask, regardless
		/// 				of the background color. This value has no effect if the image list
		/// 				does not contain a mask.
		/// 
		/// An overlay image is drawn transparently over the primary image specified in the i parameter.
		/// To specify an overlay image in the fStyle parameter, use the INDEXTOOVERLAYMASK macro to
		/// shift the one-based index of the overlay image. Use the OR operator to logically combine the return
		/// value of the macro with the drawing style flags specified in the fStyle parameter.
		/// You must first specify this image as an overlay image by using the ImageList_SetOverlayImage function.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <returns></returns>
		public static SalBoolean ImageList_Draw(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			uint _param6 = (uint)param6;


			retVal = COMCTL32.ImageList_Draw(_param1, _param2, _param3, _param4, _param5, _param6);

			return retVal;
		}
		
		/// <summary>
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <param name="param4"></param>
		/// <param name="param5"></param>
		/// <param name="param6"></param>
		/// <param name="param7"></param>
		/// <param name="param8"></param>
		/// <param name="param9"></param>
		/// <param name="param10"></param>
		/// <returns></returns>
		public static SalBoolean ImageList_DrawEx(SalNumber param1, SalNumber param2, SalNumber param3, SalNumber param4, SalNumber param5, SalNumber param6, SalNumber param7, SalNumber param8, SalNumber param9, SalNumber param10)
		{
			SalBoolean retVal = false;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;
			int _param4 = (int)param4;
			int _param5 = (int)param5;
			int _param6 = (int)param6;
			int _param7 = (int)param7;
			int _param8 = (int)param8;
			int _param9 = (int)param9;
			uint _param10 = (uint)param10;


			retVal = COMCTL32.ImageList_DrawEx(_param1, _param2, _param3, _param4, _param5, _param6, _param7, _param8, _param9, _param10);

			return retVal;
		}
		
		/// <summary>
		/// Retrieves the current background color for an image list.
		/// 
		/// The return value is the background color.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber ImageList_GetBkColor(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = COMCTL32.ImageList_GetBkColor(_param1);

			return retVal;
		}
		
		/// <summary>
		/// Retrieves the number of images in an image list.
		/// 
		/// Returns the number of images.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalNumber ImageList_GetImageCount(SalNumber param1)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;


			retVal = COMCTL32.ImageList_GetImageCount(_param1);

			return retVal;
		}
		
		/// <summary>
		/// Replaces an image with an icon or cursor.
		/// 
		/// Returns the index of the image if successful, or -1 otherwise.
		/// 
		/// Parameters:
		/// 	himl 	Handle to the image list.
		/// 	i 	Index of the image to replace. If i is -1, the function appends the image
		/// 		to the end of the list.
		/// 	hicon 	Handle to the icon or cursor that contains the bitmap and mask for the
		/// 		new image.
		/// 
		/// Because the system does not save hicon, you can destroy it after the function returns
		/// if the icon or cursor was created by theCreateIcon function. You do not need to destroy
		/// hicon if it was loaded by theLoadIcon function; the system automatically frees an icon
		/// resource when it is no longer needed.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <param name="param3"></param>
		/// <returns></returns>
		public static SalNumber ImageList_ReplaceIcon(SalNumber param1, SalNumber param2, SalNumber param3)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;
			uint _param3 = (uint)param3;


			retVal = COMCTL32.ImageList_ReplaceIcon(_param1, _param2, _param3);

			return retVal;
		}
		
		/// <summary>
		/// Sets the background color for an image list.
		/// 
		/// Returns the previous background color if successful, or CLR_NONE otherwise.
		/// </summary>
		/// <param name="param1"></param>
		/// <param name="param2"></param>
		/// <returns></returns>
		public static SalNumber ImageList_SetBkColor(SalNumber param1, SalNumber param2)
		{
			SalNumber retVal = 0;
			uint _param1 = (uint)param1;
			int _param2 = (int)param2;


			retVal = COMCTL32.ImageList_SetBkColor(_param1, _param2);

			return retVal;
		}
		
		/// <summary>
		/// The TrackMouseEvent function posts messages when the mouse pointer leaves a window or
		/// hovers over a window for a specified amount of time.
		/// 
		/// Parameters:
		/// lpEventTrack 	[in/out] Pointer to a TRACKMOUSEEVENT structure that contains tracking information.
		/// 
		/// Return Values:
		/// If the function succeeds, the return value is nonzero .
		/// If the function fails, return value is zero. To get extended error information, call GetLastError.
		/// 
		/// The function can post the following messages.
		/// Message 			Meaning
		/// WM_NCMOUSEHOVER 	Windows 98, Windows 2000: The same meaning as WM_MOUSEHOVER except this is for the
		/// 			nonclient area of the window.
		/// WM_NCMOUSELEAVE 	Windows 98, Windows 2000: The same meaning as WM_MOUSELEAVE except this is for the
		/// 			nonclient area of the window.
		/// WM_MOUSEHOVER 	The mouse hovered over the client area of the window for the period of time specified in a prior call to
		/// 			TrackMouseEvent. Hover tracking stops when this message is generated. The application must call
		/// 			TrackMouseEvent again if it requires further tracking of mouse hover behavior.
		/// WM_MOUSELEAVE 	The mouse left the client area of the window specified in a prior call to TrackMouseEvent.
		/// 			All tracking requested by TrackMouseEvent is canceled when this message is generated.
		/// 			The application must call TrackMouseEvent when the mouse reenters its window if it requires further
		/// 			tracking of mouse hover behavior.
		/// 
		/// Remarks:
		/// The mouse pointer is considered to be hovering when it stays within a specified rectangle for a specified period of time.
		/// Call SystemParametersInfo and use the values SPI_GETMOUSEHOVERWIDTH, SPI_GETMOUSEHOVERHEIGHT,
		/// and SPI_GETMOUSEHOVERTIME to retrieve the size of the rectangle and the time.
		/// 
		/// Note  The _TrackMouseEvent function calls TrackMouseEvent if it exists, otherwise _TrackMouseEvent emulates TrackMouseEvent.
		/// The _TrackMouseEvent function is in commctrl.h and is exported by COMCTRL32.DLL.
		/// </summary>
		/// <param name="param1"></param>
		/// <returns></returns>
		public static SalBoolean _TrackMouseEvent(SalNumber param1, SalNumber param2, SalWindowHandle param3, SalNumber param4)
		{
			SalBoolean retVal = false;

			Structures.STRUCT_13 _struct1 = new Structures.STRUCT_13();
			_struct1.Member1 = (uint)param1;
			_struct1.Member2 = (uint)param2;
			_struct1.Member3 = (System.IntPtr)param3;
			_struct1.Member4 = (uint)param4;

			retVal = COMCTL32._TrackMouseEvent(ref _struct1);

			return retVal;
		}
		
		#region odbc32.dll
		
		/// <summary>
		/// Interop declarations for the external module odbc32.dll
		/// </summary>
		private static class ODBC32
		{
			private const string LibraryFileName = "odbc32.dll";
			[DllImport(LibraryFileName, EntryPoint="SQLAllocEnv", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLAllocEnv(System.Text.StringBuilder param1);
			[DllImport(LibraryFileName, EntryPoint="SQLAllocConnect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLAllocConnect(int param1, System.Text.StringBuilder param2);
			[DllImport(LibraryFileName, EntryPoint="SQLFreeEnv", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLFreeEnv(int param1);
			[DllImport(LibraryFileName, EntryPoint="SQLFreeConnect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLFreeConnect(int param1);
			[DllImport(LibraryFileName, EntryPoint="SQLConnect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLConnect(int param1, string param2, short param3, string param4, short param5, string param6, short param7);
			[DllImport(LibraryFileName, EntryPoint="SQLDisconnect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLDisconnect(int param1);
			[DllImport(LibraryFileName, EntryPoint="SQLError", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short SQLError(int param1, int param2, int param3, System.Text.StringBuilder param4, ref uint param5, System.Text.StringBuilder param6, short param7, ref short param8);
		}
		#endregion
		
		#region shell32.dll
		
		/// <summary>
		/// Interop declarations for the external module shell32.dll
		/// </summary>
		private static class SHELL32
		{
			private const string LibraryFileName = "shell32.dll";
			[DllImport(LibraryFileName, EntryPoint="ShellExecuteA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr ShellExecuteA(System.IntPtr param1, string param2, string param3, string param4, string param5, int param6);
			[DllImport(LibraryFileName, EntryPoint="FindExecutableA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int FindExecutableA(string param1, string param2, System.Text.StringBuilder param3);
			[DllImport(LibraryFileName, EntryPoint="Shell_NotifyIconA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool Shell_NotifyIconA(uint param1, ref Structures.STRUCT_11 param2);
			[DllImport(LibraryFileName, EntryPoint="SHFileOperation", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SHFileOperation(string param1);
		}
		#endregion
		
		#region user32.dll
		
		/// <summary>
		/// Interop declarations for the external module user32.dll
		/// </summary>
		private static class USER32
		{
			private const string LibraryFileName = "user32.dll";
			[DllImport(LibraryFileName, EntryPoint="SetSysColors", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool SetSysColors(int param1, ref Structures.STRUCT_1 param2, ref Structures.STRUCT_2 param3);
			[DllImport(LibraryFileName, EntryPoint="CreateWindowExA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateWindowExA(uint param1, string param2, string param3, uint param4, int param5, int param6, int param7, int param8, System.IntPtr param9, int param10, uint param11, int param12);
			[DllImport(LibraryFileName, EntryPoint="DestroyWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DestroyWindow(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GetClientRect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetClientRect(System.IntPtr param1, ref Structures.STRUCT_3 param2);
			[DllImport(LibraryFileName, EntryPoint="GetWindowRect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetWindowRect(System.IntPtr param1, ref Structures.STRUCT_3 param2);
			[DllImport(LibraryFileName, EntryPoint="MoveWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool MoveWindow(System.IntPtr param1, int param2, int param3, int param4, int param5, bool param6);
			[DllImport(LibraryFileName, EntryPoint="UnregisterClassA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool UnregisterClassA(string param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="DisableProcessWindowsGhosting", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void DisableProcessWindowsGhosting();
			[DllImport(LibraryFileName, EntryPoint="CharToOemA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int CharToOemA(string param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="OemToCharA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int OemToCharA(string param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="wsprintfA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int wsprintfA(System.Text.StringBuilder param1, string param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="SetWindowPos", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void SetWindowPos(System.IntPtr param1, System.IntPtr param2, int param3, int param4, int param5, int param6, uint param7);
			[DllImport(LibraryFileName, EntryPoint="AppendMenuA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool AppendMenuA(System.IntPtr param1, ushort param2, ushort param3, string param4);
			[DllImport(LibraryFileName, EntryPoint="AppendMenuW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern bool AppendMenuW(System.IntPtr param1, ushort param2, ushort param3, string param4);
			[DllImport(LibraryFileName, EntryPoint="BeginPaint", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint BeginPaint(System.IntPtr param1, System.Text.StringBuilder param2);
			[DllImport(LibraryFileName, EntryPoint="CallNextHookEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CallNextHookEx(uint param1, int param2, uint param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="ChangeMenuA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ChangeMenuA(System.IntPtr param1, ushort param2, string param3, ushort param4, ushort param5);
			[DllImport(LibraryFileName, EntryPoint="ChildWindowFromPointEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr ChildWindowFromPointEx(System.IntPtr param1, int param2, int param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="CheckMenuItem", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool CheckMenuItem(System.IntPtr param1, ushort param2, ushort param3);
			[DllImport(LibraryFileName, EntryPoint="ClientToScreen", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void ClientToScreen(System.IntPtr param1, ref Structures.STRUCT_8 param2);
			[DllImport(LibraryFileName, EntryPoint="CloseClipboard", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool CloseClipboard();
			[DllImport(LibraryFileName, EntryPoint="CopyIcon", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CopyIcon(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="CreateMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateMenu();
			[DllImport(LibraryFileName, EntryPoint="CreatePopupMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreatePopupMenu();
			[DllImport(LibraryFileName, EntryPoint="DefWindowProcA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int DefWindowProcA(System.IntPtr param1, ushort param2, ushort param3, int param4);
			[DllImport(LibraryFileName, EntryPoint="DeleteMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DeleteMenu(System.IntPtr param1, uint param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="DestroyMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DestroyMenu(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="DestroyIcon", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DestroyIcon(uint param1);
			[DllImport(LibraryFileName, EntryPoint="DispatchMessageA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int DispatchMessageA(System.Text.StringBuilder param1);
			[DllImport(LibraryFileName, EntryPoint="DragDetect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DragDetect(System.IntPtr param1, ref Structures.STRUCT_8 param2);
			[DllImport(LibraryFileName, EntryPoint="DrawEdge", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DrawEdge(int param1, ref Structures.STRUCT_3 param2, uint param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="DrawFocusRect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DrawFocusRect(uint param1, ref Structures.STRUCT_3 param2);
			[DllImport(LibraryFileName, EntryPoint="DrawFrameControl", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DrawFrameControl(int param1, ref Structures.STRUCT_3 param2, uint param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="DrawMenuBar", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DrawMenuBar(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="DrawTextA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int DrawTextA(uint param1, string param2, int param3, ref Structures.STRUCT_3 param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="EmptyClipboard", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool EmptyClipboard();
			[DllImport(LibraryFileName, EntryPoint="EnableMenuItem", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort EnableMenuItem(System.IntPtr param1, ushort param2, ushort param3);
			[DllImport(LibraryFileName, EntryPoint="EndPaint", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void EndPaint(System.IntPtr param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="ExitWindowsEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ExitWindowsEx(uint param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="FillRect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int FillRect(uint param1, ref Structures.STRUCT_3 param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="FindWindowA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr FindWindowA(string param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="GetActiveWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetActiveWindow();
			[DllImport(LibraryFileName, EntryPoint="GetAsyncKeyState", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short GetAsyncKeyState(int param1);
			[DllImport(LibraryFileName, EntryPoint="GetClassNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetClassNameA(System.IntPtr param1, System.Text.StringBuilder param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="GetClipboardData", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort GetClipboardData(ushort param1);
			[DllImport(LibraryFileName, EntryPoint="GetCursor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetCursor();
			[DllImport(LibraryFileName, EntryPoint="GetCursorPos", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void GetCursorPos(ref Structures.STRUCT_8 param1);
			[DllImport(LibraryFileName, EntryPoint="GetDC", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetDC(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GetDesktopWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetDesktopWindow();
			[DllImport(LibraryFileName, EntryPoint="GetDlgItem", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetDlgItem(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="GetForegroundWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetForegroundWindow();
			[DllImport(LibraryFileName, EntryPoint="GetKeyState", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern short GetKeyState(int param1);
			[DllImport(LibraryFileName, EntryPoint="GetMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetMenu(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GetMenuItemCount", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort GetMenuItemCount(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GetMenuItemID", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort GetMenuItemID(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="GetMenuCheckMarkDimensions", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetMenuCheckMarkDimensions();
			[DllImport(LibraryFileName, EntryPoint="GetMenuState", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort GetMenuState(System.IntPtr param1, ushort param2, ushort param3);
			[DllImport(LibraryFileName, EntryPoint="GetMenuStringA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetMenuStringA(System.IntPtr param1, ushort param2, System.Text.StringBuilder param3, int param4, ushort param5);
			[DllImport(LibraryFileName, EntryPoint="#312", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetNextWindow(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="GetParent", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetParent(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GetScrollInfo", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetScrollInfo(System.IntPtr param1, int param2, ref Structures.STRUCT_12 param3);
			[DllImport(LibraryFileName, EntryPoint="GetSubMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetSubMenu(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="GetSysColor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetSysColor(int param1);
			[DllImport(LibraryFileName, EntryPoint="GetSystemMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetSystemMenu(System.IntPtr param1, bool param2);
			[DllImport(LibraryFileName, EntryPoint="GetSystemMetrics", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetSystemMetrics(int param1);
			[DllImport(LibraryFileName, EntryPoint="GetWindowLongA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetWindowLongA(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="GetWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr GetWindow(System.IntPtr param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="GetWindowDC", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetWindowDC(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GetWindowTextA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetWindowTextA(System.IntPtr param1, string param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="GetWindowWord", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort GetWindowWord(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="HiliteMenuItem", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool HiliteMenuItem(System.IntPtr param1, System.IntPtr param2, ushort param3, ushort param4);
			[DllImport(LibraryFileName, EntryPoint="IsIconic", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool IsIconic(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="IsWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool IsWindow(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="IsWindowEnabled", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool IsWindowEnabled(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="InsertMenuA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool InsertMenuA(System.IntPtr param1, ushort param2, ushort param3, ushort param4, string param5);
			[DllImport(LibraryFileName, EntryPoint="#359", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint LoadCursorA(int param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="LoadCursorFromFileA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr LoadCursorFromFileA(string param1);
			[DllImport(LibraryFileName, EntryPoint="LoadIconA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint LoadIconA(uint param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="LoadImageA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint LoadImageA(uint param1, string param2, uint param3, int param4, int param5, uint param6);
			[DllImport(LibraryFileName, EntryPoint="ModifyMenuA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ModifyMenuA(System.IntPtr param1, int param2, int param3, int param4, string param5);
			[DllImport(LibraryFileName, EntryPoint="OpenClipboard", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool OpenClipboard(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="PeekMessageA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool PeekMessageA(System.Text.StringBuilder param1, System.IntPtr param2, uint param3, uint param4, uint param5);
			[DllImport(LibraryFileName, EntryPoint="RedrawWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool RedrawWindow(System.IntPtr param1, ref Structures.STRUCT_3 param2, int param3, ushort param4);
			[DllImport(LibraryFileName, EntryPoint="RegisterHotKey", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool RegisterHotKey(System.IntPtr param1, int param2, uint param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="ReleaseCapture", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ReleaseCapture();
			[DllImport(LibraryFileName, EntryPoint="ReleaseDC", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ReleaseDC(System.IntPtr param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="RemoveMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool RemoveMenu(System.IntPtr param1, ushort param2, ushort param3);
			[DllImport(LibraryFileName, EntryPoint="ScreenToClient", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ScreenToClient(System.IntPtr param1, ref Structures.STRUCT_8 param2);
			[DllImport(LibraryFileName, EntryPoint="ShowScrollBar", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void ShowScrollBar(System.IntPtr param1, int param2, bool param3);
			[DllImport(LibraryFileName, EntryPoint="SendMessageTimeoutA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SendMessageTimeoutA(System.IntPtr param1, uint param2, int param3, System.Text.StringBuilder param4, uint param5, uint param6, ref int param7);
			[DllImport(LibraryFileName, EntryPoint="SetActiveWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr SetActiveWindow(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="SetCapture", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr SetCapture(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="SetClipboardData", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort SetClipboardData(ushort param1, ushort param2);
			[DllImport(LibraryFileName, EntryPoint="SetCursor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint SetCursor(uint param1);
			[DllImport(LibraryFileName, EntryPoint="SetForegroundWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool SetForegroundWindow(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="SetMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool SetMenu(System.IntPtr param1, System.IntPtr param2);
			[DllImport(LibraryFileName, EntryPoint="SetMenuDefaultItem", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void SetMenuDefaultItem(System.IntPtr param1, uint param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="SetParent", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr SetParent(System.IntPtr param1, System.IntPtr param2);
			[DllImport(LibraryFileName, EntryPoint="SetScrollInfo", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SetScrollInfo(System.IntPtr param1, int param2, ref Structures.STRUCT_12 param3, bool param4);
			[DllImport(LibraryFileName, EntryPoint="SetSystemCursor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool SetSystemCursor(System.IntPtr param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="SetWindowLongA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SetWindowLongA(System.IntPtr param1, int param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="SetWindowRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void SetWindowRgn(System.IntPtr param1, System.IntPtr param2, bool param3);
			[DllImport(LibraryFileName, EntryPoint="SetWindowTextA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool SetWindowTextA(System.IntPtr param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="SetWindowsHookExA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint SetWindowsHookExA(int param1, uint param2, uint param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="ShowCaret", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ShowCaret(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="ShowCursor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ShowCursor(bool param1);
			[DllImport(LibraryFileName, EntryPoint="ShowWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ShowWindow(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="TrackPopupMenu", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool TrackPopupMenu(System.IntPtr param1, uint param2, int param3, int param4, int param5, System.IntPtr param6, string param7);
			[DllImport(LibraryFileName, EntryPoint="TranslateMessage", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool TranslateMessage(System.Text.StringBuilder param1);
			[DllImport(LibraryFileName, EntryPoint="UnhookWindowsHookEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool UnhookWindowsHookEx(uint param1);
			[DllImport(LibraryFileName, EntryPoint="UnregisterHotKey", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool UnregisterHotKey(System.IntPtr param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="ValidateRect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ValidateRect(System.IntPtr param1, int param2, int param3, int param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="ValidateRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ValidateRgn(System.IntPtr param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="WindowFromPoint", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr WindowFromPoint(int param1, int param2);
		}
		#endregion
		
		/// <summary>
		/// External functions structure declarations.
		/// </summary>
		private class Structures
		{
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_1
			{
				public Int32 Member1;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_2
			{
				public UInt32 Member1;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_3
			{
				public Int32 Member1;
				public Int32 Member2;
				public Int32 Member3;
				public Int32 Member4;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_4
			{
				public UInt32 Member1;
				public UInt32 Member2;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_5
			{
				public UInt32 Member1;
				public UInt16 Member2;
				public UInt16 Member3;
				[MarshalAs(UnmanagedType.ByValTStr, SizeConst=8)]
				public String Member4;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_6
			{
				[MarshalAs(UnmanagedType.ByValTStr, SizeConst=255)]
				public StringBuilder Member1;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_7
			{
				public UInt16 Member1;
				public UInt16 Member2;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_8
			{
				public Int32 Member1;
				public Int32 Member2;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_9
			{
				public UInt32 Member1;
				public UInt32 Member2;
				public UInt32 Member3;
				public UInt32 Member4;
				public UInt32 Member5;
				[MarshalAs(UnmanagedType.ByValTStr, SizeConst=128)]
				public StringBuilder Member6;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_10
			{
				public UInt32 Member1;
				public UInt32 Member2;
				public UInt32 Member3;
				public UInt32 Member4;
				public UInt32 Member5;
				public UInt32 Member6;
				public UInt32 Member7;
				public UInt32 Member8;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_11
			{
				public UInt32 Member1;
				public IntPtr Member2;
				public UInt32 Member3;
				public UInt32 Member4;
				public UInt32 Member5;
				public UInt32 Member6;
				[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
				public String Member7;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_12
			{
				public UInt32 Member1;
				public UInt32 Member2;
				public Int32 Member3;
				public Int32 Member4;
				public UInt32 Member5;
				public Int32 Member6;
				public Int32 Member7;
			}
			
			[StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
			public struct STRUCT_13
			{
				public UInt32 Member1;
				public UInt32 Member2;
				public IntPtr Member3;
				public UInt32 Member4;
			}
		}
		
		#region atl.dll
		
		/// <summary>
		/// Interop declarations for the external module atl.dll
		/// </summary>
		private static class ATL
		{
			private const string LibraryFileName = "atl.dll";
			[DllImport(LibraryFileName, EntryPoint="AtlAxWinInit", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool AtlAxWinInit();
			[DllImport(LibraryFileName, EntryPoint="AtlAxCreateControl", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int AtlAxCreateControl(string param1, System.IntPtr param2, int param3, ref int param4);
		}
		#endregion
		
		#region kernel32.dll
		
		/// <summary>
		/// Interop declarations for the external module kernel32.dll
		/// </summary>
		private static class KERNEL32
		{
			private const string LibraryFileName = "kernel32.dll";
			[DllImport(LibraryFileName, EntryPoint="GetComputerNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetComputerNameA(System.Text.StringBuilder param1, ref uint param2);
			[DllImport(LibraryFileName, EntryPoint="AddAtomA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int AddAtomA(string param1);
			[DllImport(LibraryFileName, EntryPoint="CopyFileA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool CopyFileA(string param1, string param2, bool param3);
			[DllImport(LibraryFileName, EntryPoint="DeleteAtom", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int DeleteAtom(int param1);
			[DllImport(LibraryFileName, EntryPoint="DeleteFileA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DeleteFileA(string param1);
			[DllImport(LibraryFileName, EntryPoint="ExitProcess", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void ExitProcess(uint param1);
			[DllImport(LibraryFileName, EntryPoint="FindClose", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool FindClose(uint param1);
			[DllImport(LibraryFileName, EntryPoint="FindFirstFileA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint FindFirstFileA(string param1, System.Text.StringBuilder param2);
			[DllImport(LibraryFileName, EntryPoint="FreeLibrary", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint FreeLibrary(uint param1);
			[DllImport(LibraryFileName, EntryPoint="GetCurrentDirectoryA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetCurrentDirectoryA(uint param1, System.Text.StringBuilder param2);
			[DllImport(LibraryFileName, EntryPoint="GetCurrentProcess", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetCurrentProcess();
			[DllImport(LibraryFileName, EntryPoint="GetCurrentThreadId", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetCurrentThreadId();
			[DllImport(LibraryFileName, EntryPoint="GetDiskFreeSpaceA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetDiskFreeSpaceA(string param1, ref uint param2, ref uint param3, ref uint param4, ref uint param5);
			[DllImport(LibraryFileName, EntryPoint="GetDriveTypeA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetDriveTypeA(string param1);
			[DllImport(LibraryFileName, EntryPoint="GetEnvironmentVariableA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetEnvironmentVariableA(string param1, System.Text.StringBuilder param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="GetExitCodeProcess", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetExitCodeProcess(uint param1, ref int param2);
			[DllImport(LibraryFileName, EntryPoint="GetFileAttributesA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetFileAttributesA(string param1);
			[DllImport(LibraryFileName, EntryPoint="GetFullPathNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetFullPathNameA(string param1, uint param2, System.Text.StringBuilder param3, System.Text.StringBuilder param4);
			[DllImport(LibraryFileName, EntryPoint="GetLastError", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetLastError();
			[DllImport(LibraryFileName, EntryPoint="GetModuleFileNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetModuleFileNameA(int param1, System.Text.StringBuilder param2, ushort param3);
			[DllImport(LibraryFileName, EntryPoint="GetModuleHandleA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetModuleHandleA(string param1);
			[DllImport(LibraryFileName, EntryPoint="GetProcAddress", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetProcAddress(uint param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="GetProcessHeap", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetProcessHeap();
			[DllImport(LibraryFileName, EntryPoint="GetShortPathNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetShortPathNameA(string param1, System.Text.StringBuilder param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="GetSystemDirectoryA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetSystemDirectoryA(System.Text.StringBuilder param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="GetTempFileNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetTempFileNameA(string param1, string param2, uint param3, System.Text.StringBuilder param4);
			[DllImport(LibraryFileName, EntryPoint="GetTempPathA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetTempPathA(uint param1, System.Text.StringBuilder param2);
			[DllImport(LibraryFileName, EntryPoint="GetTickCount", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetTickCount();
			[DllImport(LibraryFileName, EntryPoint="GetVersionExA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetVersionExA(ref Structures.STRUCT_9 param1);
			[DllImport(LibraryFileName, EntryPoint="GetWindowsDirectoryA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetWindowsDirectoryA(System.Text.StringBuilder param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="GlobalAddAtomA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GlobalAddAtomA(string param1);
			[DllImport(LibraryFileName, EntryPoint="GlobalAlloc", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GlobalAlloc(uint param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="GlobalDeleteAtom", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GlobalDeleteAtom(int param1);
			[DllImport(LibraryFileName, EntryPoint="GlobalFree", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GlobalFree(uint param1);
			[DllImport(LibraryFileName, EntryPoint="GlobalGetAtomNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GlobalGetAtomNameA(int param1, System.Text.StringBuilder param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="GlobalLock", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GlobalLock(ushort param1);
			[DllImport(LibraryFileName, EntryPoint="GlobalMemoryStatus", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void GlobalMemoryStatus(ref Structures.STRUCT_10 param1);
			[DllImport(LibraryFileName, EntryPoint="GlobalSize", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GlobalSize(System.IntPtr param1);
			[DllImport(LibraryFileName, EntryPoint="GlobalUnlock", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GlobalUnlock(ushort param1);
			[DllImport(LibraryFileName, EntryPoint="HeapAlloc", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int HeapAlloc(uint param1, uint param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="HeapFree", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool HeapFree(uint param1, uint param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="LoadLibraryA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint LoadLibraryA(string param1);
			[DllImport(LibraryFileName, EntryPoint="#45", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr LoadModule(string param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="MoveFileA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool MoveFileA(string param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="OpenProcess", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint OpenProcess(uint param1, bool param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="TerminateProcess", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool TerminateProcess(uint param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="Sleep", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void Sleep(uint param1);
			[DllImport(LibraryFileName, EntryPoint="WinExec", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint WinExec(string param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="RtlZeroMemory", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void RtlZeroMemory(int param1, uint param2);
		}
		#endregion
		
		#region advapi32.dll
		
		/// <summary>
		/// Interop declarations for the external module advapi32.dll
		/// </summary>
		private static class ADVAPI32
		{
			private const string LibraryFileName = "advapi32.dll";
			[DllImport(LibraryFileName, EntryPoint="GetUserNameA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetUserNameA(System.Text.StringBuilder param1, ref uint param2);
			[DllImport(LibraryFileName, EntryPoint="RegCloseKey", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int RegCloseKey(int param1);
			[DllImport(LibraryFileName, EntryPoint="RegCreateKeyExA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegCreateKeyExA(int param1, string param2, uint param3, string param4, uint param5, uint param6, string param7, ref int param8, ref int param9);
			[DllImport(LibraryFileName, EntryPoint="RegEnumKeyExA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegEnumKeyExA(int param1, uint param2, string param3, ref uint param4, string param5, string param6, ref uint param7, ref Structures.STRUCT_4 param8);
			[DllImport(LibraryFileName, EntryPoint="RegEnumKeyExW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegEnumKeyExW(int param1, uint param2, string param3, ref uint param4, string param5, string param6, ref uint param7, ref Structures.STRUCT_4 param8);
			[DllImport(LibraryFileName, EntryPoint="RegEnumValueA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegEnumValueA(int param1, uint param2, string param3, ref uint param4, string param5, ref uint param6, string param7, ref uint param8);
			[DllImport(LibraryFileName, EntryPoint="RegEnumValueW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegEnumValueW(int param1, uint param2, string param3, ref uint param4, string param5, ref uint param6, string param7, ref uint param8);
			[DllImport(LibraryFileName, EntryPoint="RegFlushKey", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int RegFlushKey(int param1);
			[DllImport(LibraryFileName, EntryPoint="RegOpenKeyExA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegOpenKeyExA(int param1, string param2, uint param3, uint param4, ref int param5);
			[DllImport(LibraryFileName, EntryPoint="RegOpenKeyExW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegOpenKeyExW(int param1, string param2, uint param3, uint param4, ref int param5);
			[DllImport(LibraryFileName, EntryPoint="RegQueryInfoKeyA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegQueryInfoKeyA(int param1, string param2, ref uint param3, string param4, ref uint param5, ref uint param6, ref uint param7, ref uint param8, ref uint param9, ref uint param10, ref uint param11, ref Structures.STRUCT_4 param12);
			[DllImport(LibraryFileName, EntryPoint="RegQueryInfoKeyW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegQueryInfoKeyW(int param1, string param2, ref uint param3, string param4, ref uint param5, ref uint param6, ref uint param7, ref uint param8, ref uint param9, ref uint param10, ref uint param11, ref Structures.STRUCT_4 param12);
			[DllImport(LibraryFileName, EntryPoint="RegQueryValueExA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegQueryValueExA(int param1, string param2, string param3, ref uint param4, System.Text.StringBuilder param5, ref uint param6);
			[DllImport(LibraryFileName, EntryPoint="RegQueryValueExW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegQueryValueExW(int param1, string param2, string param3, ref uint param4, System.Text.StringBuilder param5, ref uint param6);
			[DllImport(LibraryFileName, EntryPoint="RegSetValueExA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegSetValueExA(int param1, string param2, uint param3, uint param4, string param5, uint param6);
			[DllImport(LibraryFileName, EntryPoint="RegSetValueExW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegSetValueExW(int param1, string param2, uint param3, uint param4, string param5, uint param6);
			[DllImport(LibraryFileName, EntryPoint="RegDeleteKeyA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegDeleteKeyA(int param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="RegDeleteKeyW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegDeleteKeyW(int param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="RegDeleteValueA", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegDeleteValueA(int param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="RegDeleteValueW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegDeleteValueW(int param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="RegCreateKeyExW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int RegCreateKeyExW(int param1, string param2, uint param3, string param4, uint param5, uint param6, string param7, ref int param8, ref int param9);
		}
		#endregion
		
		#region ole32.dll
		
		/// <summary>
		/// Interop declarations for the external module ole32.dll
		/// </summary>
		private static class OLE32
		{
			private const string LibraryFileName = "ole32.dll";
			[DllImport(LibraryFileName, EntryPoint="StringFromGUID2", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int StringFromGUID2(ref Structures.STRUCT_5 param1, ref Structures.STRUCT_6 param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="CoCreateGuid", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int CoCreateGuid(System.Text.StringBuilder param1);
		}
		#endregion
		
		#region salmail62.dll
		
		/// <summary>
		/// Interop declarations for the external module salmail62.dll
		/// </summary>
		private static class SALMAIL62
		{
			private const string LibraryFileName = "salmail62.dll";
			[DllImport(LibraryFileName, EntryPoint="#1", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int SmtpConnect(string param1, int param2, string param3, string param4, bool param5, ref uint param6);
			[DllImport(LibraryFileName, EntryPoint="#2", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int Pop3Connect(string param1, int param2, string param3, string param4, bool param5, ref uint param6);
			[DllImport(LibraryFileName, EntryPoint="#3", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int MailDisconnectEx(uint param1);
			[DllImport(LibraryFileName, EntryPoint="#4", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int SmtpSendMail(uint param1, byte param2, string param3, string param4, string param5, string param6, string param7, string param8, bool param9, byte param10);
			[DllImport(LibraryFileName, EntryPoint="#5", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int Pop3DeleteMail(uint param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="#8", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint Pop3GetNumberMessages(uint param1);
			[DllImport(LibraryFileName, EntryPoint="#10", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
			internal static extern int IMAPConnect(string param1, int param2, string param3, string param4, bool param5);
			[DllImport(LibraryFileName, EntryPoint="#11", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int IMAPDeleteMail(uint param1);
			[DllImport(LibraryFileName, EntryPoint="#14", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint IMAPGetNumberMessages();
		}
		#endregion
		
		#region gdi32.dll
		
		/// <summary>
		/// Interop declarations for the external module gdi32.dll
		/// </summary>
		private static class GDI32
		{
			private const string LibraryFileName = "gdi32.dll";
			[DllImport(LibraryFileName, EntryPoint="BitBlt", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool BitBlt(uint param1, int param2, int param3, int param4, int param5, uint param6, int param7, int param8, uint param9);
			[DllImport(LibraryFileName, EntryPoint="CombineRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void CombineRgn(System.IntPtr param1, System.IntPtr param2, System.IntPtr param3, int param4);
			[DllImport(LibraryFileName, EntryPoint="CreateBitmap", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateBitmap(int param1, int param2, uint param3, uint param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="CreateCompatibleBitmap", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateCompatibleBitmap(uint param1, int param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="CreateCompatibleDC", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateCompatibleDC(uint param1);
			[DllImport(LibraryFileName, EntryPoint="CreateEllipticRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateEllipticRgn(int param1, int param2, int param3, int param4);
			[DllImport(LibraryFileName, EntryPoint="CreateFontA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateFontA(int param1, int param2, int param3, int param4, int param5, byte param6, byte param7, byte param8, byte param9, byte param10, byte param11, byte param12, byte param13, string param14);
			[DllImport(LibraryFileName, EntryPoint="CreateHalftonePalette", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateHalftonePalette(uint param1);
			[DllImport(LibraryFileName, EntryPoint="CreateHatchBrush", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateHatchBrush(int param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="CreatePalette", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreatePalette(ref Structures.STRUCT_7 param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="CreatePen", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreatePen(int param1, int param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="CreatePolygonRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreatePolygonRgn(string param1, int param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="CreateRectRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateRectRgn(int param1, int param2, int param3, int param4);
			[DllImport(LibraryFileName, EntryPoint="CreateRoundRectRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateRoundRectRgn(int param1, int param2, int param3, int param4, int param5, int param6);
			[DllImport(LibraryFileName, EntryPoint="CreateSolidBrush", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint CreateSolidBrush(int param1);
			[DllImport(LibraryFileName, EntryPoint="DeleteDC", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DeleteDC(uint param1);
			[DllImport(LibraryFileName, EntryPoint="DeleteObject", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DeleteObject(uint param1);
			[DllImport(LibraryFileName, EntryPoint="DPtoLP", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool DPtoLP(uint param1, ref Structures.STRUCT_8 param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="Ellipse", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool Ellipse(uint param1, int param2, int param3, int param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="ExcludeClipRect", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ExcludeClipRect(uint param1, int param2, int param3, int param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="ExtTextOutA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ExtTextOutA(uint param1, int param2, int param3, uint param4, string param5, string param6, ushort param7, uint param8);
			[DllImport(LibraryFileName, EntryPoint="FrameRgn", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void FrameRgn(uint param1, System.IntPtr param2, uint param3, int param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="GetBitmapDimensionEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetBitmapDimensionEx(System.IntPtr param1, ref Structures.STRUCT_8 param2);
			[DllImport(LibraryFileName, EntryPoint="GetDeviceCaps", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetDeviceCaps(uint param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="GetPixel", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetPixel(uint param1, int param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="GetObjectA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetObjectA(uint param1, int param2, System.Text.StringBuilder param3);
			[DllImport(LibraryFileName, EntryPoint="GetStockObject", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetStockObject(int param1);
			[DllImport(LibraryFileName, EntryPoint="GetTextExtentPoint32A", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetTextExtentPoint32A(uint param1, string param2, int param3, ref Structures.STRUCT_8 param4);
			[DllImport(LibraryFileName, EntryPoint="GetTextFaceA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int GetTextFaceA(ushort param1, ushort param2, string param3);
			[DllImport(LibraryFileName, EntryPoint="GetTextMetricsA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetTextMetricsA(ushort param1, string param2);
			[DllImport(LibraryFileName, EntryPoint="LineTo", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool LineTo(int param1, int param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="MoveToEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort MoveToEx(int param1, int param2, int param3, int param4);
			[DllImport(LibraryFileName, EntryPoint="PatBlt", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool PatBlt(uint param1, int param2, int param3, int param4, int param5, uint param6);
			[DllImport(LibraryFileName, EntryPoint="Rectangle", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool Rectangle(int param1, int param2, int param3, int param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="RectInRegion", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool RectInRegion(System.IntPtr param1, ref Structures.STRUCT_3 param2);
			[DllImport(LibraryFileName, EntryPoint="SelectObject", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SelectObject(uint param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="#374", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SetBkColor(ushort param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="SetBkMode", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SetBkMode(uint param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="#405", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern ushort SetTextAlign(ushort param1, ushort param2);
			[DllImport(LibraryFileName, EntryPoint="SetTextColor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SetTextColor(uint param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="SetStretchBltMode", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int SetStretchBltMode(uint param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="TextOutA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool TextOutA(ushort param1, int param2, int param3, string param4, ushort param5);
			[DllImport(LibraryFileName, EntryPoint="CreateDCA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int CreateDCA(string param1, string param2, string param3, int param4);
		}
		#endregion
		
		#region version.dll
		
		/// <summary>
		/// Interop declarations for the external module version.dll
		/// </summary>
		private static class VERSION
		{
			private const string LibraryFileName = "version.dll";
			[DllImport(LibraryFileName, EntryPoint="GetFileVersionInfoA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool GetFileVersionInfoA(string param1, uint param2, uint param3, int param4);
			[DllImport(LibraryFileName, EntryPoint="GetFileVersionInfoSizeA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint GetFileVersionInfoSizeA(string param1, ref uint param2);
			[DllImport(LibraryFileName, EntryPoint="VerQueryValueA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool VerQueryValueA(int param1, string param2, System.Text.StringBuilder param3, ref uint param4);
		}
		#endregion
		
		#region winmm.dll
		
		/// <summary>
		/// Interop declarations for the external module winmm.dll
		/// </summary>
		private static class WINMM
		{
			private const string LibraryFileName = "winmm.dll";
			[DllImport(LibraryFileName, EntryPoint="sndPlaySoundA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void sndPlaySoundA(string param1, int param2);
		}
		#endregion
		
		#region comctl32.dll
		
		/// <summary>
		/// Interop declarations for the external module comctl32.dll
		/// </summary>
		private static class COMCTL32
		{
			private const string LibraryFileName = "comctl32.dll";
			[DllImport(LibraryFileName, EntryPoint="InitCommonControls", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void InitCommonControls();
			[DllImport(LibraryFileName, EntryPoint="InitCommonControlsEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool InitCommonControlsEx(ref Structures.STRUCT_4 param1);
			[DllImport(LibraryFileName, EntryPoint="CreateStatusWindow", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateStatusWindow(int param1, string param2, System.IntPtr param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="CreateToolbarEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern System.IntPtr CreateToolbarEx(System.IntPtr param1, uint param2, uint param3, int param4, uint param5, uint param6, string param7, int param8, int param9, int param10, int param11, int param12, uint param13);
			[DllImport(LibraryFileName, EntryPoint="DrawStatusText", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern void DrawStatusText(uint param1, ref Structures.STRUCT_3 param2, string param3, uint param4);
			[DllImport(LibraryFileName, EntryPoint="ImageList_Add", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_Add(uint param1, uint param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="ImageList_AddIcon", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_AddIcon(uint param1, uint param2);
			[DllImport(LibraryFileName, EntryPoint="ImageList_AddMasked", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_AddMasked(uint param1, uint param2, int param3);
			[DllImport(LibraryFileName, EntryPoint="ImageList_Create", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern uint ImageList_Create(int param1, int param2, uint param3, int param4, int param5);
			[DllImport(LibraryFileName, EntryPoint="ImageList_Destroy", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ImageList_Destroy(uint param1);
			[DllImport(LibraryFileName, EntryPoint="ImageList_Draw", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ImageList_Draw(uint param1, int param2, uint param3, int param4, int param5, uint param6);
			[DllImport(LibraryFileName, EntryPoint="ImageList_DrawEx", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool ImageList_DrawEx(uint param1, int param2, uint param3, int param4, int param5, int param6, int param7, int param8, int param9, uint param10);
			[DllImport(LibraryFileName, EntryPoint="ImageList_GetBkColor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_GetBkColor(uint param1);
			[DllImport(LibraryFileName, EntryPoint="ImageList_GetImageCount", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_GetImageCount(uint param1);
			[DllImport(LibraryFileName, EntryPoint="ImageList_ReplaceIcon", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_ReplaceIcon(uint param1, int param2, uint param3);
			[DllImport(LibraryFileName, EntryPoint="ImageList_SetBkColor", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern int ImageList_SetBkColor(uint param1, int param2);
			[DllImport(LibraryFileName, EntryPoint="_TrackMouseEvent", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
			internal static extern bool _TrackMouseEvent(ref Structures.STRUCT_13 param1);
		}
		#endregion
	}
}
