// <ppj name="Moveta.Intern" date="1/17/2024 7:59:41 AM" id="F4EC85BAD2BF79AC25C9F8643540E90F9BE1DAF0"/>
// ======================================================================================================
// This code was generated by the Ice Porter(tm) Tool version 4.8.15.0
// Ice Porter is part of The Porting Project (PPJ) by Ice Tea Group, LLC.
// The generated code is not guaranteed to be accurate and to compile without
// manual modifications.
// 
// ICE TEA GROUP LLC SHALL IN NO EVENT BE LIABLE FOR ANY DAMAGES WHATSOEVER
// (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
// INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER LOSS OF ANY KIND)
// ARISING OUT OF THE USE OR INABILITY TO USE THE GENERATED CODE, WHETHER
// DIRECT, INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR OTHERWISE, REGARDLESS
// OF THE FORM OF ACTION, EVEN IF ICE TEA GROUP LLC HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
// =====================================================================================================
using System;
using System.Text;
using System.Drawing;
using System.Diagnostics;
using System.Collections;
using System.Windows.Forms;
using System.ComponentModel;
using MT;
using PPJ.Runtime;
using PPJ.Runtime.Com;
using PPJ.Runtime.Sql;
using PPJ.Runtime.Vis;
using PPJ.Runtime.Windows;
using PPJ.Runtime.Windows.QO;
using PPJ.Runtime.XSal;

namespace Moveta.Intern
{
	
	/// <summary>
	/// This class encapsulates some of the windows registry api's.
	/// You use the routines in the following way:
	/// 
	/// if OpenKey()
	///   ...
	///   Read-/Write-Functions
	///   ...
	///   CloseKey()
	/// </summary>
	public class cBTRegistry : SalFunctionalClass
	{
		#region Fields
		public SalNumber m_RootKey = 0;
		public SalNumber m_CurrentKey = 0;
		public SalNumber m_ErrorCode = 0;
		public SalString m_CurrentPath = "";
		public SalBoolean m_LazyWrite = false;
		#endregion
		
		#region Constructors/Destructors
		#endregion
		
		#region Methods
		// most used functions:
		/// <summary>
		/// Call CloseKey()
		/// Closes the key opened by OpenKey()
		/// </summary>
		/// <returns></returns>
		public SalNumber CloseKey()
		{
			#region Actions
			// if any key was opened then close it
			if (m_CurrentKey != 0) 
			{
				// Laze write means, the changes do not get saved immediately
				if (m_LazyWrite) 
				{
					Ext.RegCloseKey(m_CurrentKey);
				}
				else
				{
					Ext.RegFlushKey(m_CurrentKey);
				}
				m_CurrentKey = 0;
				m_CurrentPath = SalString.Null;
			}
			m_ErrorCode = 0;

			return 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = DeleteKey( sKeyPath )
		/// Deletes a key
		/// sKeyPath	IN	path of the key to be deleted
		/// </summary>
		/// <param name="sKeyPath"></param>
		/// <returns></returns>
		public SalBoolean DeleteKey(SalString sKeyPath)
		{
			#region Local Variables
			SalBoolean Relative = false;
			#endregion
			
			#region Actions
			// Set sKeyPath = __VisStrSubstitute( sKeyPath, '/', '\\' )
			Relative = IsRelativeKey(sKeyPath);
			if (!(Relative)) 
			{
				sKeyPath = StrDelete(sKeyPath, 0, 1);
			}
			return Ext.RegDeleteKeyW(GetBaseKey(Relative), sKeyPath) == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = DeleteValue( sKey )
		/// Deletes a key's value
		/// sKey	IN	key name from which to delete
		/// </summary>
		/// <param name="sKey"></param>
		/// <returns></returns>
		public SalBoolean DeleteValue(SalString sKey)
		{
			#region Local Variables
			SalBoolean Relative = false;
			SalNumber DelKey = 0;
			#endregion
			
			#region Actions
			return Ext.RegDeleteValueW(m_CurrentKey, sKey) == 0;
			#endregion
		}
		
		/// <summary>
		/// bOk = EnumKeys( rsKeys[*] )
		/// fills rsKeys with all the key names residing under the
		/// currently open path
		/// rsKeys[*]	OUT	array of key names
		/// </summary>
		/// <param name="Arr">[*]</param>
		/// <returns></returns>
		public SalBoolean EnumKeys(SalArray<SalString> Arr)
		{
			#region Local Variables
			SalNumber Class = 0;
			SalNumber SubValues = 0;
			SalNumber MaxSubKeyLen = 0;
			SalNumber MaxClassLen = 0;
			SalNumber Values = 0;
			SalNumber MaxValueNameLen = 0;
			SalNumber MaxValueLen = 0;
			SalNumber SecurityDescriptor = 0;
			SalNumber LastWriteTime1 = 0;
			SalNumber LastWriteTime2 = 0;
			SalNumber n = 0;
			SalNumber len = 0;
			SalString s = "";
			#endregion
			
			#region Actions
			// clear return values
			Arr.SetUpperBound(1, -1);
			// retrieve the number of key names under the current path
			m_ErrorCode = Ext.RegQueryInfoKeyW(m_CurrentKey, SalString.Null, ref Class, SalString.Null, ref SubValues, ref MaxSubKeyLen, ref MaxClassLen, ref Values, ref MaxValueNameLen, ref MaxValueLen, ref SecurityDescriptor, ref LastWriteTime1, ref 
				LastWriteTime2);
			if (m_ErrorCode == 0) 
			{
				// loop over each one
				n = 0;
				while (n < SubValues) 
				{
					// v1.1: Set len = MaxSubKeyLen
					// v1.2: must have space for the trailing zero
					// 25.07.12 F1210
					// Set len = MaxSubKeyLen + 1
					len = MaxSubKeyLen * 2 + 2;
					// read the name directly into the return array
					Sal.SetBufferLength(ref Arr.GetArray(n)[n], len);
					Ext.RegEnumKeyExW(m_CurrentKey, n, Arr[n], ref len, SalString.Null, SalString.Null, ref Class, ref LastWriteTime1, ref LastWriteTime2);
					n = n + 1;
				}
			}
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// bOk = EnumValues( rsValues[*] )
		/// fills rsValues with all the value names under the
		/// currently open path
		/// rsValues[*]	OUT	array of value names
		/// </summary>
		/// <param name="Arr">[*]</param>
		/// <returns></returns>
		public SalBoolean EnumValues(SalArray<SalString> Arr)
		{
			#region Local Variables
			SalNumber Class = 0;
			SalNumber SubValues = 0;
			SalNumber MaxSubKeyLen = 0;
			SalNumber MaxClassLen = 0;
			SalNumber Values = 0;
			SalNumber MaxValueNameLen = 0;
			SalNumber MaxValueLen = 0;
			SalNumber SecurityDescriptor = 0;
			SalNumber LastWriteTime1 = 0;
			SalNumber LastWriteTime2 = 0;
			SalNumber n = 0;
			SalNumber len = 0;
			SalNumber dummy1 = 0;
			SalNumber dummy2 = 0;
			SalString s = "";
			#endregion
			
			#region Actions
			// clear return values
			Arr.SetUpperBound(1, -1);
			// retrieve the number of value names under the current path
			m_ErrorCode = Ext.RegQueryInfoKeyW(m_CurrentKey, SalString.Null, ref Class, SalString.Null, ref SubValues, ref MaxSubKeyLen, ref MaxClassLen, ref Values, ref MaxValueNameLen, ref MaxValueLen, ref SecurityDescriptor, ref LastWriteTime1, ref 
				LastWriteTime2);
			if (m_ErrorCode == 0) 
			{
				// loop over each one
				n = 0;
				while (n < Values) 
				{
					// v1.1: Set len = MaxSubKeyLen
					// v1.2: must have space for the trailing zero
					// 25.07.12 F1210
					// Set len = MaxValueNameLen + 1
					len = MaxValueNameLen * 2 + 2;
					// read the name directly into the return array
					Sal.SetBufferLength(ref Arr.GetArray(n)[n], len);
					Ext.RegEnumValueW(m_CurrentKey, n, Arr[n], ref len, SalString.Null, ref dummy1, SalString.Null, ref dummy2);
					n = n + 1;
				}
			}
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bExists = KeyExists( sPath )
		/// Checks, if a registry path exists
		/// sPath	IN	the key (ex: "/Software/Centura")
		/// </summary>
		/// <param name="Name"></param>
		/// <returns></returns>
		public SalBoolean KeyExists(SalString Name)
		{
			#region Local Variables
			SalNumber TempKey = 0;
			#endregion
			
			#region Actions
			// try to open the key to see if it exists
			TempKey = GetKey(Name);
			// if it exists, then close it right away
			if (TempKey != 0) 
			{
				Ext.RegCloseKey(TempKey);
			}
			// return the result of the open key function
			return TempKey != 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = OpenKey( sPath, bCanCreate )
		/// sPath		Registry-Path (e.g. "/Software/Centura")
		/// bCanCreate	set to TRUE, if Path shall be created
		/// </summary>
		/// <param name="Key"></param>
		/// <param name="CanCreate"></param>
		/// <returns></returns>
		public SalBoolean OpenKey(SalString Key, SalBoolean CanCreate)
		{
			#region Local Variables
			SalBoolean Relative = false;
			SalNumber TempKey = 0;
			SalNumber Disposition = 0;
			#endregion
			
			#region Actions
			// all forward slashes must be substituted with backslashes
			// Set Key = __VisStrSubstitute( Key, '/', '\\' )
			// is it an absolute or relative path?
			Relative = IsRelativeKey(Key);
			if (!(Relative)) 
			{
				Key = StrDelete(Key, 0, 1);
			}
			// Create the key, if it doesn't exist?
			if (!(CanCreate) || (Key == SalString.Null)) 
			{
				// do not create, if not existing
				m_ErrorCode = Ext.RegOpenKeyExW(GetBaseKey(Relative), Key, 0, 0xe000f, ref TempKey);
				if (m_ErrorCode != 0) 
				{
					// maybe, you don't have enough rights so try again in read/only mode
					m_ErrorCode = Ext.RegOpenKeyExW(GetBaseKey(Relative), Key, 0, Const.KEY_ALL_READ, ref TempKey);
				}
			}
			else
			{
				// create, if not existing
				m_ErrorCode = Ext.RegCreateKeyExW(GetBaseKey(Relative), Key, 0, SalString.Null, Const.REG_OPTION_NON_VOLATILE, 0xe000f, SalString.Null, ref TempKey, ref Disposition);
			}
			// if ok, then change internal settings
			if (m_ErrorCode == 0) 
			{
				if ((m_CurrentKey != 0) && Relative) 
				{
					Key = m_CurrentPath + "\\" + Key;
				}
				ChangeKey(TempKey, Key);
			}
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = SetRootKey( nKey )
		/// sets the root for subsequent operations.
		/// see also: HKEY_xxxx constants
		/// </summary>
		/// <param name="RootKey"></param>
		/// <returns></returns>
		public SalBoolean SetRootKey(SalNumber RootKey)
		{
			#region Actions
			if (RootKey == m_RootKey) 
			{
				return true;
			}
			CloseKey();
			m_RootKey = RootKey;

			return false;
			#endregion
		}
		
		/// <summary>
		/// Set bExists = ValueExists( sValueName )
		/// Checks, if a value exists under the current path
		/// sValueName	IN	name of the value to be checked
		/// </summary>
		/// <param name="Name"></param>
		/// <returns></returns>
		public SalBoolean ValueExists(SalString Name)
		{
			#region Local Variables
			SalNumber DataSize = 0;
			SalNumber DataType = 0;
			SalString buf = "";
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Call SalSetBufferLength( buf, 4 )
			Sal.SetBufferLength(ref buf, 10);
			DataSize = 0;
			m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref buf, ref DataSize);
			return m_ErrorCode == 0;
			#endregion
		}
		// read...
		/// <summary>
		/// Set bOk = ReadBinary( sValueName, rsValue, rnValueSize )
		/// sValueName	IN	Name of the Entry
		/// rsValue		OUT	the value (see CStruct-functions)
		/// rnValueSize	IN	size that rsValue can hold
		/// 		OUT	number of bytes retrieved
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <param name="ValueSize"></param>
		/// <returns></returns>
		public SalBoolean ReadBinary(SalString Name, ref SalString Value, ref SalNumber ValueSize)
		{
			#region Local Variables
			SalNumber DataType = 0;
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Call SalSetBufferLength( Value, 1 )
			Sal.SetBufferLength(ref Value, 4);
			ValueSize = 0;
			m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref Value, ref ValueSize);
			// Error 234 means, there is more data that doesn't fit into buf
			if ((m_ErrorCode == 0) || (m_ErrorCode == 234)) 
			{
				// 25.07.12 F1210
				// Call SalSetBufferLength( Value, ValueSize )
				Sal.SetBufferLength(ref Value, ValueSize * 2 + 2);
				m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref Value, ref ValueSize);
			}
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = ReadBool( sValueName, rbValue )
		/// sValueName	IN	name of the entry
		/// rbValue		OUT	retrieved boolean value
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean ReadBool(SalString Name, ref SalBoolean Value)
		{
			#region Actions
			SalNumber temp = Value;
			return ReadInteger(Name, ref temp);
			Value = temp;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = ReadFloat( sValueName, rnValue )
		/// sValueName	IN	name of the entry
		/// rnValue		OUT	retrieved value
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="FloatValue"></param>
		/// <returns></returns>
		public SalBoolean ReadFloat(SalString Name, ref SalNumber FloatValue)
		{
			#region Local Variables
			SalNumber DataType = 0;
			SalNumber ValueSize = 0;
			SalString Value = "";
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Set ValueSize = 8
			ValueSize = 18;
			Sal.SetBufferLength(ref Value, ValueSize);
			m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref Value, ref ValueSize);
			FloatValue = Ext.CStructGetDouble(Value, 0);
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = ReadInteger( sValueName, rnValue )
		/// sValueName	IN	name of the entry
		/// rnValue		OUT	retrieved value
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean ReadInteger(SalString Name, ref SalNumber Value)
		{
			#region Local Variables
			SalNumber DataSize = 0;
			SalNumber DataType = 0;
			SalString buf = "";
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Call SalSetBufferLength( buf, 4 )
			Sal.SetBufferLength(ref buf, 10);
			DataSize = 4;
			m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref buf, ref DataSize);
			if (m_ErrorCode == 0) 
			{
				Value = Ext.CStructGetInt(buf, 0);
				return true;
			}
			return false;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = ReadString( sValueName, rsValue )
		/// sValueName	IN	name of the entry
		/// rsValue		OUT	retrieved value
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean ReadString(SalString Name, ref SalString Value)
		{
			#region Local Variables
			SalNumber DataSize = 0;
			SalNumber DataType = 0;
			SalString buf = "";
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Call SalSetBufferLength( buf, 2 )
			Sal.SetBufferLength(ref buf, 6);
			DataSize = 0;
			m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref buf, ref DataSize);
			// Error 234 means, there is more data that doesn't fit into buf
			if ((m_ErrorCode == 0) || (m_ErrorCode == 234)) 
			{
				// 25.07.12 F1210
				// Call SalSetBufferLength( buf, DataSize )
				Sal.SetBufferLength(ref buf, DataSize * 2 + 2);
				// 18.06.10 OTF414
				DataSize = DataSize * 2;

				m_ErrorCode = Ext.RegQueryValueExW(m_CurrentKey, Name, SalString.Null, ref DataType, ref buf, ref DataSize);
				if (m_ErrorCode == 0) 
				{
					Value = buf;
					return true;
				}
			}
			return false;
			#endregion
		}
		// write ...
		/// <summary>
		/// Set bOk = WriteBinary( sValueName, sValue, nSize )
		/// sValueName	IN	name of the entry
		/// sValue		IN	value to write
		/// nSize		IN	size of value
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <param name="ValueSize"></param>
		/// <returns></returns>
		public SalBoolean WriteBinary(SalString Name, SalString Value, SalNumber ValueSize)
		{
			#region Actions
			m_ErrorCode = Ext.RegSetValueExW(m_CurrentKey, Name, 0, Const.REG_BINARY, Value, ValueSize);
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = WriteBool( sValueName, bValue )
		/// sValueName	IN	name of the entry
		/// bValue		IN	value to write
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean WriteBool(SalString Name, SalBoolean Value)
		{
			#region Actions
			return WriteInteger(Name, Value);
			#endregion
		}
		
		/// <summary>
		/// Set bOk = WriteFloat( sValueName, nValue )
		/// sValueName	IN	name of the entry
		/// nValue		IN	value to write
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean WriteFloat(SalString Name, SalNumber Value)
		{
			#region Local Variables
			SalString buf = "";
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Call SalSetBufferLength( buf, 8 )
			Sal.SetBufferLength(ref buf, 18);
			Ext.CStructPutDouble(ref buf, 0, Value);
			m_ErrorCode = Ext.RegSetValueExW(m_CurrentKey, Name, 0, Const.REG_BINARY, buf, 8);
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = WriteInteger( sValueName, nValue )
		/// sValueName	IN	name of the entry
		/// nValue		IN	value to write
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean WriteInteger(SalString Name, SalNumber Value)
		{
			#region Local Variables
			SalString buf = "";
			#endregion
			
			#region Actions
			// 25.07.12 F1210
			// Call SalSetBufferLength( buf, 4 )
			Sal.SetBufferLength(ref buf, 10);
			Ext.CStructPutInt(ref buf, 0, Value);
			m_ErrorCode = Ext.RegSetValueExW(m_CurrentKey, Name, 0, Const.REG_DWORD, buf, 4);
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set bOk = WriteString( sValueName, sValue )
		/// sValueName	IN	name of the entry
		/// sValue		IN	value to write
		/// </summary>
		/// <param name="Name"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean WriteString(SalString Name, SalString Value)
		{
			#region Actions
			m_ErrorCode = Ext.RegSetValueExW(m_CurrentKey, Name, 0, Const.REG_SZ, Value, Value.Length * 2 + 1);
			return m_ErrorCode == 0;
			#endregion
		}
		// shortcuts to read/write-functions...
		/// <summary>
		/// </summary>
		/// <param name="KeyPath"></param>
		/// <param name="ValueName"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean ReadStringAt(SalString KeyPath, SalString ValueName, ref SalString Value)
		{
			#region Local Variables
			SalBoolean Ok = false;
			#endregion
			
			#region Actions
			if (OpenKey(KeyPath, false)) 
			{
				Ok = ReadString(ValueName, ref Value);
				CloseKey();
			}
			return Ok;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="KeyPath"></param>
		/// <param name="ValueName"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean ReadIntegerAt(SalString KeyPath, SalString ValueName, ref SalNumber Value)
		{
			#region Local Variables
			SalBoolean Ok = false;
			#endregion
			
			#region Actions
			if (OpenKey(KeyPath, false)) 
			{
				Ok = ReadInteger(ValueName, ref Value);
				CloseKey();
			}
			return Ok;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="KeyPath"></param>
		/// <param name="CanCreate"></param>
		/// <param name="ValueName"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean WriteStringAt(SalString KeyPath, SalBoolean CanCreate, SalString ValueName, SalString Value)
		{
			#region Local Variables
			SalBoolean Ok = false;
			#endregion
			
			#region Actions
			if (OpenKey(KeyPath, CanCreate)) 
			{
				Ok = WriteString(ValueName, Value);
				CloseKey();
			}
			return Ok;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="KeyPath"></param>
		/// <param name="CanCreate"></param>
		/// <param name="ValueName"></param>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean WriteIntegerAt(SalString KeyPath, SalBoolean CanCreate, SalString ValueName, SalNumber Value)
		{
			#region Local Variables
			SalBoolean Ok = false;
			#endregion
			
			#region Actions
			if (OpenKey(KeyPath, CanCreate)) 
			{
				Ok = WriteInteger(ValueName, Value);
				CloseKey();
			}
			return Ok;
			#endregion
		}
		// others:
		/// <summary>
		/// Set bOk = CreateKey( sKey )
		/// Creates a new key
		/// sKey	IN	name of the key path to be created
		/// </summary>
		/// <param name="Key"></param>
		/// <returns></returns>
		public SalNumber CreateKey(SalString Key)
		{
			#region Local Variables
			SalBoolean Relative = false;
			SalNumber TempKey = 0;
			SalNumber Disposition = 0;
			#endregion
			
			#region Actions
			Relative = IsRelativeKey(Key);
			if (!(Relative)) 
			{
				Key = StrDelete(Key, 1, 1);
			}
			m_ErrorCode = Ext.RegCreateKeyExW(GetBaseKey(Relative), Key, 0, SalString.Null, Const.REG_OPTION_NON_VOLATILE, Const.KEY_ALL_ACCESS, SalString.Null, ref TempKey, ref Disposition);
			if (m_ErrorCode == 0) 
			{
				Ext.RegCloseKey(TempKey);
			}
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Set nKey = GetBaseKey()
		/// Retrieves the base key handle
		/// </summary>
		/// <param name="Relative"></param>
		/// <returns></returns>
		public SalNumber GetBaseKey(SalBoolean Relative)
		{
			#region Actions
			if ((m_CurrentKey == 0) || !(Relative)) 
			{
				return GetRootKey();
			}
			return m_CurrentKey;
			#endregion
		}
		
		/// <summary>
		/// Set nKey = GetCurrentPath()
		/// Retrieves the current key handle
		/// </summary>
		/// <returns></returns>
		public SalString GetCurrentPath()
		{
			#region Actions
			return m_CurrentPath;
			#endregion
		}
		
		/// <summary>
		/// Set nErrCode = GetLastError()
		/// retrieves the return value of the most
		/// recently executed registry api
		/// </summary>
		/// <returns></returns>
		public SalNumber GetLastError()
		{
			#region Actions
			return m_ErrorCode;
			#endregion
		}
		
		/// <summary>
		/// Set nRootKey = GetRootKey()
		/// retrieves the number of the root key
		/// see also: HKEY_xxxx constants
		/// </summary>
		/// <returns></returns>
		public SalNumber GetRootKey()
		{
			#region Actions
			if (m_RootKey == 0) 
			{
				return Const.HKEY_CURRENT_USER;
			}
			return m_RootKey;
			#endregion
		}
		
		/// <summary>
		/// Set bHasSubValues = HasSubValues()
		/// return TRUE, if the currently opened key has any values
		/// </summary>
		/// <returns></returns>
		public SalBoolean HasSubValues()
		{
			#region Local Variables
			SalNumber Class = 0;
			SalNumber SubValues = 0;
			SalNumber MaxSubKeyLen = 0;
			SalNumber MaxClassLen = 0;
			SalNumber Values = 0;
			SalNumber MaxValueNameLen = 0;
			SalNumber MaxValueLen = 0;
			SalNumber SecurityDescriptor = 0;
			SalNumber LastWriteTime1 = 0;
			SalNumber LastWriteTime2 = 0;
			#endregion
			
			#region Actions
			m_ErrorCode = Ext.RegQueryInfoKeyW(m_CurrentKey, SalString.Null, ref Class, SalString.Null, ref SubValues, ref MaxSubKeyLen, ref MaxClassLen, ref Values, ref MaxValueNameLen, ref MaxValueLen, ref SecurityDescriptor, ref LastWriteTime1, ref 
				LastWriteTime2);
			if (m_ErrorCode == 0) 
			{
				return SubValues > 0;
			}
			return m_ErrorCode == 0;
			#endregion
		}
		
		/// <summary>
		/// Call SetLazyWrite( bSwitchOn )
		/// Set the behaviour of CloseKey(). If set to FALSE,
		/// all changed get written back to disk immediately
		/// as soon as CloseKey() is called
		/// bSwitchOn	IN	TRUE = use RegCloseKey
		/// 			FALSE = use RegFlushKey
		/// </summary>
		/// <param name="OnOff"></param>
		/// <returns></returns>
		public SalNumber SetLazyWrite(SalBoolean OnOff)
		{
			#region Actions
			m_LazyWrite = OnOff;

			return 0;
			#endregion
		}
		// internals, do not use:
		/// <summary>
		/// </summary>
		/// <param name="hKey"></param>
		/// <param name="NewPath"></param>
		/// <returns></returns>
		public SalNumber ChangeKey(SalNumber hKey, SalString NewPath)
		{
			#region Actions
			CloseKey();
			m_CurrentKey = hKey;
			m_CurrentPath = NewPath;

			return 0;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="Value"></param>
		/// <returns></returns>
		public SalBoolean IsRelativeKey(SalString Value)
		{
			#region Actions
			if (Value != SalString.Null) 
			{
				if (Value.Left(1) != "\\") 
				{
					return true;
				}
			}
			return false;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="Key"></param>
		/// <returns></returns>
		public SalNumber GetKey(SalString Key)
		{
			#region Local Variables
			SalBoolean Relative = false;
			SalNumber TempKey = 0;
			SalNumber Disposition = 0;
			#endregion
			
			#region Actions
			// Set Key = __VisStrSubstitute( Key, '/', '\\' )
			Relative = IsRelativeKey(Key);
			if (!(Relative)) 
			{
				Key = StrDelete(Key, 0, 1);
			}
			m_ErrorCode = Ext.RegOpenKeyExW(GetBaseKey(Relative), Key, 0, Const.KEY_ALL_ACCESS, ref TempKey);
			if (m_ErrorCode != 0) 
			{
				m_ErrorCode = Ext.RegOpenKeyExW(GetBaseKey(Relative), Key, 0, Const.KEY_ALL_READ, ref TempKey);
				if (m_ErrorCode != 0) 
				{
					return 0;
				}
			}
			return TempKey;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="Source"></param>
		/// <param name="At">beginnend mit 0</param>
		/// <param name="NumChars"></param>
		/// <returns></returns>
		public SalString StrDelete(SalString Source, SalNumber At, SalNumber NumChars)
		{
			#region Local Variables
			SalNumber Len = 0;
			SalString SL = "";
			SalString SR = "";
			#endregion
			
			#region Actions
			Len = Source.Length;
			if (At >= Len) 
			{
				return Source;
			}
			SL = Source.Left(At);
			SR = Source.Right(Len - At - NumChars);
			return SL + SR;
			#endregion
		}
		#endregion
	}
}
