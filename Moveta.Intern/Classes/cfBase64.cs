// <ppj name="Moveta.Intern" date="1/17/2024 7:59:41 AM" id="F4EC85BAD2BF79AC25C9F8643540E90F9BE1DAF0"/>
// ======================================================================================================
// This code was generated by the Ice Porter(tm) Tool version 4.8.15.0
// Ice Porter is part of The Porting Project (PPJ) by Ice Tea Group, LLC.
// The generated code is not guaranteed to be accurate and to compile without
// manual modifications.
// 
// ICE TEA GROUP LLC SHALL IN NO EVENT BE LIABLE FOR ANY DAMAGES WHATSOEVER
// (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
// INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER LOSS OF ANY KIND)
// ARISING OUT OF THE USE OR INABILITY TO USE THE GENERATED CODE, WHETHER
// DIRECT, INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR OTHERWISE, REGARDLESS
// OF THE FORM OF ACTION, EVEN IF ICE TEA GROUP LLC HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
// =====================================================================================================
using System;
using System.Text;
using System.Drawing;
using System.Diagnostics;
using System.Collections;
using System.Windows.Forms;
using System.ComponentModel;
using MT;
using PPJ.Runtime;
using PPJ.Runtime.Com;
using PPJ.Runtime.Sql;
using PPJ.Runtime.Vis;
using PPJ.Runtime.Windows;
using PPJ.Runtime.Windows.QO;
using PPJ.Runtime.XSal;

namespace Moveta.Intern
{
	
	/// <summary>
	/// </summary>
	public class cfBase64 : SalFunctionalClass
	{
		#region Fields
		public static SalArray<SalNumber> cv_nBase64DecodeLookup = new SalArray<SalNumber>(256);
		public static SalArray<SalString> cv_sBase64EncodeLookup = new SalArray<SalString>();
		#endregion
		
		#region Constructors/Destructors
		#endregion
		
		#region Methods
		
		/// <summary>
		/// Converts 3 bytes in to 4 chars. out. Quoted from http://email.about.com/cs/standards/a/base64_encoding.htm -
		/// "[F]or example, the three bytes are 155, 162 and 233, the corresponding (and frightening) bit stream is
		/// 100110111010001011101001, which in turn corresponds to the 6-bit values 38, 58, 11 and 41.
		/// 
		/// These numbers are converted to ASCII characters in the second step using the Base64 encoding table. The 6-bit values
		/// of our example translate to the ASCII sequence "m6Lp".
		/// 
		/// [JL: i.e., rearrange 3-bytes( 24 bits) from 3x8 "10011011 10100010 11101001" to 4x6 "100110 111010 001011 101001" and convert to chars.]
		/// 
		/// 155 -> 10011011
		/// 162 -> 10100010
		/// 233 -> 11101001
		/// 
		/// 100110 -> 38
		/// 111010 -> 58
		/// 001011 -> 11
		/// 101001 -> 41
		/// 
		/// 38 -> m
		/// 58 -> 6
		/// 11 -> L
		/// 41 -> p"
		/// </summary>
		/// <param name="sBytesIn"></param>
		/// <returns></returns>
		public SalString __Encode3BytesToQuadChars(SalString sBytesIn)
		{
			#region Local Variables
			SalNumber b0 = 0;
			SalNumber b1 = 0;
			SalNumber b2 = 0;
			SalNumber b3 = 0;
			SalString sB = "";
			SalArray<SalNumber> b = new SalArray<SalNumber>(3);
			#endregion
			
			#region Actions
			if (sBytesIn.Length != 3) 
			{
				return SalString.Null;
			}
			// 1st, convert each char. in sBytesIn to #
			sB = sBytesIn.Mid(0, 1);
			b[0] = Sal.StrLop(ref sB);
			sB = sBytesIn.Mid(1, 1);
			b[1] = Sal.StrLop(ref sB);
			sB = sBytesIn.Mid(2, 1);
			b[2] = Sal.StrLop(ref sB);
			// VB: b0 = SHR2(b(0)) And &H3F
			b0 = __SHR2(b[0]) & 0x003f;

			// 12/2007: special-case for "x00"
			// VB: b1 = SHL4(b(0) And &H3) Or (SHR4(b(1)) And &HF)
			// 20.11.19 F4576 Kommentierung aufgehoben plus "If b[1] = 48 AND b[1] = 48" -> "If b[1] = 48 AND b[2] = 48"
			if (b[1] == 48 && b[2] == 48) 
			{
				b1 = __SHL4((b[0] & 0x0003));
			}
			else
			{
				b1 = __SHL4((b[0] & 0x0003)) | (__SHR4(b[1]) & 0x000f);
			}
			// Set b1 = __SHL4( b[0] & 0x3 ) | (__SHR4( b[1] ) & 0xF )

			// VB: b2 = SHL2(b(1) And &HF) Or (SHR6(b(2)) And &H3)
			b2 = __SHL2((b[1] & 0x000f)) | (__SHR6(b[2]) & 0x0003);
			// VB: b3 = b(2) And &H3F
			b3 = b[2] & 0x003f;

			return cfBase64.cv_sBase64EncodeLookup[b0] + cfBase64.cv_sBase64EncodeLookup[b1] + cfBase64.cv_sBase64EncodeLookup[b2] + cfBase64.cv_sBase64EncodeLookup[b3];
			#endregion
		}
		
		/// <summary>
		/// inits. cv_nBase64DecodeLookup[256] so encoded values map back to #s.
		/// </summary>
		/// <returns></returns>
		public SalNumber __InitBase64DecodeLookup()
		{
			#region Local Variables
			SalNumber nCurrent = 0;
			SalNumber nIndex = 0;
			SalNumber nFirst = 0;
			SalNumber nLast = 0;
			SalString sFirst = "";
			SalString sLast = "";
			#endregion
			
			#region Actions
			nIndex = 0;
			while (nIndex < 256) 
			{
				cfBase64.cv_nBase64DecodeLookup[nIndex] = -1;
				nIndex = nIndex + 1;
			}

			nIndex = 0;
			sFirst = "A";
			nFirst = Sal.StrLop(ref sFirst);
			sLast = "Z";
			nLast = Sal.StrLop(ref sLast);
			nCurrent = nFirst;
			while (nCurrent <= nLast) 
			{
				cfBase64.cv_nBase64DecodeLookup[nCurrent] = nIndex;
				nCurrent = nCurrent + 1;
				nIndex = nIndex + 1;
			}

			sFirst = "a";
			nFirst = Sal.StrLop(ref sFirst);
			sLast = "z";
			nLast = Sal.StrLop(ref sLast);
			nCurrent = nFirst;
			while (nCurrent <= nLast) 
			{
				cfBase64.cv_nBase64DecodeLookup[nCurrent] = nIndex;
				nCurrent = nCurrent + 1;
				nIndex = nIndex + 1;
			}

			sFirst = "0";
			nFirst = Sal.StrLop(ref sFirst);
			sLast = "9";
			nLast = Sal.StrLop(ref sLast);
			nCurrent = nFirst;
			while (nCurrent <= nLast) 
			{
				cfBase64.cv_nBase64DecodeLookup[nCurrent] = nIndex;
				nCurrent = nCurrent + 1;
				nIndex = nIndex + 1;
			}

			sFirst = "+";
			nCurrent = Sal.StrLop(ref sFirst);
			cfBase64.cv_nBase64DecodeLookup[nCurrent] = nIndex;

			nIndex = nIndex + 1;
			sFirst = "/";
			nCurrent = Sal.StrLop(ref sFirst);
			cfBase64.cv_nBase64DecodeLookup[nCurrent] = nIndex;

			nIndex = nIndex + 1;
			sFirst = "=";
			nCurrent = Sal.StrLop(ref sFirst);
			cfBase64.cv_nBase64DecodeLookup[nCurrent] = nIndex;

			return 0;
			#endregion
		}
		
		/// <summary>
		/// init. cv_sBase64EncodeLookup[*] for all legal Base64 chars: A-Z, a-z, 0-9, '+', '/'
		/// </summary>
		/// <returns></returns>
		public SalNumber __InitBase64EncodeLookup()
		{
			#region Local Variables
			SalNumber nCurrent = 0;
			SalNumber nIndex = 0;
			SalNumber nFirst = 0;
			SalNumber nLast = 0;
			SalString sFirst = "";
			SalString sLast = "";
			#endregion
			
			#region Actions
			nIndex = 0;
			sFirst = "A";
			nFirst = Sal.StrLop(ref sFirst);
			sLast = "Z";
			nLast = Sal.StrLop(ref sLast);
			nCurrent = nFirst;
			while (nCurrent <= nLast) 
			{
				cfBase64.cv_sBase64EncodeLookup[nIndex] = nCurrent.ToCharacter();
				nCurrent = nCurrent + 1;
				nIndex = nIndex + 1;
			}

			sFirst = "a";
			nFirst = Sal.StrLop(ref sFirst);
			sLast = "z";
			nLast = Sal.StrLop(ref sLast);
			nCurrent = nFirst;
			while (nCurrent <= nLast) 
			{
				cfBase64.cv_sBase64EncodeLookup[nIndex] = nCurrent.ToCharacter();
				nCurrent = nCurrent + 1;
				nIndex = nIndex + 1;
			}

			sFirst = "0";
			nFirst = Sal.StrLop(ref sFirst);
			sLast = "9";
			nLast = Sal.StrLop(ref sLast);
			nCurrent = nFirst;
			while (nCurrent <= nLast) 
			{
				cfBase64.cv_sBase64EncodeLookup[nIndex] = nCurrent.ToCharacter();
				nCurrent = nCurrent + 1;
				nIndex = nIndex + 1;
			}

			sFirst = "+";
			nCurrent = Sal.StrLop(ref sFirst);
			cfBase64.cv_sBase64EncodeLookup[nIndex] = nCurrent.ToCharacter();

			nIndex = nIndex + 1;
			sFirst = "/";
			nCurrent = Sal.StrLop(ref sFirst);
			cfBase64.cv_sBase64EncodeLookup[nIndex] = nCurrent.ToCharacter();

			return 0;
			#endregion
		}
		
		/// <summary>
		/// Shift 8-bit value to left by 2 bits
		/// </summary>
		/// <param name="nByte"></param>
		/// <returns></returns>
		public SalNumber __SHL2(SalNumber nByte)
		{
			#region Actions
			// VB: SHL2 = (bytValue * &H4) And &HFF
			return (nByte * 0x0004) & 0x00ff;
			#endregion
		}
		
		/// <summary>
		/// Shift 8-bit value to left by 4 bits
		/// </summary>
		/// <param name="nByte"></param>
		/// <returns></returns>
		public SalNumber __SHL4(SalNumber nByte)
		{
			#region Actions
			// VB: SHL4 = (bytValue * &H10) And &HFF
			return (nByte * 0x0010) & 0x00ff;
			#endregion
		}
		
		/// <summary>
		/// Shift 8-bit value to left by 6 bits
		/// </summary>
		/// <param name="nByte"></param>
		/// <returns></returns>
		public SalNumber __SHL6(SalNumber nByte)
		{
			#region Actions
			// VB: SHL6 = (bytValue * &H40) And &HFF
			return (nByte * 0x0040) & 0x00ff;
			#endregion
		}
		
		/// <summary>
		/// Shift 8-bit value to right by 2 bits
		/// </summary>
		/// <param name="nByte"></param>
		/// <returns></returns>
		public SalNumber __SHR2(SalNumber nByte)
		{
			#region Actions
			// VB: SHR2 = bytValue \ &H4
			return nByte / 0x0004;
			#endregion
		}
		
		/// <summary>
		/// Shift 8-bit value to right by 4 bits
		/// </summary>
		/// <param name="nByte"></param>
		/// <returns></returns>
		public SalNumber __SHR4(SalNumber nByte)
		{
			#region Actions
			// VB: SHR4 = bytValue \ &H10
			return nByte / 0x0010;
			#endregion
		}
		
		/// <summary>
		/// Shift 8-bit value to right by 6 bits
		/// </summary>
		/// <param name="nByte"></param>
		/// <returns></returns>
		public SalNumber __SHR6(SalNumber nByte)
		{
			#region Actions
			// VB: SHR6 = bytValue \ &H40
			return nByte / 0x0040;
			#endregion
		}
		
		/// <summary>
		/// Return Byte array of decoded binary values given base64 string. Ignores any chars not in the 64-char subset.
		/// </summary>
		/// <param name="sEncodedIn"></param>
		/// <returns></returns>
		public SalString DecodeBase64(SalString sEncodedIn)
		{
			#region Local Variables
			SalNumber C = 0;
			SalNumber i = 0;
			SalNumber nLen = 0;
			SalArray<SalNumber> d = new SalArray<SalNumber>(4);
			SalNumber dI = 0;
			SalString sDecoded = "";
			SalString s = "";
			#endregion
			
			#region Actions
			nLen = sEncodedIn.Length;
			if (nLen < 4)  // invalid encoding - min. len. = 4 (ex: "a" encodes as --> "YQ==")
			{
				return sEncodedIn;
			}
			Sal.WaitCursor(true);
			i = 0;
			dI = 0;
			sDecoded = "";
			while (i < nLen) 
			{
				s = sEncodedIn.Mid(i, 1);
				C = Sal.StrLop(ref s);
				C = cfBase64.cv_nBase64DecodeLookup[C];
				if (C >= 0) 
				{
					d[dI] = C;
					dI = dI + 1;
					if (dI == 4) 
					{
						// VB: abDecoded(iIndex) = SHL2(d(0)) Or (SHR4(d(1)) And &H3)
						sDecoded = sDecoded + (__SHL2(d[0]) | (__SHR4(d[1]) & 0x0003)).ToCharacter();
						// VB: abDecoded(iIndex+1) = SHL4(d(1) And &HF) Or (SHR2(d(2)) And &HF)
						sDecoded = sDecoded + (__SHL4((d[1] & 0x000f)) | (__SHR2(d[2]) & 0x000f)).ToCharacter();
						// VB: abDecoded(iIndex+2) = SHL6(d(2) And &H3) Or d(3)
						sDecoded = sDecoded + (__SHL6((d[2] & 0x0003)) | d[3]).ToCharacter();
						if (i == nLen - 1)  // at the end, see if any "=" chars
						{
							if (d[3] == 64) 
							{
								sDecoded = sDecoded.Left(sDecoded.Length - 1);
							}
							// 12/2007: NO 2nd lop - fix to account for special-case "x00" in __Encode3BytesToQuadChars()
							// If d[2] = 64
							// Set sDecoded = SalStrLeftX( sDecoded, SalStrLength( sDecoded )-1 )
						}

						dI = 0;
					}
				}

				i = i + 1;
			}

			Sal.WaitCursor(false);
			return sDecoded;
			#endregion
		}
		
		/// <summary>
		/// Returns base64 encoding of Byte array (here passed as a string).
		/// Does not insert CRLFs. Just returns one long string, so it's up to the user to add line breaks or other formatting.
		/// </summary>
		/// <param name="sBytesIn"></param>
		/// <returns></returns>
		public SalString EncodeBase64(SalString sBytesIn)
		{
			#region Local Variables
			SalString sLast = "";
			SalString sLocalIn = "";
			SalString sOutput = "";
			SalString s3Bytes = "";
			SalNumber i = 0;
			SalNumber nLen = 0;
			SalNumber nQuants = 0;
			#endregion
			
			#region Actions
			// be sure lookup arrays are initialized
			if (cfBase64.cv_nBase64DecodeLookup[0] != -1 || cfBase64.cv_sBase64EncodeLookup[0] != "A") 
			{
				InitBase64Lookups();
			}

			nLen = sBytesIn.Length;
			if (nLen == 0) 
			{
				return SalString.Null;
			}

			Sal.WaitCursor(true);
			nQuants = (nLen / 3).Truncate(10, 0);
			sLocalIn = sBytesIn;
			if (nQuants > 0) 
			{
				sOutput = "";
				i = 0;
				while (i < nQuants) 
				{
					s3Bytes = sLocalIn.Mid(i * 3, 3);
					sOutput = sOutput + __Encode3BytesToQuadChars(s3Bytes);
					i = i + 1;
				}
			}
			switch (nLen.Mod(3))
			{
				case 0:
					sLast = "";
					break;
				
				case 1:
					s3Bytes = sLocalIn.Right(1) + "00";
					sLast = __Encode3BytesToQuadChars(s3Bytes);
					// replace last 2 with '=='
					sLast = sLast.Left(2) + "==";
					break;
				
				case 2:
					s3Bytes = sLocalIn.Right(2) + "0";
					sLast = __Encode3BytesToQuadChars(s3Bytes);
					// replace last 1 with '='
					sLast = sLast.Left(3) + "=";
					break;
			}

			sOutput = sOutput + sLast;
			Sal.WaitCursor(false);
			return sOutput;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public SalNumber InitBase64Lookups()
		{
			#region Actions
			__InitBase64EncodeLookup();
			__InitBase64DecodeLookup();

			return 0;
			#endregion
		}
		#endregion
	}
}
