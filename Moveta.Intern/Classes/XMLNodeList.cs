// <ppj name="Moveta.Intern" date="1/17/2024 7:59:41 AM" id="F4EC85BAD2BF79AC25C9F8643540E90F9BE1DAF0"/>
// ======================================================================================================
// This code was generated by the Ice Porter(tm) Tool version 4.8.15.0
// Ice Porter is part of The Porting Project (PPJ) by Ice Tea Group, LLC.
// The generated code is not guaranteed to be accurate and to compile without
// manual modifications.
// 
// ICE TEA GROUP LLC SHALL IN NO EVENT BE LIABLE FOR ANY DAMAGES WHATSOEVER
// (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
// INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER LOSS OF ANY KIND)
// ARISING OUT OF THE USE OR INABILITY TO USE THE GENERATED CODE, WHETHER
// DIRECT, INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR OTHERWISE, REGARDLESS
// OF THE FORM OF ACTION, EVEN IF ICE TEA GROUP LLC HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
// =====================================================================================================
using System;
using System.Text;
using System.Drawing;
using System.Diagnostics;
using System.Collections;
using System.Windows.Forms;
using System.ComponentModel;
using MT;
using PPJ.Runtime;
using PPJ.Runtime.Com;
using PPJ.Runtime.Sql;
using PPJ.Runtime.Vis;
using PPJ.Runtime.Windows;
using PPJ.Runtime.Windows.QO;
using PPJ.Runtime.XSal;

namespace Moveta.Intern
{
	
	/// <summary>
	/// </summary>
	public class XMLNodeList : SalFunctionalClass
	{
		#region Fields
		public SalArray<XMLNode> children = new SalArray<XMLNode>();
		public SalNumber nIteratorIndex = 0;
		#endregion
		
		#region Constructors/Destructors
		#endregion
		
		#region Methods
		
		/// <summary>
		/// </summary>
		/// <param name="index"></param>
		/// <returns></returns>
		public XMLNode item(SalNumber index)
		{
			#region Local Variables
			XMLNode node = new XMLNode();
			#endregion
			
			#region Actions
			node = children[index];
			return node;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public SalNumber length()
		{
			#region Local Variables
			SalNumber bound = 0;
			#endregion
			
			#region Actions
			if (children.IsEmpty) 
			{
				return 0;
			}
			bound = children.GetUpperBound(1);
			return bound + 1;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <returns></returns>
		public SalNumber reset()
		{
			#region Actions
			children.SetUpperBound(1, -1);
			nIteratorIndex = 0;

			return 0;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="returnNode"></param>
		/// <returns></returns>
		public SalBoolean first(XMLNode returnNode)
		{
			#region Local Variables
			SalNumber nBound = 0;
			#endregion
			
			#region Actions
			nIteratorIndex = 0;
			nBound = children.GetUpperBound(1);
			if (nBound >= 0) 
			{
				returnNode = children[nIteratorIndex];
				return true;
			}
			returnNode = null;
			return false;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="returnNode"></param>
		/// <returns></returns>
		public SalBoolean next(XMLNode returnNode)
		{
			#region Local Variables
			SalNumber nBound = 0;
			#endregion
			
			#region Actions
			nBound = children.GetUpperBound(1);
			if (nIteratorIndex + 1 <= nBound) 
			{
				nIteratorIndex = nIteratorIndex + 1;
				returnNode = children[nIteratorIndex];
				return true;
			}
			returnNode = null;
			return false;
			#endregion
		}
		
		/// <summary>
		/// </summary>
		/// <param name="returnNode"></param>
		/// <returns></returns>
		public SalBoolean previous(XMLNode returnNode)
		{
			#region Local Variables
			SalNumber nBound = 0;
			#endregion
			
			#region Actions
			nBound = children.GetUpperBound(1);
			if (((bool)(nIteratorIndex - 1 >= 0)) && (nBound >= 0)) 
			{
				nIteratorIndex = nIteratorIndex - 1;
				returnNode = children[nIteratorIndex];
				return true;
			}
			returnNode = null;
			return false;
			#endregion
		}
		#endregion
	}
}
